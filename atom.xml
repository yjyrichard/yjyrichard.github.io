<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yangjiayu</title>
  
  
  <link href="https://yjyrichard.github.io/atom.xml" rel="self"/>
  
  <link href="https://yjyrichard.github.io/"/>
  <updated>2025-12-17T12:18:09.226Z</updated>
  <id>https://yjyrichard.github.io/</id>
  
  <author>
    <name>Yangjiayu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”</title>
    <link href="https://yjyrichard.github.io/posts/137ed813.html"/>
    <id>https://yjyrichard.github.io/posts/137ed813.html</id>
    <published>2025-12-17T12:11:21.928Z</published>
    <updated>2025-12-17T12:18:09.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”"><a href="#【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”" class="headerlink" title="【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”"></a>【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”</h3><p>今天傍晚在地铁上刷到了巫师那个关于房地产的视频，两万字的文稿，将近半小时多的视频，看完我CPU都快烧了。为了防止大家跟我一样晕，我把这期视频的核心逻辑，用我学生能听懂的“游戏术语”和“生活案例”重新盘了一遍。</p><p>省流版核心：<strong>房价下跌是必然，但国家在努力让它“慢动作”下跌，只要你不急，时间就是你的朋友。</strong></p><p>下面我们分三步拆解。</p><h3 id="第一部分：GM（游戏管理员）的视角——为什么不能让房价直接崩盘？"><a href="#第一部分：GM（游戏管理员）的视角——为什么不能让房价直接崩盘？" class="headerlink" title="第一部分：GM（游戏管理员）的视角——为什么不能让房价直接崩盘？"></a>第一部分：GM（游戏管理员）的视角——为什么不能让房价直接崩盘？</h3><p>视频里提到的“主神”，其实就是国家的决策层，我们可以理解为<strong>地球Online中国服的GM</strong>。</p><p><strong>1. “锚”是什么？其实就是你的“肝”</strong><br>巫师说“锚”是劳动时间。说白了，在这个社会游戏里，钱是虚的，你每天打工、熬夜复习、做实验付出的<strong>“寿命”和“精力”</strong>才是真正的货币。<br>房子，就是GM设计的一个超级昂贵的“装备”。为了买这个装备，大家都在疯狂“肝”（劳动），从而建设了社会。</p><p><strong>2. 为什么不能直接崩？</strong><br>假设你为了买一把“屠龙刀”（房子），背了30年的债。</p><ul><li><strong>硬着陆（崩盘）：</strong> 明天GM突然宣布，屠龙刀不值钱了，人手一把。你是不是心态崩了？你会觉得“我不玩了”，甚至想把服务器砸了（社会动荡）。如果大家都躺平不干活，银行全是坏账，服务器就挂了。</li><li><strong>软着陆（现在的策略）：</strong> GM知道这刀不值钱了，但他把降价过程拉长到20年。今年降一点，明年降一点。</li></ul><p><strong>GM的策略叫“分摊痛苦”：</strong><br>原本小A买房亏了300万，他可能会跳楼。<br>现在变成：小A亏50万卖给小B，小B亏50万卖给小C……大家虽然都亏了，但每个人只亏一点点，都能咬牙活下去，社会秩序就稳住了。</p><h3 id="第二部分：市场真相——你以为的利好，其实是“止疼药”"><a href="#第二部分：市场真相——你以为的利好，其实是“止疼药”" class="headerlink" title="第二部分：市场真相——你以为的利好，其实是“止疼药”"></a>第二部分：市场真相——你以为的利好，其实是“止疼药”</h3><p><strong>1. 政策是用来“哄”你的</strong><br>经常看到新闻说“取消限购”、“降低首付”、“救房企”。<br>这不是为了让房价大涨，而是<strong>怕大家都不玩了</strong>。<br>这就好比打篮球，比分落后太多，有人喊“把球给我，我要回家”。这时候必须得哄着他：“别走别走，规则改一下，再玩会儿。”<br><strong>目的：</strong> 维持交易量，让击鼓传花的游戏能继续慢慢传下去，而不是突然停在某人手里。</p><p><strong>2. 保交楼 = 救项目不救老板</strong><br>国家现在是“保交楼”，让开发商把烂尾楼盖完，但不管开发商老板死活。<br>这就像你的小组作业（盖楼），组长（恒大等）摆烂了，老师（国家）按着组长的头说：“你挂科无所谓，但这作业你必须给我写完，不能坑了组员（买房人）。”</p><h3 id="第三部分：作为普通人（买方-卖方），我们该怎么办？"><a href="#第三部分：作为普通人（买方-卖方），我们该怎么办？" class="headerlink" title="第三部分：作为普通人（买方/卖方），我们该怎么办？"></a>第三部分：作为普通人（买方/卖方），我们该怎么办？</h3><p>这是最实用的部分，巫师给了非常犀利的建议。</p><h4 id="1-给手里有房想卖的人（或者你爸妈）："><a href="#1-给手里有房想卖的人（或者你爸妈）：" class="headerlink" title="1. 给手里有房想卖的人（或者你爸妈）："></a>1. 给手里有房想卖的人（或者你爸妈）：</h4><ul><li><strong>核心法则：早跑就是赚。</strong><br>不要幻想房价会涨回去。现在的逻辑是“比惨”。<ul><li>如果你现在卖，亏了50万。</li><li>你邻居死扛着不卖，两年后他亏了100万。</li><li><strong>恭喜你，你相对于邻居，赚了50万。</strong> 这叫“相对收益”。</li></ul></li><li><strong>别在这个时候谈信仰。</strong> 只要有人愿意接盘，赶紧出手。</li></ul><h4 id="2-给还没买房的人："><a href="#2-给还没买房的人：" class="headerlink" title="2. 给还没买房的人："></a>2. 给还没买房的人：</h4><ul><li><p><strong>核心法则：别急，做时间的朋友。</strong><br>现在是买方市场。房价在阴跌，你每晚买一个月，可能就省出一台迈巴赫（夸张手法，但确实省很多）。<br><strong>只要你不买，你就永远有主动权。</strong></p></li><li><p><strong>租房真有那么惨吗？</strong><br>从经济账算，租房绝对划算。但巫师提到了一个<strong>“心态成本”</strong>。<br>很多父母觉得“没房就没有家”，这种焦虑是很难克服的。如果你为了消除这种焦虑非要买，那就买吧，这就叫为“情绪价值”买单。</p></li></ul><h4 id="3-避坑指南：千万别买“未来的贫民窟”"><a href="#3-避坑指南：千万别买“未来的贫民窟”" class="headerlink" title="3. 避坑指南：千万别买“未来的贫民窟”"></a>3. 避坑指南：千万别买“未来的贫民窟”</h4><p>这是视频里最吓人的一点。<br><strong>什么房子不能买？</strong></p><ul><li><strong>高密度高层住宅：</strong> 住的人多，还没钱。</li><li><strong>物业差的小区：</strong><br>想象一下，电梯坏了没人修，外墙脱落砸死人，垃圾堆成山。大家都不交物业费，有钱人先搬走，剩下的都是没钱搬走的。这个小区就会陷入<strong>“没钱维护 -&gt; 环境变差 -&gt; 房价暴跌 -&gt; 更没人交钱”</strong>的死循环。<br>这就是未来的<strong>贫民窟</strong>。</li></ul><p><strong>买房建议：</strong></p><ol><li><strong>选好物业：</strong> 贵的物业费其实是在保护你的房价。</li><li><strong>宁做凤尾，不做鸡头：</strong> 哪怕买小一点，也要去富人区/高知区。因为那里的人不仅有钱维护小区，而且好沟通，不会为了修个电梯吵三年。</li><li><strong>别碰期房：</strong> 现在的期房质量堪忧（为了省成本减配），要买就买看得见的现房。</li></ol><hr><h3 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h3><p>看完这期视频，我最大的感触是：<strong>祛魅</strong>。</p><p>以前觉得房地产是宏大的经济叙事，现在看透了，它就是一个<strong>“击鼓传花”+“慢慢泄气”</strong>的过程。</p><ul><li><strong>对于国家：</strong> 稳定压倒一切，慢刀割肉，不能崩盘。</li><li><strong>对于我们：</strong> 现在的房价正在进入“垃圾时间”。除非你家里有矿，或者是为了结婚不得不买的刚需，否则，<strong>拿着现金，租个好房子，该吃吃该喝喝，看别人卷生卷死，可能是未来十年最聪明的活法。</strong></li></ul><p>希望这个“人话版”总结能帮你看懂那个复杂的视频！如果觉得有用，请给我这个苦逼的大三学生点个赞吧！</p><p>视频地址：【【巫师】吃透中国房价，但是主神视角】 <a href="https://www.bilibili.com/video/BV1fqmiBSE1y/?share_source=copy_web&amp;vd_source=b0f2742e7b4a2838ad4d1870af693bc1">https://www.bilibili.com/video/BV1fqmiBSE1y/?share_source=copy_web&amp;vd_source=b0f2742e7b4a2838ad4d1870af693bc1</a></p>]]></content>
    
    
    <summary type="html">【大三学生-观后感】两万字解析中国房价？我把“巫师”的视频翻译成了“人话”</summary>
    
    
    
    <category term="其他" scheme="https://yjyrichard.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="https://yjyrichard.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>管理统计学期末复习</title>
    <link href="https://yjyrichard.github.io/posts/3f1d912a.html"/>
    <id>https://yjyrichard.github.io/posts/3f1d912a.html</id>
    <published>2025-12-11T10:10:40.483Z</published>
    <updated>2025-12-17T12:17:20.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管理统计学期末复习"><a href="#管理统计学期末复习" class="headerlink" title="管理统计学期末复习"></a>管理统计学期末复习</h1><p>我希望以<strong>“先见森林，再见树木”</strong>的复习策略，让你真正掌握统计学的精髓，而不仅仅是为了应付考试。</p><p>管理统计学（Management Statistics）的核心其实就一句话：<strong>如何在不确定性中，利用数据做出科学的决策。</strong></p><h3 id="第一层：底层逻辑——统计学到底在干嘛？"><a href="#第一层：底层逻辑——统计学到底在干嘛？" class="headerlink" title="第一层：底层逻辑——统计学到底在干嘛？"></a>第一层：底层逻辑——统计学到底在干嘛？</h3><p>在管理学中，我们每天都要做决策。但由于时间、成本和能力的限制，我们通常面临两个问题：</p><ol><li><strong>数据太多，看不懂</strong>（信息过载）。</li><li><strong>数据太少，不敢定</strong>（无法获取全体数据）。</li></ol><p>统计学就是为了解决这两个问题而生的。</p><ol><li><strong>描述统计 (Descriptive Statistics)</strong><ul><li><strong>解决问题：</strong> 数据太多，看不懂。</li><li><strong>作用：</strong> 把一大堆杂乱无章的数据，通过<strong>图表</strong>（直方图、饼图）和<strong>数字</strong>（平均数、方差）总结出来。</li><li><strong>通俗理解：</strong> 给数据画个“素描”。比如你期末考试所有科目的平均分，就是对你一学期表现的“描述”。</li></ul></li><li><strong>推断统计 (Inferential Statistics)</strong><ul><li><strong>解决问题：</strong> 数据太少（只有样本），想知道全体的情况。</li><li><strong>作用：</strong> 利用小部分数据（样本），去猜测（估计）整体的情况，并告诉你这个猜测有多靠谱（假设检验）。</li><li><strong>通俗理解：</strong> “尝一勺汤知道整锅咸淡”。这才是统计学最迷人、最难，也是最有用的部分。</li></ul></li></ol><hr><h3 id="第二层：笔记详解与核心概念梳理"><a href="#第二层：笔记详解与核心概念梳理" class="headerlink" title="第二层：笔记详解与核心概念梳理"></a>第二层：笔记详解与核心概念梳理</h3><h4 id="1-数据的“生命周期”"><a href="#1-数据的“生命周期”" class="headerlink" title="1. 数据的“生命周期”"></a>1. 数据的“生命周期”</h4><p>统计工作是有流水线的：</p><ul><li><strong>收集 → 预处理 (审核/筛选/排序) → 整理 → 分析</strong><ul><li><strong>实战意义：</strong> 如果以后你在公司做数据分析，<strong>70%的时间会花在“预处理”上</strong>（清洗脏数据）。如果数据源头是错的（比如问卷乱填），后面用再高级的模型也是“垃圾进，垃圾出”。</li></ul></li></ul><h4 id="2-认识数据：给数据贴标签"><a href="#2-认识数据：给数据贴标签" class="headerlink" title="2. 认识数据：给数据贴标签"></a>2. 认识数据：给数据贴标签</h4><p>这是考试必考点，也是分析的基础。因为<strong>数据类型决定了你能用什么分析方法</strong>。</p><ul><li><strong>分类数据 (Categorical)</strong>：<ul><li><strong>无序：</strong> 比如“男/女”、“制造业/金融业”。（你不能说金融业 &gt; 制造业，它们只是不同）。</li><li><strong>有序：</strong> 比如“优秀/良好/一般”。（这里有等级之分，但不能量化差距，你不能说“优秀”减去“良好”等于多少）。</li></ul></li><li><strong>数值数据 (Numerical/Quantitative)</strong>：<ul><li><strong>离散：</strong> 比如“班级人数”。（只能是整数，不能有2.5个人）。</li><li><strong>连续：</strong> 比如“身高”、“GDP”。（可以无限细分）。</li></ul></li></ul><blockquote><p><strong>💡 为什么要分这么细？</strong></p><ul><li>如果是分类数据（比如性别），你算“平均性别”是没有意义的，你只能算<strong>比例</strong>（60%是男性）。</li><li>如果是数值数据（比如收入），你才能算<strong>平均值</strong>、<strong>标准差</strong>。</li></ul></blockquote><ul><li><strong>数据来源</strong>：<ul><li><strong>观测数据</strong>：只是看，不干预（比如记录过去10年的房价）。</li><li><strong>实验数据</strong>：人为控制变量（比如把用户分两组，一组给优惠券，一组不给，看购买率差异 —— 这就是互联网著名的 <strong>A/B Test</strong>）。</li></ul></li></ul><h4 id="3-统计学的灵魂：总体-vs-样本"><a href="#3-统计学的灵魂：总体-vs-样本" class="headerlink" title="3. 统计学的灵魂：总体 vs 样本"></a>3. 统计学的灵魂：总体 vs 样本</h4><p>这是整门课最核心的概念！</p><ul><li><strong>总体 (Population)</strong>：你想要研究的所有对象的集合（比如：<strong>全国</strong>所有人的身高）。<ul><li>描述总体的数字叫<strong>参数 (Parameter)</strong>。通常用希腊字母表示：$\mu$ (均值), $\sigma$ (标准差)。</li><li><em>特点：它是上帝视角的真理，通常是未知的（因为普查太贵太难）。</em></li></ul></li><li><strong>样本 (Sample)</strong>：你实际抽出来调查的那一部分人（比如：随机抽取的<strong>1000</strong>人）。<ul><li>描述样本的数字叫<strong>统计量 (Statistic)</strong>。通常用拉丁字母表示：$\bar{x}$ (均值), $s$ (标准差)。</li><li><em>特点：它是我们要计算的，用来猜测上帝视角的工具。</em></li></ul></li></ul><blockquote><p><strong>💡 这里的逻辑是：</strong><br>我们算出样本的 $\bar{x}$（统计量），是为了去估计总体的 $\mu$（参数）。因为 $\bar{x}$ 是变动的（每次抽的人不一样），而 $\mu$ 是固定的真理。</p></blockquote><hr><h3 id="第三层：实战演练"><a href="#第三层：实战演练" class="headerlink" title="第三层：实战演练"></a>第三层：实战演练</h3><p>为了巩固上面的概念，我们直接做第三张图的题。这种题期末考试大概率出现在选择或填空题里。</p><h4 id="1-1-指出变量类型"><a href="#1-1-指出变量类型" class="headerlink" title="1.1 指出变量类型"></a>1.1 指出变量类型</h4><ul><li><strong>(1) 年龄</strong>：<strong>数值变量</strong>（连续或离散均可，通常视为连续）。可以计算平均年龄。</li><li><strong>(2) 性别</strong>：<strong>分类变量</strong>（无序）。只能算男女比例。</li><li><strong>(3) 汽车产量</strong>：<strong>数值变量</strong>（离散，因为车是一辆辆产的）。</li><li><strong>(4) 员工态度（赞成、中立、反对）</strong>：<strong>分类变量</strong>（<strong>有序</strong>）。注意这里有等级之分。</li><li><strong>(5) 支付方式（现金、信用卡等）</strong>：<strong>分类变量</strong>（无序）。</li></ul><h4 id="1-2-案例分析：2000个家庭推断全市收入"><a href="#1-2-案例分析：2000个家庭推断全市收入" class="headerlink" title="1.2 案例分析：2000个家庭推断全市收入"></a>1.2 案例分析：2000个家庭推断全市收入</h4><p>这个例子完美展示了统计学的过程。</p><ul><li><strong>总体</strong>：该城市<strong>所有</strong>职工家庭。</li><li><strong>样本</strong>：被抽取的<strong>2000个</strong>家庭。</li><li><strong>参数</strong>：该城市<strong>所有</strong>职工家庭的年人均收入（未知的真理值，记为 $\mu$）。</li><li><strong>统计量</strong>：那<strong>2000个</strong>家庭的年人均收入（我们算出来的具体数字，记为 $\bar{x}$）。</li></ul><h4 id="1-3-案例分析：IT从业者调查"><a href="#1-3-案例分析：IT从业者调查" class="headerlink" title="1.3 案例分析：IT从业者调查"></a>1.3 案例分析：IT从业者调查</h4><ul><li><strong>(1) 这一研究的总体是什么？</strong><ul><li>注意！不是“所有人”，也不是“1000人”。</li><li>答案：<strong>所有的IT从业者</strong>。（这是你要推断的目标群体）。</li></ul></li><li><strong>(2) 月收入是分类变量还是数值变量？</strong><ul><li>答案：<strong>数值变量</strong>。（钱是数字，可以运算）。</li></ul></li><li><strong>(3) 消费支付方式是分类变量还是数值变量？</strong><ul><li>答案：<strong>分类变量</strong>。（信用卡、支付宝等是类别，不是数字）。</li></ul></li></ul><hr><h3 id="第四层：学完了有什么用？（现实世界的意义）"><a href="#第四层：学完了有什么用？（现实世界的意义）" class="headerlink" title="第四层：学完了有什么用？（现实世界的意义）"></a>第四层：学完了有什么用？（现实世界的意义）</h3><p>你说不想只为了考试，那我们聊聊在实际管理工作中，这些有什么用？</p><p><strong>1. 市场营销：精准画像 (描述统计)</strong></p><ul><li><strong>场景</strong>：你是某奶茶店店长。</li><li><strong>应用</strong>：你记录了每天的销售数据。通过<strong>描述统计</strong>，你发现“周末下午2点-4点”是高峰期（众数），且顾客多为“18-25岁女性”（分类数据）。</li><li><strong>决策</strong>：在这个时间段增加兼职人手，并推出针对年轻女性的“闺蜜拼团套餐”。</li></ul><p><strong>2. 质量管理：六西格玛 (方差/标准差)</strong></p><ul><li><strong>场景</strong>：你在工厂生产手机屏幕。</li><li><strong>应用</strong>：平均厚度达标（均值 $\bar{x}$ 很好）就够了吗？不够。如果有的太厚有的太薄，虽然平均值没问题，但残次品率很高。你需要关注<strong>方差/标准差 ($s^2, s$)</strong>。</li><li><strong>决策</strong>：统计学的意义在于<strong>控制波动</strong>。标准差越小，说明你的工艺越稳，这就是大名鼎鼎的“六西格玛”管理的核心。</li></ul><p><strong>3. 风险投资：不要把鸡蛋放在一个篮子里 (相关性分析)</strong></p><ul><li><strong>场景</strong>：你要配置公司的资产。</li><li><strong>应用</strong>：笔记图1里提到了“相关分析”。如果你发现A股票涨的时候，B股票也跟着涨（正相关），那买这两个就没有分散风险的作用。</li><li><strong>决策</strong>：你要找负相关的资产（A跌B涨），利用统计学中的<strong>相关系数</strong>来构建投资组合，对冲风险。</li></ul><p><strong>4. 互联网运营：A/B Test (假设检验/推断统计)</strong></p><ul><li><strong>场景</strong>：抖音要改版点赞按钮的颜色，红色好还是蓝色好？</li><li><strong>应用</strong>：不能拍脑袋决定。随机抽取1%的用户看红色，1%看蓝色。如果红色组的点击率比蓝色高了5%，这是真的高，还是偶然误差？</li><li><strong>决策</strong>：利用<strong>假设检验</strong>（计算P值），如果P &lt; 0.05，说明这“显著”有效，全量上线红色按钮。</li></ul><p>统计学不是数学游戏，它是<strong>“讲证据”的艺术</strong>。你在复习时，每看到一个公式，试着问自己：<em>“这个公式是为了帮老板解决什么管理问题的？”</em> 这样学起来会通透很多！</p><h2 id="描述性统计"><a href="#描述性统计" class="headerlink" title="描述性统计"></a>描述性统计</h2><p>如果说上一部分是“搭骨架”，这一部分就是在“填血肉”。描述统计的核心任务只有两个字：<strong>浓缩</strong>。我们要把成千上万条数据，浓缩成<strong>几个图</strong>和<strong>几个数</strong>，让老板一眼看懂。</p><hr><h3 id="模块一：数据的来源与质量"><a href="#模块一：数据的来源与质量" class="headerlink" title="模块一：数据的来源与质量"></a>模块一：数据的来源与质量</h3><p>这一块通常考选择题或简答题，概念清楚即可。</p><p><strong>1. 抽样方法（重中之重）</strong></p><ul><li><strong>概率抽样 (Probability Sampling)</strong>：<strong>必须掌握</strong>。只有这种方法才能做后面的“推断统计”。<ul><li><em>简单随机</em>：像抽奖一样，每个人被抽到的概率相同。</li><li><em>分层抽样</em>：先分类再抽（如：先分男生女生，再各自抽）。<strong>优点：提高精度。</strong></li></ul></li><li><strong>非概率抽样</strong>：<ul><li><em>方便抽样</em>：街头拦人。优点是快，缺点是不准。</li><li><em>滚雪球抽样</em>：找一个人，让他推荐下一个人。<strong>场景：</strong> 调查难以接触的群体（如吸毒者、高端私密圈子）。</li></ul></li></ul><p><strong>2. 误差（理解逻辑）</strong></p><ul><li><strong>抽样误差</strong>：<strong>不可避免</strong>。只要不是普查，就一定有误差。这是运气问题。</li><li><strong>非抽样误差</strong>：<strong>人为错误</strong>。比如填错了、问卷设计有诱导性、数据录入错了。这是可以避免的。<ul><li><em>实战意义</em>：作为管理者，你很难控制抽样误差（除非加钱扩大样本），但你必须严抓非抽样误差（数据清洗、流程规范）。</li></ul></li></ul><hr><h3 id="模块二：图表描述-——-给数据“照相”"><a href="#模块二：图表描述-——-给数据“照相”" class="headerlink" title="模块二：图表描述 —— 给数据“照相”"></a>模块二：图表描述 —— 给数据“照相”</h3><p>考试中，通常会给你一个图，让你分析数据特征。</p><p><strong>1. 箱形图 (Boxplot) —— 这里的王者</strong><br>这是<strong>管理统计学中最重要</strong>的图表之一。</p><ul><li><strong>它能看什么？</strong><ol><li><strong>中位数</strong>：中间那条线。</li><li><strong>分散程度</strong>：箱子越长，数据越散（意见越不统一）。</li><li><strong>异常值 (Outliers)</strong>：箱子外面的点。</li></ol></li><li><strong>实战场景</strong>：假如你是区域经理，对比A、B两个分店的业绩。<ul><li>A店箱子很短，且高：说明A店大家业绩都很稳，且都很好。</li><li>B店箱子很长：说明B店也是有人行有人不行，管理混乱。</li><li>B店上方有个离群点：说明B店有个“销冠”大神，要把他的经验萃取出来。</li></ul></li></ul><hr><h3 id="模块三：数据的集中趋势-——-寻找“大概位置”"><a href="#模块三：数据的集中趋势-——-寻找“大概位置”" class="headerlink" title="模块三：数据的集中趋势 —— 寻找“大概位置”"></a>模块三：数据的<strong>集中趋势</strong> —— 寻找“大概位置”</h3><p>这是计算题的高频区。</p><p><strong>1. 平均数 vs 中位数 vs 众数</strong></p><ul><li><strong>平均数 (Mean, $\bar{x}$)</strong>：最常用，但<strong>最怕极端值</strong>。<ul><li><em>例子</em>：马云走进一家普通的酒吧，酒吧里所有人的“平均财富”瞬间变成亿万富翁。这能代表大家很有钱吗？不能。</li></ul></li><li><strong>中位数 (Median, $Me$)</strong>：排在正中间的数。<strong>不受极端值影响</strong>（马云来了，中位数还是那个普通人的钱）。<ul><li><em>结论</em>：<strong>研究收入、房价等贫富差距大的数据时，看中位数更靠谱。</strong></li></ul></li><li><strong>众数 (Mode, $M_0$)</strong>：出现最多的数。适合分类数据（如：卖得最好的鞋码是40号）。</li></ul><p><strong>2. 偏态分布下的关系</strong><br>这三个图非常经典，一定要背下来：</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251211224546504.png" alt="image-20251211224546504"></p><ul><li><strong>对称分布</strong>：均值 = 中位数 = 众数。</li><li><strong>右偏分布 (正偏)</strong>：尾巴往右边拖（像长尾巴）。<ul><li><strong>记忆口诀</strong>：平均数是被极值“拉”着跑的。尾巴在右边（有极大的值），平均数就被拉向右边。</li><li>关系：$\bar{x} &gt; Me &gt; M_0$</li></ul></li><li><strong>左偏分布 (负偏)</strong>：尾巴往左边拖（有极小的值）。<ul><li>关系：$\bar{x} &lt; Me &lt; M_0$</li></ul></li></ul><p><strong>3. 四分位数 (Quantiles)</strong></p><ul><li>计算位置的公式 $Position = (n+1) \times P\%$。</li><li><strong>关键点</strong>：算出来的是<strong>位置</strong>，不是数值！算出来位置是7.75，意味着你要找第7个和第8个数，按 0.75 的比例去插值。</li></ul><hr><h3 id="模块四：数据的离散程度-——-衡量“靠谱程度”"><a href="#模块四：数据的离散程度-——-衡量“靠谱程度”" class="headerlink" title="模块四：数据的离散程度 —— 衡量“靠谱程度”"></a>模块四：数据的<strong>离散程度</strong> —— 衡量“靠谱程度”</h3><p>这部分是很多同学的痛点，但其实最有意思。<br><strong>如果说平均数代表“收益”，那离散程度就代表“风险”。</strong></p><p><strong>1. 方差与标准差 (Variance &amp; Std Dev)</strong></p><ul><li><strong>核心公式</strong>：<ul><li><strong>样本方差分母是 $n-1$</strong>。</li><li><strong>总体方差分母是 $N$</strong>。</li><li><em>为什么？</em> “为了保证无偏性”。通俗解释：因为我们用样本均值代替了总体均值，消耗了一个“自由度”，如果除以 $n$，算出来的方差会偏小，所以要除以 $n-1$ 来修正。</li></ul></li><li><strong>实战意义</strong>：<ul><li>你买股票，A股票平均收益10%，标准差2%；B股票平均收益10%，标准差20%。买哪个？</li><li>买A。因为B虽然平均也是10%，但它可能今天涨50%，明天跌30%（波动大），心脏受不了。<strong>标准差越大，风险越高。</strong></li></ul></li></ul><p><strong>2. 离散系数 (CV, Coefficient of Variation)</strong></p><ul><li><strong>解决问题</strong>：比较不同单位或量级数据的波动。</li><li><em>例子</em>：大象的体重波动（单位：吨）和蚂蚁的体重波动（单位：克），谁的变异程度大？直接比标准差没法比。</li><li><strong>公式</strong>：$CV = \frac{标准差}{平均值}$。消除量纲影响，比的是“相对波动”。</li></ul><p><strong>3. 标准分数 (Z-score)</strong></p><ul><li><strong>公式</strong>：$z = \frac{x - \bar{x}}{s}$</li><li><strong>作用</strong>：把数据标准化。</li><li><strong>判断异常值</strong>：一般认为，如果一个数据的 $Z$ 分数大于3（即偏离平均值3个标准差以上），它就是个异常值（Outlier）。</li></ul><hr><h3 id="模块五：分布形状"><a href="#模块五：分布形状" class="headerlink" title="模块五：分布形状"></a>模块五：分布形状</h3><ul><li><strong>偏度 (Skewness)</strong>：衡量歪不歪。<ul><li>SK &gt; 0：右偏（尾巴在右）。</li><li>SK &lt; 0：左偏（尾巴在左）。</li></ul></li><li><strong>峰度 (Kurtosis)</strong>：衡量尖不尖。<ul><li>K &gt; 0：尖峰（数据非常集中）。</li><li>K &lt; 0：扁平（数据很散）。</li><li><em>金融应用</em>：<strong>“肥尾效应”</strong>。如果峰度很高，意味着中间很尖，两头尾巴其实也会变厚（虽然图上看不明显）。这意味着发生极端事件（黑天鹅）的概率比正态分布预测的要大。</li></ul></li></ul><hr><h3 id="给你的复习建议（针对这一章）"><a href="#给你的复习建议（针对这一章）" class="headerlink" title="给你的复习建议（针对这一章）"></a>给你的复习建议（针对这一章）</h3><ol><li><strong>计算器准备好</strong>：<ul><li>一定要亲手算一道<strong>分组数据</strong>的平均数和方差（利用组中值 $m_i$）。期末考试大题往往是给你一个频率分布表，让你算均值和标准差。</li></ul></li><li><strong>死磕关系图</strong>：<ul><li>闭上眼睛能画出左偏、右偏分布图，并标出均值、中位数的位置。</li></ul></li><li><strong>理解 $n-1$</strong>：<ul><li>考试选择题如果问“计算样本方差时分母是多少”，选 $n-1$。</li></ul></li><li><strong>实际案例联想</strong>：<ul><li>看到平均数，想“平均薪资”不可靠。</li><li>看到标准差，想“股票风险”或“产品质量稳定性”。</li><li>看到中位数，想“排除马云后的真实收入”。</li></ul></li></ol><p>这部分是统计学的地基，地基打牢了，后面学推断统计（区间估计、假设检验）时，只要把 $\bar{x}$ 换成概率分布，逻辑是一模一样的！继续加油！</p><h2 id="推断统计"><a href="#推断统计" class="headerlink" title="推断统计"></a>推断统计</h2><p>我们把书本上的条条框框先拆掉，按照<strong>“管理决策的逻辑流”</strong>，从头到尾把<strong>推断统计（参数估计）</strong>这一章重新构建一遍。</p><p>我们要解决的核心问题只有一个：<strong>上帝视角的真理（总体参数）我看不到，我手里只有一小撮数据（样本统计量），我该怎么向老板汇报？</strong></p><p>整个推断统计的体系，其实就只有<strong>三步走</strong>。</p><hr><h3 id="第一步：点估计-——-给老板一个“最靠谱的猜测”"><a href="#第一步：点估计-——-给老板一个“最靠谱的猜测”" class="headerlink" title="第一步：点估计 —— 给老板一个“最靠谱的猜测”"></a>第一步：点估计 —— 给老板一个“最靠谱的猜测”</h3><p><strong>1. 需求场景</strong><br>老板问：“我们要在这个城市开分店，这里的人平均月薪（$\mu$）是多少？”<br>你肯定不能把全城几百万人都调查一遍（成本太高）。你只随机调查了100个人（$n=100$）。</p><p><strong>2. 解决方案</strong><br>你算了一下这100个人的平均工资是 8000元（$\bar{x}=8000$）。<br>于是你跟老板说：“老板，我觉得全市平均工资大概就是 <strong>8000</strong>。”</p><p>这就是<strong>点估计</strong>：直接把样本的指标（$\bar{x}$），当成总体的指标（$\mu$）。</p><p><strong>3. 这里的逻辑（为什么敢这么干？）</strong><br>因为我们相信数学上的三个原则：</p><ul><li><strong>无偏性</strong>：虽然这次可能高了或低了，但在理论上，$\bar{x}$ 的期望就是 $\mu$。</li><li><strong>有效性</strong>：$\bar{x}$ 的波动比其他瞎猜的方法小。</li><li><strong>一致性</strong>：样本越多越准。</li></ul><p><strong>4. 痛点</strong><br>老板不傻，他会问：“<strong>准吗？</strong> 刚好8000？不可能吧？是7999还是8001？”<br>点估计最大的缺点是：<strong>它没告诉你误差有多大，命中率几乎为0</strong>（因为连续数据要在数轴上精准命中某一点，概率为0）。</p><hr><h3 id="第二步：区间估计-——-给猜测加一个“安全气囊”"><a href="#第二步：区间估计-——-给猜测加一个“安全气囊”" class="headerlink" title="第二步：区间估计 —— 给猜测加一个“安全气囊”"></a>第二步：区间估计 —— 给猜测加一个“安全气囊”</h3><p><strong>1. 需求升级</strong><br>为了严谨，你不能只给一个数。你要给一个<strong>范围</strong>，并且告诉老板这个范围有多<strong>可信</strong>。</p><p><strong>2. 解决方案逻辑（核心公式的诞生）</strong><br>我们在<strong>第一章</strong>学过“标准分数（Z分数）”，对吧？</p><script type="math/tex; mode=display">Z = \frac{\text{某个数} - \text{均值}}{\text{标准差}}</script><p>在推断统计里，<strong>核心逻辑</strong>就是把这个公式变个形：</p><ul><li><strong>前提（中心极限定理）</strong>：统计学家告诉我们，不管总体长什么样，只要样本量够大，<strong>样本均值 $\bar{x}$ 的分布</strong>就会服从正态分布。</li><li><strong>公式推导（不用背，看一眼就懂）</strong>：<script type="math/tex; mode=display">Z = \frac{\bar{x} - \mu}{\sigma / \sqrt{n}}</script>我们现在的目标是求 $\mu$（总体均值）。我们把公式变换一下，把 $\mu$ 留在左边：<script type="math/tex; mode=display">\mu = \bar{x} \pm Z \times \frac{\sigma}{\sqrt{n}}</script></li></ul><p><strong>3. 那个著名的公式就出来了：</strong></p><script type="math/tex; mode=display">\text{置信区间} = \text{点估计} \pm (\text{可靠系数} \times \text{标准误})</script><ul><li><strong>点估计</strong>：$\bar{x}$（你的观测值，比如8000）。</li><li><strong>标准误</strong>：$\frac{\sigma}{\sqrt{n}}$（<strong>样本均值的标准差</strong>）。<ul><li><em>注意：这里为什么要除以 $\sqrt{n}$？</em> 因为平均值比单个数据更稳定。<strong>样本越多（n越大），平均值波动越小，估得越准。</strong></li></ul></li><li><strong>可靠系数</strong>：$Z$ 或 $t$（这就用到了<strong>三大分布</strong>！）。</li></ul><hr><h3 id="第三步：量化风险-——-搞懂“置信水平”与“显著性水平”"><a href="#第三步：量化风险-——-搞懂“置信水平”与“显著性水平”" class="headerlink" title="第三步：量化风险 —— 搞懂“置信水平”与“显著性水平”"></a>第三步：量化风险 —— 搞懂“置信水平”与“显著性水平”</h3><p>这一步是为了确定公式里的那个 $Z$（可靠系数）到底取多少。</p><p><strong>1. 置信水平 (Confidence Level, $1-\alpha$)</strong></p><ul><li><strong>人话</strong>：你希望你的这一网下去，<strong>有多大把握</strong>能捞到真理？</li><li><strong>最常用的标准</strong>：<strong>95%</strong> ($0.95$)。</li><li><strong>对应的 Z 值</strong>：查表可得，95% 对应的是 <strong>1.96</strong>。<ul><li><em>意思是：$\bar{x}$ 往左往右各偏 1.96 个标准误差，就能覆盖住 95% 的可能性。</em></li></ul></li></ul><p><strong>2. 显著性水平 (Significance Level, $\alpha$)</strong></p><ul><li><strong>人话</strong>：你容忍的<strong>犯错概率</strong>是多少？</li><li>如果置信水平是 95%，那犯错概率 $\alpha = 5\%$ ($0.05$)。</li><li>这就是“显著性水平”。</li></ul><p><strong>3. 这一步的产出</strong><br>你跟老板汇报：“老板，我有 <strong>95% 的把握</strong>（置信水平），全市平均工资在 <strong>7800 到 8200 之间</strong>（置信区间）。”<br>潜台词：我也承认有 <strong>5% 的可能</strong>（显著性水平），这个结论是错的，真实工资其实是 20000 或者 2000，但我尽力了。</p><hr><h3 id="第四步：实战工具箱-——-到底该用-Z，t，还是-chi-2-？"><a href="#第四步：实战工具箱-——-到底该用-Z，t，还是-chi-2-？" class="headerlink" title="第四步：实战工具箱 —— 到底该用 Z，t，还是 $\chi^2$？"></a>第四步：实战工具箱 —— 到底该用 Z，t，还是 $\chi^2$？</h3><p>到了考试或实际应用，最难的是<strong>选公式</strong>。我们把三大分布也就是在这里派上用场的。</p><h4 id="场景-A：估算平均值-比如：平均工资、平均寿命"><a href="#场景-A：估算平均值-比如：平均工资、平均寿命" class="headerlink" title="场景 A：估算平均值 (比如：平均工资、平均寿命)"></a>场景 A：估算平均值 (比如：平均工资、平均寿命)</h4><p>这是最常见的。公式模型：$\bar{x} \pm \text{系数} \times \text{标准误}$</p><ol><li><strong>如果你知道总体的标准差 $\sigma$</strong>（上帝视角）：<ul><li><strong>用 Z 分布</strong>。</li><li>系数查 Z 表（比如 1.96）。</li></ul></li><li><strong>如果你不知道 $\sigma$，只有样本标准差 $S$</strong>（现实情况通常如此）：<ul><li><strong>大样本 ($n \ge 30$)</strong>：虽然理论上用 t，但 t 分布在大样本下和 Z 几乎一样，所以<strong>也可以用 Z</strong>。</li><li><strong>小样本 ($n &lt; 30$)</strong>：必须<strong>用 t 分布</strong>。</li><li><em>为什么要用 t？</em> 因为 $S$ 不准，我们需要把区间拉宽一点来容错，t 分布的尾巴更厚，算出来的区间会比 Z 宽一点，更保守。</li></ul></li></ol><h4 id="场景-B：估算比例-比如：支持率、次品率"><a href="#场景-B：估算比例-比如：支持率、次品率" class="headerlink" title="场景 B：估算比例 (比如：支持率、次品率)"></a>场景 B：估算比例 (比如：支持率、次品率)</h4><ul><li>比如：调查某产品的次品率 $p$。</li><li><strong>用 Z 分布</strong>。</li><li>公式：$p \pm Z \sqrt{\frac{p(1-p)}{n}}$</li></ul><h4 id="场景-C：估算方差-波动-比如：机器精度的稳定性"><a href="#场景-C：估算方差-波动-比如：机器精度的稳定性" class="headerlink" title="场景 C：估算方差/波动 (比如：机器精度的稳定性)"></a>场景 C：估算方差/波动 (比如：机器精度的稳定性)</h4><ul><li>老板问：“这个机器生产零件的<strong>误差范围</strong>（方差 $\sigma^2$）是多少？”</li><li>这里不能用 Z 或 t 了，因为方差是平方数，不能是负的。</li><li><strong>用 $\chi^2$ 分布 (卡方分布)</strong>。</li><li>逻辑：构造一个基于平方和的区间。</li></ul><h4 id="场景-D：比较两个总体的方差-比如：机器A和机器B谁更稳？"><a href="#场景-D：比较两个总体的方差-比如：机器A和机器B谁更稳？" class="headerlink" title="场景 D：比较两个总体的方差 (比如：机器A和机器B谁更稳？)"></a>场景 D：比较两个总体的方差 (比如：机器A和机器B谁更稳？)</h4><ul><li><strong>用 F 分布</strong>。</li><li>逻辑：看 $\frac{S_A^2}{S_B^2}$ 这个比值是不是接近 1。</li></ul><hr><h3 id="总结：推断统计的思维导图"><a href="#总结：推断统计的思维导图" class="headerlink" title="总结：推断统计的思维导图"></a>总结：推断统计的思维导图</h3><p>复习的时候，按这个顺序思考，就不会乱：</p><ol><li><strong>目的</strong>：用样本估总体。</li><li><strong>方法</strong>：先点估计（给个基准数），再区间估计（给个范围）。</li><li><strong>构造区间</strong>：<script type="math/tex; mode=display">\text{结果} = \text{点估计} \pm \text{系数} \times \text{标准误}</script></li><li><strong>确定系数（找分布）</strong>：<ul><li>你要算<strong>平均值</strong>吗？<ul><li>知道 $\sigma$ 吗？ $\to$ <strong>Z</strong></li><li>不知道 $\sigma$ 且样本小？ $\to$ <strong>t</strong></li></ul></li><li>你要算<strong>波动（方差）</strong>吗？ $\to$ <strong>$\chi^2$</strong></li><li>你要<strong>比波动</strong>吗？ $\to$ <strong>F</strong></li></ul></li><li><strong>确定范围</strong>：<ul><li>看置信水平 ($1-\alpha$)，通常是 95%。</li></ul></li></ol><p>这就是推断统计的完整逻辑闭环。所有的公式变化，都是在这个框架里换不同的零件而已。现在对这三大分布的“分工”是不是清晰点了？</p><p><strong>统计学最忌讳的就是“死记公式”</strong>。如果你只背公式，考试时只要题目换个马甲（比如把“灯泡寿命”换成“电池续航”），你立刻就懵了。</p><p>要摆脱“套公式”的感觉，我们需要建立<strong>“诊断思维”</strong>。就像医生看病一样，先看症状，再开药方（选公式）。</p><p>我们来解剖它们，看看在拿到题目的一瞬间，大脑是如何判断该用哪个公式的。</p><hr><h3 id="第一局：这是“上帝视角”还是“凡人视角”？（Z-vs-t）"><a href="#第一局：这是“上帝视角”还是“凡人视角”？（Z-vs-t）" class="headerlink" title="第一局：这是“上帝视角”还是“凡人视角”？（Z vs t）"></a>第一局：这是“上帝视角”还是“凡人视角”？（Z vs t）</h3><p>请看两个例题。它们看起来都是求“平均值的置信区间”，但解法完全不同。</p><h4 id="案例-A：袋装食品重量"><a href="#案例-A：袋装食品重量" class="headerlink" title="案例 A：袋装食品重量"></a>案例 A：袋装食品重量</h4><blockquote><p><strong>题目核心信息</strong>：</p><ol><li>抽取 $n=25$ 袋。</li><li>已知“<strong>总体</strong>标准差为 10克”。</li><li>求 95% 置信区间。</li></ol></blockquote><ul><li><p><strong>诊断过程（大脑独白）</strong>：</p><ul><li><strong>Step 1：我要估什么？</strong> $\to$ 平均重量（总体均值 $\mu$）。</li><li><strong>Step 2：我看得到上帝视角的真理吗？</strong> $\to$ 题目说了“<strong>总体</strong>标准差为10”。</li><li><strong>Step 3：判决！</strong> 既然知道了总体标准差（$\sigma$），这就是<strong>上帝视角</strong>。不管样本量是多是少（虽然25&lt;30），只要 $\sigma$ 已知，直接用最完美的 <strong>Z分布</strong>。</li></ul></li><li><p><strong>开药方（公式）</strong>：</p><script type="math/tex; mode=display">\bar{x} \pm Z_{\alpha/2} \frac{\sigma}{\sqrt{n}}</script><ul><li>$\sigma = 10$（直接代入，不用算样本方差）。</li></ul></li></ul><hr><h4 id="案例-B：灯泡使用寿命"><a href="#案例-B：灯泡使用寿命" class="headerlink" title="案例 B：灯泡使用寿命"></a>案例 B：灯泡使用寿命</h4><blockquote><p><strong>题目核心信息</strong>：</p><ol><li>抽取 $n=16$ 个灯泡。</li><li>数据列了一堆（1510, 1450…），<strong>没提</strong>总体标准差。</li><li>求 95% 置信区间。</li></ol></blockquote><ul><li><p><strong>诊断过程（大脑独白）</strong>：</p><ul><li><strong>Step 1：我要估什么？</strong> $\to$ 平均寿命（总体均值 $\mu$）。</li><li><strong>Step 2：我看得到上帝视角的真理吗？</strong> $\to$ 题目没给 $\sigma$。我手里只有这16个烂数据。</li><li><strong>Step 3：样本够大吗？</strong> $\to$ $n=16$，小于30，属于<strong>小样本</strong>。</li><li><strong>Step 4：判决！</strong> 没有上帝视角（$\sigma$未知），样本又少（穷），只能用宽容度更高的 <strong>t分布</strong>。</li></ul></li><li><p><strong>开药方（公式）</strong>：</p><script type="math/tex; mode=display">\bar{x} \pm t_{\alpha/2}(n-1) \frac{s}{\sqrt{n}}</script><ul><li><strong>注意点</strong>：这里公式里是 $s$（样本标准差），你需要按计算器先算出这16个数的标准差 $s=24.77$。</li><li><strong>查表</strong>：查的是 $t$ 表，自由度是 $16-1=15$。</li></ul></li></ul><blockquote><p><strong>💡 总结：</strong></p><ul><li>看到“<strong>总体</strong>标准差” $\to$ <strong>Z</strong> (不管n大小)</li><li>没看到“总体”，且 $n&lt;30$ $\to$ <strong>t</strong></li><li>没看到“总体”，但 $n&gt;30$ $\to$ <strong>Z</strong> (因为大样本下 t 和 Z 差不多，大部分教材允许用 Z)</li></ul></blockquote><hr><h3 id="第二局：两个世界怎么比？（双样本均值之差）"><a href="#第二局：两个世界怎么比？（双样本均值之差）" class="headerlink" title="第二局：两个世界怎么比？（双样本均值之差）"></a>第二局：两个世界怎么比？（双样本均值之差）</h3><p>这是考试中最复杂的公式（看起来很吓人），但逻辑很简单。</p><h4 id="案例-C：两个学校的分数差异（对应图4左下角）"><a href="#案例-C：两个学校的分数差异（对应图4左下角）" class="headerlink" title="案例 C：两个学校的分数差异（对应图4左下角）"></a>案例 C：两个学校的分数差异（对应图4左下角）</h4><blockquote><p><strong>场景</strong>：你想知道A校和B校的学生，平均分差多少？</p><ul><li>A校抽46人，均分86，方差$S_1$。</li><li>B校抽33人，均分78，方差$S_2$。</li></ul></blockquote><ul><li><p><strong>诊断过程（大脑独白）</strong>：</p><ul><li><strong>Step 1：目标是什么？</strong> $\to$ 找差距 ($\mu_1 - \mu_2$)。</li><li><strong>Step 2：样本是独立的吗？</strong> $\to$ 是的，A校学生和B校学生没关系（如果是同一个学生补课前后的成绩，那就是“配对样本”，公式不一样，但这里是独立）。</li><li><strong>Step 3：方差（波动）一样吗？</strong> $\to$<ul><li><strong>情况1（图4公式下半部分 $S_p^2$）</strong>：如果我们假设两个学校虽然平均分不同，但<strong>学生水平参差不齐的程度（方差）是一样的</strong>（$\sigma_1^2 = \sigma_2^2$）。</li><li><strong>判决</strong>：既然方差一样，那不如把两组数据倒进一个大池子里算一个“混合方差”（Pooled Variance, $S_p^2$）。这样算得更准。</li><li><strong>情况2（图4公式上半部分 $v$）</strong>：如果A校是普通中学（分化大），B校是精英中学（都很强，分化小），方差明显不同（$\sigma_1^2 \ne \sigma_2^2$）。</li><li><strong>判决</strong>：不能混合，必须用那个超级复杂的自由度公式（Satterthwaite近似）。</li></ul></li></ul></li><li><p><strong>考试技巧</strong>：</p><ul><li>通常题目会告诉你“<strong>假设两总体方差相等</strong>”。看到这句话，马上反应：<strong>用混合方差 $S_p^2$ 的 t 检验公式</strong>。就是笔记里写着 $n_1+n_2-2$ 自由度的那个。</li></ul></li></ul><hr><h3 id="第三局：老板要多准？（样本量的确定）"><a href="#第三局：老板要多准？（样本量的确定）" class="headerlink" title="第三局：老板要多准？（样本量的确定）"></a>第三局：老板要多准？（样本量的确定）</h3><p>这通常是填空题或第一道大题。</p><h4 id="案例-D：倒推人数"><a href="#案例-D：倒推人数" class="headerlink" title="案例 D：倒推人数"></a>案例 D：倒推人数</h4><blockquote><p><strong>题目</strong>：要做市场调查，要求误差不超过 400元 ($E=400$)，标准差约为 2000元 ($\sigma=2000$)，置信水平 95% ($Z=1.96$)。问要抽多少人？</p></blockquote><ul><li><p><strong>逻辑（不是背公式，是解方程）</strong>：<br>我们知道误差公式是：</p><script type="math/tex; mode=display">E = Z \times \frac{\sigma}{\sqrt{n}}</script><p>老板限定了 $E$，让你求 $n$。直接移项：</p><script type="math/tex; mode=display">\sqrt{n} = \frac{Z \times \sigma}{E} \implies n = \frac{Z^2 \sigma^2}{E^2}</script></li><li><p><strong>必须要懂的“坑”：进位取整</strong></p><ul><li>你看笔记里算出来 $n = 96.04$。</li><li><strong>能取 96 吗？</strong> 哪怕是 96.0001，也要取 <strong>97</strong>。</li><li><strong>为什么？</strong> 因为样本越多，误差越小。如果是 96人，误差刚好比 400 稍微大了一丢丢（比如 400.1元），就不符合老板要求了。所以必须<strong>向上取整</strong>。</li></ul></li></ul><hr><h3 id="🔥-模拟实战：现在轮到你了"><a href="#🔥-模拟实战：现在轮到你了" class="headerlink" title="🔥 模拟实战：现在轮到你了"></a>🔥 模拟实战：现在轮到你了</h3><p>我不给答案，你根据上面的逻辑，判断下面三个场景该用什么公式？（告诉我用 Z 还是 t，还是其他？）</p><p><strong>练习 1：大选预测</strong></p><blockquote><p>某报社想预测A候选人的支持率。随机采访了 1000 位市民 ($n=1000$)，其中 550 人支持。请构建 95% 的置信区间。</p><ul><li><strong>你的诊断</strong>：这是求均值还是比例？样本量大吗？用什么分布？</li></ul></blockquote><p><strong>练习 2：新药测试</strong></p><blockquote><p>研发了一款新止痛药。在 10 名志愿者身上测试药效持续时间 ($n=10$)。算得样本标准差为 1.5小时。假设药效服从正态分布。求平均药效的 95% 置信区间。</p><ul><li><strong>你的诊断</strong>：知道总体标准差吗？样本量如何？用什么分布？</li></ul></blockquote><p><strong>练习 3：精密仪器</strong></p><blockquote><p>工厂新进一台机器，要求其生产零件的直径波动（方差）不能太大。抽取 20 个零件，想估算这台机器的<strong>方差</strong>置信区间。</p><ul><li><strong>你的诊断</strong>：研究目标是均值还是方差？用 Z, t, F 还是 $\chi^2$？</li></ul></blockquote><p>我结合管理学实战经验，重新梳理的一套<strong>“假设检验实操心法”</strong>。</p><p>推断统计的终极目标是<strong>“用证据说话”</strong>。假设检验就是一场<strong>法庭审判</strong>：</p><ul><li><strong>原假设 ($H_0$)</strong>：是被告（通常是我们想要推翻的现状），预设它是无罪的。</li><li><strong>备择假设 ($H_1$)</strong>：是原告（我们的新发现），我们要找证据证明它有罪。</li><li><strong>数据</strong>：就是证据。</li><li><strong>小概率原理</strong>：如果假设 $H_0$ 是真的，那么出现这么离谱的数据的概率应该很小（$&lt;0.05$）。如果竟然出现了，那说明 $H_0$ 在撒谎，推翻它！</li></ul><p>以下是详细的复习笔记体系：</p><hr><h1 id="📝-管理统计学·个人复习笔记：假设检验"><a href="#📝-管理统计学·个人复习笔记：假设检验" class="headerlink" title="📝 管理统计学·个人复习笔记：假设检验"></a>📝 管理统计学·个人复习笔记：假设检验</h1><h2 id="一、-核心逻辑：法官的思维模型"><a href="#一、-核心逻辑：法官的思维模型" class="headerlink" title="一、 核心逻辑：法官的思维模型"></a>一、 核心逻辑：法官的思维模型</h2><p>做假设检验，永远遵循<strong>四步走</strong>：</p><h3 id="1-站队：确立-H-0-和-H-1"><a href="#1-站队：确立-H-0-和-H-1" class="headerlink" title="1. 站队：确立 $H_0$ 和 $H_1$"></a>1. 站队：确立 $H_0$ 和 $H_1$</h3><p>这是最容易错的第一步。记住原则：<strong>$H_0$ 包含等号 ($=, \ge, \le$)，且通常是我们想推翻的“老黄历”。</strong></p><ul><li><strong>双侧检验</strong>：<ul><li><strong>场景</strong>：机器生产的零件直径必须是 5cm，太大太小都不行。</li><li><strong>设定</strong>：$H_0: \mu = 5$； $H_1: \mu \ne 5$。</li><li><strong>心态</strong>：只要不一样就报警。</li></ul></li><li><strong>左单侧检验</strong>：<ul><li><strong>场景</strong>：商家说灯泡寿命至少 1000小时，我怀疑它偷工减料。</li><li><strong>设定</strong>：$H_0: \mu \ge 1000$； $H_1: \mu &lt; 1000$。</li><li><strong>心态</strong>：只有显著“变小”了才报警。</li></ul></li><li><strong>右单侧检验</strong>：<ul><li><strong>场景</strong>：改进工艺后，我想证明新产品的寿命显著提高了。</li><li><strong>设定</strong>：$H_0: \mu \le 1000$； $H_1: \mu &gt; 1000$。</li><li><strong>心态</strong>：只有显著“变大”了才庆祝。</li></ul></li></ul><h3 id="2-选武器：确定检验统计量"><a href="#2-选武器：确定检验统计量" class="headerlink" title="2. 选武器：确定检验统计量"></a>2. 选武器：确定检验统计量</h3><p>看你要检验什么指标，以及你手里有什么数据。</p><div class="table-container"><table><thead><tr><th style="text-align:left">检验目标</th><th style="text-align:left">已知条件</th><th style="text-align:left">武器（统计量）</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><strong>平均值</strong> ($\mu$)</td><td style="text-align:left">已知总体标准差 $\sigma$</td><td style="text-align:left"><strong>$Z$ 统计量</strong></td><td style="text-align:left">最精准，上帝视角</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">未知 $\sigma$，大样本 ($n&gt;30$)</td><td style="text-align:left"><strong>$Z$ 统计量</strong></td><td style="text-align:left">也可以用 $Z$ 近似</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">未知 $\sigma$，小样本 ($n&lt;30$)</td><td style="text-align:left"><strong>$t$ 统计量</strong></td><td style="text-align:left">用样本 $S$ 代替 $\sigma$，要查 $t$ 表</td></tr><tr><td style="text-align:left"><strong>比例</strong> ($p$)</td><td style="text-align:left">任何样本</td><td style="text-align:left"><strong>$Z$ 统计量</strong></td><td style="text-align:left">研究支持率、合格率</td></tr><tr><td style="text-align:left"><strong>方差</strong> ($\sigma^2$)</td><td style="text-align:left">任何样本</td><td style="text-align:left"><strong>$\chi^2$ 统计量</strong></td><td style="text-align:left">研究稳定性</td></tr></tbody></table></div><h3 id="3-算分：计算统计值"><a href="#3-算分：计算统计值" class="headerlink" title="3. 算分：计算统计值"></a>3. 算分：计算统计值</h3><p>把样本数据代入公式，算出一个具体的数字（比如 $Z=-2.5$）。这个数字代表<strong>样本偏离标准有多远</strong>。</p><h3 id="4-宣判：-P-值法-vs-临界值法"><a href="#4-宣判：-P-值法-vs-临界值法" class="headerlink" title="4. 宣判：$P$ 值法 vs 临界值法"></a>4. 宣判：$P$ 值法 vs 临界值法</h3><ul><li><strong>临界值法（查表硬刚）</strong>：<ul><li>如果算出来的 $Z$ 值（绝对值） &gt; 查表得到的界限（比如 1.96），说明跑得太远了，<strong>拒绝 $H_0$</strong>。</li></ul></li><li><strong>$P$ 值法（看概率）</strong>：<ul><li>$P$ 值 = 在 $H_0$ 成立的情况下，出现这种离谱数据的概率。</li><li><strong>口诀</strong>：<strong>若 $P &lt; \alpha$ (0.05)，拒绝 $H_0$</strong>。（概率太小了，居然发生了，说明前提是错的）。</li></ul></li></ul><hr><h2 id="二、-实战案例复盘（题目补充与解析）"><a href="#二、-实战案例复盘（题目补充与解析）" class="headerlink" title="二、 实战案例复盘（题目补充与解析）"></a>二、 实战案例复盘（题目补充与解析）</h2><p>这四道题覆盖了考试的90%考点**。</p><h3 id="案例-1：平均值检验（左单侧-Z-检验）"><a href="#案例-1：平均值检验（左单侧-Z-检验）" class="headerlink" title="案例 1：平均值检验（左单侧 + Z 检验）"></a>案例 1：平均值检验（左单侧 + Z 检验）</h3><blockquote><p><strong>题目</strong>：批发商想买灯泡。厂家吹牛说平均寿命 $\mu \ge 1000$ 小时。已知总体标准差 $\sigma=200$。批发商随机抽了 $n=100$ 个，测出来平均值只有 $\bar{x}=960$。问：厂家在撒谎吗？($\alpha=0.05$)</p></blockquote><ul><li><strong>思考</strong>：有“总体标准差”，直接上 Z！批发商最怕寿命短，所以是左单侧。</li><li><strong>步骤</strong>：<ol><li><strong>假设</strong>：$H_0: \mu \ge 1000$（厂家没骗人）；$H_1: \mu &lt; 1000$（厂家骗人）。</li><li><strong>计算</strong>：<script type="math/tex; mode=display">Z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{960 - 1000}{200 / \sqrt{100}} = \frac{-40}{20} = -2</script><em>解读：样本均值比宣称均值低了2个标准误差。</em></li><li><strong>判决</strong>：<ul><li>查表：$\alpha=0.05$ 的左侧临界值是 <strong>-1.645</strong>。</li><li>比较：$-2 &lt; -1.645$（落在了左边的拒绝域里）。</li></ul></li><li><strong>结论</strong>：<strong>拒绝 $H_0$</strong>。有充分证据证明厂家在吹牛，不要买这批灯泡。</li></ol></li></ul><h3 id="案例-2：平均值检验（双侧-t-检验）"><a href="#案例-2：平均值检验（双侧-t-检验）" class="headerlink" title="案例 2：平均值检验（双侧 + t 检验）"></a>案例 2：平均值检验（双侧 + t 检验）</h3><blockquote><p><strong>题目</strong>：生产肥皂，标准厚度要 5cm。质检员抽了 $n=10$ 块，测得 $\bar{x}=5.3$，样本标准差 $S=0.3$。问：机器正常吗？($\alpha=0.05$)</p></blockquote><ul><li><strong>思考</strong>：没给总体 $\sigma$，且 $n=10$ 是小样本 $\rightarrow$ 必须用 <strong>t 检验</strong>。机器好坏是双向的，太厚太薄都不行 $\rightarrow$ <strong>双侧检验</strong>。</li><li><strong>步骤</strong>：<ol><li><strong>假设</strong>：$H_0: \mu = 5$（机器正常）；$H_1: \mu \ne 5$（机器坏了）。</li><li><strong>计算</strong>：<script type="math/tex; mode=display">t = \frac{\bar{x} - \mu_0}{S / \sqrt{n}} = \frac{5.3 - 5}{0.3 / \sqrt{10}} \approx \frac{0.3}{0.095} = 3.16</script></li><li><strong>判决</strong>：<ul><li>查 t 分布表（自由度 $df = n-1 = 9$），对应 $\alpha/2 = 0.025$ 的临界值是 <strong>2.262</strong>。</li><li>比较：$3.16 &gt; 2.262$（显著偏大）。</li></ul></li><li><strong>结论</strong>：<strong>拒绝 $H_0$</strong>。机器出问题了，肥皂显著偏厚。</li></ol></li></ul><h3 id="案例-3：比例检验（双侧-Z-检验）"><a href="#案例-3：比例检验（双侧-Z-检验）" class="headerlink" title="案例 3：比例检验（双侧 + Z 检验）"></a>案例 3：比例检验（双侧 + Z 检验）</h3><blockquote><p><strong>题目</strong>：统计局说老年人口比例是 14.7%。研究员抽查了 400 人，发现 57 人是老年人（占比 14.25%）。问：统计局的数据可靠吗？</p></blockquote><ul><li><strong>思考</strong>：只要是比例问题，不管样本大小，直接用 <strong>Z 检验</strong>。</li><li><strong>步骤</strong>：<ol><li><strong>假设</strong>：$H_0: p = 0.147$；$H_1: p \ne 0.147$。</li><li><strong>计算</strong>：<script type="math/tex; mode=display">Z = \frac{p_{样本} - p_0}{\sqrt{\frac{p_0(1-p_0)}{n}}} = \frac{0.1425 - 0.147}{\sqrt{\frac{0.147 \times 0.853}{400}}} \approx -0.254</script></li><li><strong>判决</strong>：<ul><li>临界值 $\pm 1.96$。</li><li>比较：$|-0.254| &lt; 1.96$（这差距太小了，完全在误差范围内）。</li></ul></li><li><strong>结论</strong>：<strong>不能拒绝 $H_0$</strong>。样本差异不显著，我们可以认为统计局的数据是准的。</li></ol></li></ul><h3 id="案例-4：方差检验（单侧-chi-2-检验）"><a href="#案例-4：方差检验（单侧-chi-2-检验）" class="headerlink" title="案例 4：方差检验（单侧 + $\chi^2$ 检验）"></a>案例 4：方差检验（单侧 + $\chi^2$ 检验）</h3><blockquote><p><strong>题目</strong>：饮料灌装机要求精度极高，规定方差 $\sigma^2$ 不能超过 1。现在抽 25 瓶，算出样本方差 $S^2 = 0.866$。问：机器满足设计要求吗？</p></blockquote><ul><li><strong>思考</strong>：检验方差，必须用 <strong>$\chi^2$ (卡方) 检验</strong>。</li><li><strong>注意</strong>：这里有一个逻辑坑。题目问“是否满足要求（不超过1）”。如果样本方差是 0.866（小于1），直觉告诉我们肯定是满足的，甚至不需要检验。<ul><li>但如果要走流程，假设通常是：$H_0: \sigma^2 \le 1$ vs $H_1: \sigma^2 &gt; 1$。</li><li>因为只有当算出 $S^2$ 远大于 1 时，我们才有机会推翻 $H_0$。</li></ul></li><li><strong>步骤</strong>：<ol><li><strong>假设</strong>：$H_0: \sigma^2 \le 1$（合格）；$H_1: \sigma^2 &gt; 1$（不合格）。</li><li><strong>计算</strong>：<script type="math/tex; mode=display">\chi^2 = \frac{(n-1)S^2}{\sigma_0^2} = \frac{24 \times 0.866}{1} = 20.8</script></li><li><strong>判决</strong>：<ul><li>查 $\chi^2$ 表（自由度 24，$\alpha=0.05$），右侧临界值是 <strong>36.415</strong>。</li><li>比较：$20.8 &lt; 36.415$（没有落在右边的拒绝域）。</li></ul></li><li><strong>结论</strong>：<strong>不能拒绝 $H_0$</strong>。数据支持机器是合格的（甚至比标准更稳）。</li></ol></li></ul><hr><h2 id="三、-避坑指南：两类错误"><a href="#三、-避坑指南：两类错误" class="headerlink" title="三、 避坑指南：两类错误"></a>三、 避坑指南：两类错误</h2><p>这是选择题必考概念。</p><ul><li><strong>第一类错误（弃真）- $\alpha$ 错误</strong><ul><li><strong>比喻</strong>：<strong>冤枉好人</strong>。</li><li><strong>场景</strong>：机器明明是好的（$H_0$ 为真），但因为你抽样刚好抽到了几个次品，导致你误判机器坏了，把机器停了。</li><li><strong>风险</strong>：显著性水平 $\alpha$ 就是我们允许犯这种错误的概率上限（通常5%）。</li></ul></li><li><strong>第二类错误（取伪）- $\beta$ 错误</strong><ul><li><strong>比喻</strong>：<strong>放过坏人</strong>。</li><li><strong>场景</strong>：机器已经坏了（$H_0$ 为假），但你抽样运气好，刚好抽到了几个合格品，导致你没发现问题，继续生产次品。</li><li><strong>关系</strong>：$\alpha$ 和 $\beta$ 是跷跷板。想减少冤枉好人（降低 $\alpha$），就会增加放过坏人（增加 $\beta$）的风险。想同时降低两者，唯一的办法是<strong>增加样本量 $n$</strong>（加钱，多找证据）。</li></ul></li></ul><hr><h2 id="四、-总结：做题“三板斧”"><a href="#四、-总结：做题“三板斧”" class="headerlink" title="四、 总结：做题“三板斧”"></a>四、 总结：做题“三板斧”</h2><p>拿到一道大题，不要慌，按这个模版写：</p><ol><li><strong>“解：设…”</strong>：写出 $H_0$ 和 $H_1$。（这一步写对就有分）。</li><li><strong>“计算统计量”</strong>：<ul><li>看有没有 $\sigma$ $\rightarrow$ 定 $Z$ 还是 $t$。</li><li>看是不是方差 $\rightarrow$ 定 $\chi^2$。</li><li>代入公式算出结果。</li></ul></li><li><strong>“查表比较下结论”</strong>：<ul><li>写出“查表得临界值为…”。</li><li>写出“因为统计值 &gt; 临界值，故拒绝原假设”。</li><li><strong>最后一定要用人话翻译一遍</strong>：“说明该批产品不合格/说明统计数据准确”。</li></ul></li></ol><p>这套逻辑通了吗？如果把这四个案例吃透，推断统计的计算题就没问题了！</p><p>这部分内容属于统计学的“进阶应用”。如果说前面的假设检验是“单兵作战”（比两个数），那这里就是“军团作战”（比一堆数，或者找规律）。</p><p>我将这部分重新梳理为三个模块：<strong>方差分析（ANOVA）、相关分析、回归分析</strong>。这三个模块在实际管理工作中应用极广，是数据分析师的看家本领。</p><hr><h1 id="📝-进阶数据分析方法·个人复习笔记"><a href="#📝-进阶数据分析方法·个人复习笔记" class="headerlink" title="📝 进阶数据分析方法·个人复习笔记"></a>📝 进阶数据分析方法·个人复习笔记</h1><h2 id="第一模块：单因素方差分析-ANOVA"><a href="#第一模块：单因素方差分析-ANOVA" class="headerlink" title="第一模块：单因素方差分析 (ANOVA)"></a>第一模块：单因素方差分析 (ANOVA)</h2><p><strong>1. 核心逻辑：为什么要叫“方差”分析？</strong><br>很多同学一直困惑：<strong>“我们要比较的是3组数据的平均值（$\mu_1, \mu_2, \mu_3$）是否相等，为什么要分析‘方差’？”</strong></p><p>这里有一个非常经典的<strong>“信号与噪声”</strong>理论：<br>我们将数据的总波动（SST）拆解为两部分：</p><ul><li><strong>组间波动 (SSA)</strong>：这是<strong>信号</strong>。是由不同的“因素”造成的（比如用了三种不同的组装方法，效率自然不同）。这部分波动是我们想看到的。</li><li><strong>组内波动 (SSE)</strong>：这是<strong>噪声</strong>。是随机误差（比如同样是用方法A，小张和小李的手速不一样）。这部分波动是我们想消除的。</li></ul><p><strong>判决逻辑（F检验）</strong>：</p><script type="math/tex; mode=display">F = \frac{\text{组间方差 (信号)}}{\text{组内方差 (噪声)}} = \frac{MSA}{MSE}</script><ul><li>如果 <strong>$F$ 值很大</strong>（信号远强于噪声）：说明组和组之间的区别是实打实的，不是运气。$\rightarrow$ <strong>拒绝 $H_0$，认为各组均值显著不同。</strong></li><li>如果 <strong>$F$ 值接近 1</strong>：说明组间区别还没组内瞎波动的区别大。$\rightarrow$ <strong>接受 $H_0$，认为各组没啥区别。</strong></li></ul><p><strong>2. 实战解题：ANOVA 表格填空（考试必考）</strong><br>这就像在玩数独，格子里是有勾稽关系的。一定要背下来这个关系网！</p><p>假设我们在做题目：<strong>3种组装方法 ($k=3$)，总共调查了 30 名工人 ($n=30$)。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">差异源</th><th style="text-align:left">平方和 (SS)</th><th style="text-align:left">自由度 (df)</th><th style="text-align:left">均方 (MS)</th><th style="text-align:left">F 值</th></tr></thead><tbody><tr><td style="text-align:left"><strong>组间 (SSA)</strong></td><td style="text-align:left"><strong>填空1</strong></td><td style="text-align:left">$k-1 = 3-1 = 2$</td><td style="text-align:left">$MSA = \frac{SSA}{2}$</td><td style="text-align:left">$F = \frac{MSA}{MSE}$</td></tr><tr><td style="text-align:left"><strong>组内 (SSE)</strong></td><td style="text-align:left">3836</td><td style="text-align:left">$n-k = 30-3 = 27$</td><td style="text-align:left">$MSE = \frac{3836}{27}$</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>总计 (SST)</strong></td><td style="text-align:left"><strong>填空2</strong></td><td style="text-align:left">$n-1 = 29$</td><td style="text-align:left"></td></tr></tbody></table></div><ul><li><strong>填空逻辑</strong>：<ol><li><strong>先算均方 (MS)</strong>：$MS = SS \div df$。<ul><li>题目若给了 $MSA=210$，那我们反推 $SSA = 210 \times 2 = 420$。（填空1）</li></ul></li><li><strong>再算加法</strong>：$SST = SSA + SSE = 420 + 3836 = 4256$。（填空2）</li><li><strong>最后算 F 值</strong>：<ul><li>先算出 $MSE = 3836 \div 27 \approx 142.07$</li><li>$F = 210 \div 142.07 \approx 1.48$</li></ul></li><li><strong>下结论</strong>：<ul><li>查表 F临界值（假设是 3.35）。</li><li>因为 $1.48 &lt; 3.35$，<strong>不能拒绝 $H_0$</strong>。</li><li><strong>人话结论</strong>：这三种组装方法效率差不多，没必要折腾换方法。</li></ul></li></ol></li></ul><hr><h2 id="第二模块：相关分析-Correlation"><a href="#第二模块：相关分析-Correlation" class="headerlink" title="第二模块：相关分析 (Correlation)"></a>第二模块：相关分析 (Correlation)</h2><p><strong>1. 核心指标：皮尔逊相关系数 ($r$)</strong><br>这个 $r$ 是衡量两个变量（比如“广告费”和“销售额”）亲密程度的数字。</p><ul><li><strong>取值范围</strong>：$[-1, 1]$</li><li><strong>符号看方向</strong>：<ul><li>$+$：正相关（你涨我也涨）。</li><li>$-$：负相关（你涨我就跌，比如“价格”和“销量”）。</li></ul></li><li><strong>绝对值看强度</strong>：<ul><li>$|r| \to 1$：关系铁得很，基本在一条线上。</li><li>$|r| \to 0$：关系很乱，一团散沙。</li></ul></li></ul><p><strong>2. 避坑指南（考试陷阱）</strong></p><ul><li><strong>陷阱一</strong>：$r=0$ 代表没有关系？<ul><li><strong>错！</strong> $r=0$ 只代表<strong>没有“线性”关系</strong>。它们可能是抛物线关系（U型曲线，比如“焦虑程度”和“考试成绩”，适度焦虑成绩好，过低过高都差）。</li></ul></li><li><strong>陷阱二</strong>：相关 = 因果？<ul><li><strong>错！</strong> 发现“冰淇淋销量”和“溺水人数”高度正相关。是因为吃冰淇淋导致溺水吗？不是，是因为夏天到了（第三个潜伏变量）。<strong>相关分析只告诉你它俩同步，不告诉你谁影响谁。</strong></li></ul></li></ul><hr><h2 id="第三模块：一元线性回归分析-Regression"><a href="#第三模块：一元线性回归分析-Regression" class="headerlink" title="第三模块：一元线性回归分析 (Regression)"></a>第三模块：一元线性回归分析 (Regression)</h2><p>如果说相关分析是“看热闹”（它俩有关系），回归分析就是“做预测”（具体关系是多少）。</p><p><strong>1. 核心模型：$y = \beta_0 + \beta_1 x + \epsilon$</strong></p><ul><li>$y$：因变量（我们要预测的，比如销售额）。</li><li>$x$：自变量（比如广告费）。</li><li>$\beta_0$：截距（广告费为0时的自然销量）。</li><li>$\beta_1$：斜率（每多投1块钱广告，销量增加多少）。</li></ul><p><strong>2. 方法论：最小二乘法 (OLS)</strong></p><ul><li><strong>思想</strong>：我们要画一条直线穿过散点图。怎么画最好？</li><li><strong>标准</strong>：让所有点到这条线的<strong>垂直距离的平方和</strong>最小。</li><li>这就好比大家站队，教官要找一条基准线，让所有人移动的步数总和最少。</li></ul><p><strong>3. 模型好不好？看 $R^2$ (判定系数)</strong><br>这是回归分析中最重要的指标！</p><ul><li><strong>公式</strong>：$R^2 = \frac{SSR}{SST} = 1 - \frac{SSE}{SST}$</li><li><strong>含义</strong>：<strong>拟合优度</strong>。你的模型解释了数据的百分之多少？</li><li><strong>范围</strong>：$[0, 1]$。</li><li><strong>例子</strong>：如果 $R^2 = 0.8$，意思是“销售额的波动中，有 <strong>80%</strong> 是可以由广告费的变化来解释的，剩下 20% 是随机因素”。<ul><li>$R^2$ 越大，模型越精准，老板越喜欢。</li></ul></li></ul><hr><h2 id="💡-总结与记忆口诀"><a href="#💡-总结与记忆口诀" class="headerlink" title="💡 总结与记忆口诀"></a>💡 总结与记忆口诀</h2><ol><li><p><strong>方差分析 (ANOVA)</strong>：</p><ul><li><strong>目的</strong>：比三个以上的平均值。</li><li><strong>工具</strong>：F 检验。</li><li><strong>口诀</strong>：<strong>SST拆两半，A是组间E是乱；均方除以自由度，F一算便知断。</strong></li></ul></li><li><p><strong>相关分析</strong>：</p><ul><li><strong>目的</strong>：看有没有关系。</li><li><strong>工具</strong>：相关系数 $r$。</li><li><strong>注意</strong>：0 不代表没关系，相关不代表因果。</li></ul></li><li><p><strong>回归分析</strong>：</p><ul><li><strong>目的</strong>：根据 X 预测 Y。</li><li><strong>工具</strong>：最小二乘法。</li><li><strong>评价</strong>：$R^2$ 是打分卡，越近 1 越牛叉。</li></ul></li></ol><p>这部分内容在期末考试中，通常会出一道<strong>综合大题</strong>：给一个 ANOVA 表让你填空，或者给一个回归方程 $y = 100 + 5x$，问你 $x=10$ 时 $y$ 是多少，以及 $R^2=0.9$ 说明了什么。把上面这些逻辑理顺，基本就能拿满分了！</p><p>统计学中的<strong>“类别变量分析”</strong>（Categorical Variable Analysis），核心工具是<strong>卡方检验（$\chi^2$ Test）</strong>。</p><p>我来用大白话给你拆解一下它到底在干什么，考试会怎么考，以及你该怎么应对。</p><hr><h3 id="一、-它是讲什么的？（通俗版）"><a href="#一、-它是讲什么的？（通俗版）" class="headerlink" title="一、 它是讲什么的？（通俗版）"></a>一、 它是讲什么的？（通俗版）</h3><p>所谓的“类别变量”，就是指那些<strong>不能量化、只能分类</strong>的数据。比如：性别（男/女）、血型（A/B/O/AB）、满意度（满意/不满意）、地区（东部/西部）。</p><p>这一章主要就在解决两个问题：</p><h4 id="1-现实是否符合预期？（拟合优度检验-7-1节）"><a href="#1-现实是否符合预期？（拟合优度检验-7-1节）" class="headerlink" title="1. 现实是否符合预期？（拟合优度检验 - 7.1节）"></a>1. 现实是否符合预期？（拟合优度检验 - 7.1节）</h4><ul><li><strong>通俗例子：</strong> 比如你抛一枚硬币，你心里的<strong>预期</strong>是正面反面各占50%。结果你抛了100次，出了90次正面。</li><li><strong>分析目的：</strong> 这到底是因为你运气好（纯属偶然），还是这枚硬币本身就有问题（有显著差异）？</li><li><strong>书中的例子（例7-1）：</strong> 厂家以为消费者对4种饮料的喜爱程度是一样的（预期），结果调查出来大家狂买其中一种（现实）。我们需要用公式算一下，这种差异是不是大到无法忽视。</li></ul><h4 id="2-两件事有没有关系？（独立性检验-7-2节）"><a href="#2-两件事有没有关系？（独立性检验-7-2节）" class="headerlink" title="2. 两件事有没有关系？（独立性检验 - 7.2节）"></a>2. 两件事有没有关系？（独立性检验 - 7.2节）</h4><ul><li><strong>通俗例子：</strong> “秃头”和“程序员”这两个属性有关系吗？</li><li><strong>分析目的：</strong> 是不是程序员更容易秃头（相关/不独立）？还是说不管你是不是程序员，秃头的概率都一样（独立/没关系）？</li><li><strong>书中的例子（例7-3）：</strong> “所在的地区”（东/中/西）和“购物满意度”（满意/不满意）有关系吗？是东部的人本来就比较挑剔，还是大家都差不多？</li></ul><hr><h3 id="二、-考试会怎么考？"><a href="#二、-考试会怎么考？" class="headerlink" title="二、 考试会怎么考？"></a>二、 考试会怎么考？</h3><p>根据这类教材的套路，考试通常分三种题型：</p><h4 id="题型-1：计算题（手动算卡方值）"><a href="#题型-1：计算题（手动算卡方值）" class="headerlink" title="题型 1：计算题（手动算卡方值）"></a>题型 1：计算题（手动算卡方值）</h4><p>老师会给你一个简单的表格（通常是 $2\times2$ 或 $2\times3$ 的表），让你判断两个变量是否有关系。</p><ul><li><strong>考点：</strong> 也就是书上 <strong>(7.2)</strong> 和 <strong>(7.4)</strong> 两个公式。</li><li><strong>关键步骤：</strong> 算出“理论上应该有多少人”（期望频数），然后跟“实际有多少人”（观测频数）做对比。</li></ul><h4 id="题型-2：软件结果解读（SPSS输出分析）"><a href="#题型-2：软件结果解读（SPSS输出分析）" class="headerlink" title="题型 2：软件结果解读（SPSS输出分析）"></a>题型 2：软件结果解读（SPSS输出分析）</h4><p>题目直接给你一张像书上 <strong>表7-4</strong> 或 <strong>表7-11</strong> 那样的电脑运行结果图，让你写结论。</p><ul><li><strong>考点：</strong> 看懂 <code>Sig.</code> (或者是 <code>P值</code>)。</li><li><strong>金标准：</strong> 如果 <strong>Sig &lt; 0.05</strong>，就说明拒绝原假设（说明有显著差异，或者两者有关系）。</li></ul><h4 id="题型-3：概念选择-判断题"><a href="#题型-3：概念选择-判断题" class="headerlink" title="题型 3：概念选择/判断题"></a>题型 3：概念选择/判断题</h4><ul><li><strong>考点：</strong> 什么时候不能用卡方检验？</li><li><strong>答案：</strong> 书上7.2.2提到的——当样本太少，或者期望频数小于5的时候，结果就不准了。</li><li><strong>考点：</strong> 相关系数（$\phi$, V, C）是干嘛的？</li><li><strong>答案：</strong> 卡方检验只能告诉你“有关系”，相关系数告诉你“关系有多强”。</li></ul><hr><h3 id="三、-你应该怎么做？（解题套路）"><a href="#三、-你应该怎么做？（解题套路）" class="headerlink" title="三、 你应该怎么做？（解题套路）"></a>三、 你应该怎么做？（解题套路）</h3><p>遇到这类题目，请按以下<strong>“四步走”</strong>战略：</p><h4 id="第一步：立Flag（写假设-H-0-和-H-1-）"><a href="#第一步：立Flag（写假设-H-0-和-H-1-）" class="headerlink" title="第一步：立Flag（写假设 $H_0$ 和 $H_1$）"></a>第一步：立Flag（写假设 $H_0$ 和 $H_1$）</h4><p>这是送分步骤，必须写对。</p><ul><li><strong>对于拟合优度（一个变量）：</strong><ul><li>$H_0$：实际分布跟理论分布<strong>一样</strong>（硬币没问题/大家喜爱度一样）。</li><li>$H_1$：实际分布跟理论分布<strong>不一样</strong>。</li></ul></li><li><strong>对于独立性检验（两个变量）：</strong><ul><li>$H_0$：变量A和变量B<strong>没关系</strong>（独立）。</li><li>$H_1$：变量A和变量B<strong>有关系</strong>（不独立）。</li></ul></li></ul><h4 id="第二步：算期望（找基准线）"><a href="#第二步：算期望（找基准线）" class="headerlink" title="第二步：算期望（找基准线）"></a>第二步：算期望（找基准线）</h4><p>如果是计算题，你需要算出 $E$（期望频数）。</p><ul><li><strong>公式口诀：</strong> <strong>(行合计 $\times$ 列合计) $\div$ 总人数</strong>。</li><li><em>例子：</em> 表格里如果想算“东部且满意”的期望人数，就用（东部总人数 $\times$ 满意总人数）$\div$ 全体被调查人数。</li></ul><h4 id="第三步：算差异（卡方公式-chi-2-）"><a href="#第三步：算差异（卡方公式-chi-2-）" class="headerlink" title="第三步：算差异（卡方公式 $\chi^2$）"></a>第三步：算差异（卡方公式 $\chi^2$）</h4><ul><li><strong>核心公式：</strong> $\chi^2 = \sum \frac{(实际值 - 期望值)^2}{期望值}$</li><li><strong>逻辑：</strong> 每一个格子的（实际-期望）的平方，除以期望，最后把所有格子加起来。</li><li><strong>结论：</strong> 算出来的这个数（$\chi^2$）<strong>越大</strong>，说明实际和理论差别越大，就越可能<strong>拒绝 $H_0$</strong>（即：有关系/有差异）。</li></ul><h4 id="第四步：下结论（看-P值-Sig值）"><a href="#第四步：下结论（看-P值-Sig值）" class="headerlink" title="第四步：下结论（看 P值 / Sig值）"></a>第四步：下结论（看 P值 / Sig值）</h4><ul><li><strong>如果自己算：</strong> 题目会给你一个临界值（比如 3.84），你算的数比它大，就拒绝 $H_0$。</li><li><strong>如果看图表（SPSS）：</strong> 盯着 <strong>Pearson Chi-Square</strong> 那一行的 <strong>Sig. (双侧)</strong> 看。<ul><li><strong>Sig &lt; 0.05</strong> $\rightarrow$ <strong>拒绝 $H_0$</strong> $\rightarrow$ <strong>结论：两者有显著关系/分布显著不同。</strong></li><li>Sig &gt; 0.05 $\rightarrow$ 接受 $H_0$ $\rightarrow$ 结论：两者没啥关系/分布基本一致。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你只需要记住一句话：<strong>“算出实际和预期的差距，差距只要足够大（P &lt; 0.05），就说明有猫腻（有关系/有显著差异）。”</strong></p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214203943757.png" alt="image-20251214203943757"></p><p>这是一道典型的<strong>卡方拟合优度检验（Chi-Square Goodness of Fit Test）</strong>题目。</p><p>我们要解决的问题是：<strong>实际观察到的销售数据，和我们假设的“平均分布”（即每个月卖得一样多）是否有显著差异？</strong></p><p>下面是详细的解题步骤：</p><h3 id="第一步：建立假设（立-Flag）"><a href="#第一步：建立假设（立-Flag）" class="headerlink" title="第一步：建立假设（立 Flag）"></a>第一步：建立假设（立 Flag）</h3><p>在统计学中，我们首先要设立两个对立的假设：</p><ul><li><strong>原假设 ($H_0$)：</strong> 各月份的销售量<strong>符合</strong>均匀分布。<ul><li><em>意思是：除去偶然误差，每个月卖得应该是一样多的。</em></li></ul></li><li><strong>备择假设 ($H_1$)：</strong> 各月份的销售量<strong>不符合</strong>均匀分布。<ul><li><em>意思是：销售量有显著的季节性波动或其他差异。</em></li></ul></li></ul><hr><h3 id="第二步：计算期望频数-E"><a href="#第二步：计算期望频数-E" class="headerlink" title="第二步：计算期望频数 ($E$)"></a>第二步：计算期望频数 ($E$)</h3><p>既然假设是“均匀分布”，那么理论上每个月的销售量应该是总销售量的平均值。</p><ol><li><p><strong>计算总销售量 ($N$)：</strong><br>把1月到12月的数据加起来：<br>$1660 + 1600 + 1560 + 1490 + 1380 + 1620 + 1580 + 1680 + 1550 + 1370 + 1410 + 1610$<br>$= \mathbf{18,510}$ (箱)</p></li><li><p><strong>计算期望频数 ($E$)：</strong><br>因为一年有12个月，如果均匀分布，每个月应该是：<br>$E = \frac{18510}{12} = \mathbf{1542.5}$ (箱)</p><p><em>注意：这里的 $1542.5$ 就是我们后面计算用的基准线。</em></p></li></ol><hr><h3 id="第三步：计算卡方统计量-chi-2"><a href="#第三步：计算卡方统计量-chi-2" class="headerlink" title="第三步：计算卡方统计量 ($\chi^2$)"></a>第三步：计算卡方统计量 ($\chi^2$)</h3><p>公式是：$\chi^2 = \sum \frac{(O - E)^2}{E}$</p><ul><li>$O$ = 实际观测值 (Observed)</li><li>$E$ = 理论期望值 (Expected, 即 1542.5)</li></ul><p>我们需要对每个月都算一下：<strong>[(实际 - 期望)的平方] 除以 期望</strong>，最后加在一起。</p><p>为了清晰，我们列个表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">月份</th><th style="text-align:left">实际观测值 ($O$)</th><th style="text-align:left">期望值 ($E$)</th><th style="text-align:left">差值 ($O-E$)</th><th style="text-align:left">差的平方 $(O-E)^2$</th><th style="text-align:left">$\frac{(O-E)^2}{E}$</th></tr></thead><tbody><tr><td style="text-align:left">1月</td><td style="text-align:left">1660</td><td style="text-align:left">1542.5</td><td style="text-align:left">117.5</td><td style="text-align:left">13806.25</td><td style="text-align:left"><strong>8.95</strong></td></tr><tr><td style="text-align:left">2月</td><td style="text-align:left">1600</td><td style="text-align:left">1542.5</td><td style="text-align:left">57.5</td><td style="text-align:left">3306.25</td><td style="text-align:left"><strong>2.14</strong></td></tr><tr><td style="text-align:left">3月</td><td style="text-align:left">1560</td><td style="text-align:left">1542.5</td><td style="text-align:left">17.5</td><td style="text-align:left">306.25</td><td style="text-align:left"><strong>0.20</strong></td></tr><tr><td style="text-align:left">4月</td><td style="text-align:left">1490</td><td style="text-align:left">1542.5</td><td style="text-align:left">-52.5</td><td style="text-align:left">2756.25</td><td style="text-align:left"><strong>1.79</strong></td></tr><tr><td style="text-align:left">5月</td><td style="text-align:left">1380</td><td style="text-align:left">1542.5</td><td style="text-align:left">-162.5</td><td style="text-align:left">26406.25</td><td style="text-align:left"><strong>17.12</strong></td></tr><tr><td style="text-align:left">6月</td><td style="text-align:left">1620</td><td style="text-align:left">1542.5</td><td style="text-align:left">77.5</td><td style="text-align:left">6006.25</td><td style="text-align:left"><strong>3.89</strong></td></tr><tr><td style="text-align:left">7月</td><td style="text-align:left">1580</td><td style="text-align:left">1542.5</td><td style="text-align:left">37.5</td><td style="text-align:left">1406.25</td><td style="text-align:left"><strong>0.91</strong></td></tr><tr><td style="text-align:left">8月</td><td style="text-align:left">1680</td><td style="text-align:left">1542.5</td><td style="text-align:left">137.5</td><td style="text-align:left">18906.25</td><td style="text-align:left"><strong>12.26</strong></td></tr><tr><td style="text-align:left">9月</td><td style="text-align:left">1550</td><td style="text-align:left">1542.5</td><td style="text-align:left">7.5</td><td style="text-align:left">56.25</td><td style="text-align:left"><strong>0.04</strong></td></tr><tr><td style="text-align:left">10月</td><td style="text-align:left">1370</td><td style="text-align:left">1542.5</td><td style="text-align:left">-172.5</td><td style="text-align:left">29756.25</td><td style="text-align:left"><strong>19.29</strong></td></tr><tr><td style="text-align:left">11月</td><td style="text-align:left">1410</td><td style="text-align:left">1542.5</td><td style="text-align:left">-132.5</td><td style="text-align:left">17556.25</td><td style="text-align:left"><strong>11.38</strong></td></tr><tr><td style="text-align:left">12月</td><td style="text-align:left">1610</td><td style="text-align:left">1542.5</td><td style="text-align:left">67.5</td><td style="text-align:left">4556.25</td><td style="text-align:left"><strong>2.95</strong></td></tr><tr><td style="text-align:left"><strong>合计</strong></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">$\sum = \mathbf{80.92}$</td></tr></tbody></table></div><p>所以，计算出的卡方值 <strong>$\chi^2 \approx 80.92$</strong>。</p><hr><h3 id="第四步：确定临界值并比较"><a href="#第四步：确定临界值并比较" class="headerlink" title="第四步：确定临界值并比较"></a>第四步：确定临界值并比较</h3><ol><li><p><strong>确定自由度 ($df$)：</strong><br>自由度 = 分类数 - 1<br>这里有12个月，所以 $df = 12 - 1 = \mathbf{11}$。</p></li><li><p><strong>查找临界值：</strong><br>题目给出的显著性水平是 $\alpha = 0.05$。<br>查卡方分布表（$\chi^2$ table），找到 $df=11, \alpha=0.05$ 对应的数值。<br>查表可得临界值 <strong>$\chi^2_{0.05}(11) = 19.675$</strong>。</p></li><li><p><strong>比较：</strong></p><ul><li>我们算出来的统计量：<strong>$80.92$</strong></li><li>临界值标准：<strong>$19.675$</strong></li></ul><p><strong>$80.92 &gt; 19.675$</strong><br>（算出来的差异值远远超过了允许的误差范围）</p></li></ol><hr><h3 id="第五步：得出结论"><a href="#第五步：得出结论" class="headerlink" title="第五步：得出结论"></a>第五步：得出结论</h3><ul><li><strong>统计结论：</strong> 因为计算出的 $\chi^2$ 值落在拒绝域内（大于临界值），所以我们<strong>拒绝原假设 $H_0$</strong>。</li><li><strong>业务解释：</strong> 在0.05的显著性水平下，我们有充分的理由认为<strong>该企业各月份的销售量不符合均匀分布</strong>。</li></ul><p><strong>简单说：</strong> 这家公司的产品销售有明显的淡旺季之分（比如5月、10月、11月卖得特别差，1月、8月卖得特别好），并不是每个月都卖得一样多，生产计划不能按平均数来排。</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214204251410.png" alt="image-20251214204251410"></p><p>这是一道标准的<strong>独立性检验（Test of Independence）</strong>题目。</p><p>我们要解决的问题是：<strong>“是否逃课”这件事，跟“性别”有没有关系？</strong>（比如：是不是男生更容易逃课，或者女生更容易逃课？还是说两者其实差不多？）</p><p>下面是详细的解题步骤：</p><h3 id="第一步：建立假设（立-Flag）-1"><a href="#第一步：建立假设（立-Flag）-1" class="headerlink" title="第一步：建立假设（立 Flag）"></a>第一步：建立假设（立 Flag）</h3><ul><li><strong>原假设 ($H_0$)：</strong> 是否逃课与性别<strong>相互独立</strong>（没关系）。<ul><li><em>意思是：男生和女生的逃课比例在统计学上是一样的。</em></li></ul></li><li><strong>备择假设 ($H_1$)：</strong> 是否逃课与性别<strong>不独立</strong>（有关系）。<ul><li><em>意思是：性别会影响逃课的情况。</em></li></ul></li></ul><hr><h3 id="第二步：计算期望频数-E-1"><a href="#第二步：计算期望频数-E-1" class="headerlink" title="第二步：计算期望频数 ($E$)"></a>第二步：计算期望频数 ($E$)</h3><p>如果原假设成立（两者没关系），那么每个格子里的人数应该完全按比例分配。</p><p><strong>公式：</strong> $E = \frac{\text{该行合计} \times \text{该列合计}}{\text{总人数}}$</p><p>我们先看表格里的合计数据：</p><ul><li>总人数 $n = 150$</li><li>逃过课总数 = 72，未逃过总数 = 78</li><li>男生总数 = 62，女生总数 = 88</li></ul><p>现在算出4个格子的期望值：</p><ol><li><strong>男生-逃过课 ($E_{11}$)</strong>：$\frac{72 \times 62}{150} = \mathbf{29.76}$</li><li><strong>女生-逃过课 ($E_{12}$)</strong>：$\frac{72 \times 88}{150} = \mathbf{42.24}$</li><li><strong>男生-未逃课 ($E_{21}$)</strong>：$\frac{78 \times 62}{150} = \mathbf{32.24}$</li><li><strong>女生-未逃课 ($E_{22}$)</strong>：$\frac{78 \times 88}{150} = \mathbf{45.76}$</li></ol><p><em>(简单检查一下：29.76+42.24=72，计算正确)</em></p><hr><h3 id="第三步：计算卡方统计量-chi-2-1"><a href="#第三步：计算卡方统计量-chi-2-1" class="headerlink" title="第三步：计算卡方统计量 ($\chi^2$)"></a>第三步：计算卡方统计量 ($\chi^2$)</h3><p><strong>公式：</strong> $\chi^2 = \sum \frac{(O - E)^2}{E}$</p><p>我们需要把4个格子算一遍，然后加起来：</p><ol><li><p><strong>男生-逃过课：</strong><br>$\frac{(34 - 29.76)^2}{29.76} = \frac{4.24^2}{29.76} = \frac{17.98}{29.76} \approx \mathbf{0.604}$</p></li><li><p><strong>女生-逃过课：</strong><br>$\frac{(38 - 42.24)^2}{42.24} = \frac{(-4.24)^2}{42.24} = \frac{17.98}{42.24} \approx \mathbf{0.426}$</p></li><li><p><strong>男生-未逃课：</strong><br>$\frac{(28 - 32.24)^2}{32.24} = \frac{(-4.24)^2}{32.24} = \frac{17.98}{32.24} \approx \mathbf{0.558}$</p></li><li><p><strong>女生-未逃课：</strong><br>$\frac{(50 - 45.76)^2}{45.76} = \frac{4.24^2}{45.76} = \frac{17.98}{45.76} \approx \mathbf{0.393}$</p></li></ol><p><strong>总和：</strong><br>$\chi^2 = 0.604 + 0.426 + 0.558 + 0.393 = \mathbf{1.981}$</p><hr><h3 id="第四步：确定临界值并比较-1"><a href="#第四步：确定临界值并比较-1" class="headerlink" title="第四步：确定临界值并比较"></a>第四步：确定临界值并比较</h3><ol><li><p><strong>确定自由度 ($df$)：</strong><br>对于行x列的表格，自由度 = (行数-1) $\times$ (列数-1)。<br>这是一个 $2 \times 2$ 的表格，所以：<br>$df = (2-1) \times (2-1) = 1 \times 1 = \mathbf{1}$</p></li><li><p><strong>查找临界值：</strong><br>题目给出的显著性水平 $\alpha = 0.05$。<br>查卡方分布表，找到 $df=1, \alpha=0.05$ 对应的数值。<br>临界值 <strong>$\chi^2_{0.05}(1) = 3.841$</strong>。</p></li><li><p><strong>比较：</strong></p><ul><li>我们算出来的统计量：<strong>$1.981$</strong></li><li>临界值标准：<strong>$3.841$</strong></li></ul><p><strong>$1.981 &lt; 3.841$</strong><br>（算出来的差异比较小，没有超过警戒线）</p></li></ol><hr><h3 id="第五步：得出结论-1"><a href="#第五步：得出结论-1" class="headerlink" title="第五步：得出结论"></a>第五步：得出结论</h3><ul><li><strong>统计结论：</strong> 因为 $\chi^2$ 小于临界值，落在了接受域，所以我们<strong>不能拒绝原假设 $H_0$</strong>。</li><li><strong>业务解释：</strong> 在0.05的显著性水平下，我们认为<strong>“是否逃课”与“学生性别”是相互独立的</strong>。</li></ul><p><strong>通俗得说：</strong> 虽然数据上看男生逃课比例（34/62 ≈ 54.8%）稍微比女生（38/88 ≈ 43.1%）高一点点，但经过计算，这种差别还不够大，可能是偶然造成的。统计学上认为男女生在逃课这件事情上表现是<strong>差不多</strong>的，没太大关系。</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214205614752-1765716976499-1.png" alt="image-20251214205614752"></p><p>没问题！多做题是掌握统计学最好的方法。</p><p>这道题和上一道题的区别在于：上一道是 <strong>$2\times2$</strong> 的表格（2行2列），而这道题是 <strong>$3\times2$</strong> 的表格（3行2列）。计算量稍微大一点点，但逻辑完全一样。</p><p>我们要解决的问题是：<strong>上市公司的“类型”（主板/中小板/创业板）和它们“是否关注股价”这两件事，有没有关系？</strong></p><hr><h3 id="第一步：整理数据与建立假设"><a href="#第一步：整理数据与建立假设" class="headerlink" title="第一步：整理数据与建立假设"></a>第一步：整理数据与建立假设</h3><p>首先，我们需要把表格的<strong>边缘合计（Total）</strong>算出来，这是计算期望值的基础。</p><div class="table-container"><table><thead><tr><th style="text-align:left">上市公司类型</th><th style="text-align:left">关注</th><th style="text-align:left">不关注</th><th style="text-align:left"><strong>行合计</strong></th></tr></thead><tbody><tr><td style="text-align:left">主板企业</td><td style="text-align:left">50</td><td style="text-align:left">70</td><td style="text-align:left"><strong>120</strong></td></tr><tr><td style="text-align:left">中小板企业</td><td style="text-align:left">30</td><td style="text-align:left">15</td><td style="text-align:left"><strong>45</strong></td></tr><tr><td style="text-align:left">创业板企业</td><td style="text-align:left">20</td><td style="text-align:left">5</td><td style="text-align:left"><strong>25</strong></td></tr><tr><td style="text-align:left"><strong>列合计</strong></td><td style="text-align:left"><strong>100</strong></td><td style="text-align:left"><strong>90</strong></td><td style="text-align:left"><strong>总人数 190</strong></td></tr></tbody></table></div><p><strong>设立假设：</strong></p><ul><li><strong>原假设 ($H_0$)：</strong> 上市公司的类型与对股价波动的关注程度<strong>相互独立</strong>（没关系）。<ul><li><em>意思是：不管你是哪个板块的公司，关注股价的比例应该是差不多的。</em></li></ul></li><li><strong>备择假设 ($H_1$)：</strong> 上市公司的类型与对股价波动的关注程度<strong>不独立</strong>（有关系）。</li></ul><hr><h3 id="第二步：计算期望频数-E-2"><a href="#第二步：计算期望频数-E-2" class="headerlink" title="第二步：计算期望频数 ($E$)"></a>第二步：计算期望频数 ($E$)</h3><p>如果原假设成立（大家没区别），那么每个格子的数值应该按总体的比例分配。</p><p><strong>公式：</strong> $E = \frac{\text{该行合计} \times \text{该列合计}}{\text{总人数}}$</p><p>我们需要算出表格中 <strong>6个格子</strong> 的期望值：</p><ol><li><strong>主板-关注：</strong> $\frac{120 \times 100}{190} \approx \mathbf{63.16}$</li><li><strong>主板-不关注：</strong> $\frac{120 \times 90}{190} \approx \mathbf{56.84}$</li><li><strong>中小板-关注：</strong> $\frac{45 \times 100}{190} \approx \mathbf{23.68}$</li><li><strong>中小板-不关注：</strong> $\frac{45 \times 90}{190} \approx \mathbf{21.32}$</li><li><strong>创业板-关注：</strong> $\frac{25 \times 100}{190} \approx \mathbf{13.16}$</li><li><strong>创业板-不关注：</strong> $\frac{25 \times 90}{190} \approx \mathbf{11.84}$</li></ol><hr><h3 id="第三步：计算卡方统计量-chi-2-2"><a href="#第三步：计算卡方统计量-chi-2-2" class="headerlink" title="第三步：计算卡方统计量 ($\chi^2$)"></a>第三步：计算卡方统计量 ($\chi^2$)</h3><p><strong>公式：</strong> $\chi^2 = \sum \frac{(O - E)^2}{E}$</p><p>把这6组数据代入公式计算（这步最繁琐，考试时要按计算器仔细点）：</p><ol><li><strong>主板-关注：</strong> $\frac{(50 - 63.16)^2}{63.16} = \frac{(-13.16)^2}{63.16} \approx \mathbf{2.74}$</li><li><strong>主板-不关注：</strong> $\frac{(70 - 56.84)^2}{56.84} = \frac{13.16^2}{56.84} \approx \mathbf{3.05}$</li><li><strong>中小板-关注：</strong> $\frac{(30 - 23.68)^2}{23.68} = \frac{6.32^2}{23.68} \approx \mathbf{1.69}$</li><li><strong>中小板-不关注：</strong> $\frac{(15 - 21.32)^2}{21.32} = \frac{(-6.32)^2}{21.32} \approx \mathbf{1.87}$</li><li><strong>创业板-关注：</strong> $\frac{(20 - 13.16)^2}{13.16} = \frac{6.84^2}{13.16} \approx \mathbf{3.55}$</li><li><strong>创业板-不关注：</strong> $\frac{(5 - 11.84)^2}{11.84} = \frac{(-6.84)^2}{11.84} \approx \mathbf{3.95}$</li></ol><p><strong>求和：</strong><br>$\chi^2 = 2.74 + 3.05 + 1.69 + 1.87 + 3.55 + 3.95 = \mathbf{16.85}$</p><p><em>(这个数值比较大，感觉大概率要拒绝原假设了)</em></p><hr><h3 id="第四步：确定临界值并比较-2"><a href="#第四步：确定临界值并比较-2" class="headerlink" title="第四步：确定临界值并比较"></a>第四步：确定临界值并比较</h3><ol><li><p><strong>确定自由度 ($df$)：</strong><br>公式：$df = (\text{行数}-1) \times (\text{列数}-1)$<br>这里有3种企业类型（3行），2种关注态度（2列）。<br>$df = (3-1) \times (2-1) = 2 \times 1 = \mathbf{2}$</p></li><li><p><strong>查找临界值：</strong><br>显著性水平 $\alpha = 0.05$，自由度 $df=2$。<br>查卡方分布表可得：临界值 <strong>$\chi^2_{0.05}(2) = 5.991$</strong>。</p></li><li><p><strong>比较：</strong></p><ul><li>计算值：<strong>$16.85$</strong></li><li>临界值：<strong>$5.991$</strong></li></ul><p><strong>$16.85 &gt; 5.991$</strong></p></li></ol><hr><h3 id="第五步：得出结论-2"><a href="#第五步：得出结论-2" class="headerlink" title="第五步：得出结论"></a>第五步：得出结论</h3><ul><li><strong>统计结论：</strong> 因为计算出的卡方值（16.85）远远大于临界值（5.991），落在拒绝域内，所以<strong>拒绝原假设 $H_0$</strong>。</li><li><strong>业务结论：</strong> 在0.05的显著性水平下，我们有充分理由认为：<strong>上市公司的类型与对股价波动的关注程度是有关联的（不独立）。</strong></li></ul><p><strong>💡 怎么理解这个结果？（深入分析）</strong><br>看我们的原始数据和期望值对比：</p><ul><li><strong>主板企业：</strong> 实际关注（50） &lt; 期望关注（63）。说明主板大企业可能比较“佛系”，没那么盯着股价看。</li><li><strong>中小板/创业板：</strong> 实际关注（30和20） &gt; 期望关注（23和13）。说明小公司、创业公司非常在意股价波动。</li></ul><p>所以，结论就是：<strong>越是创业板/中小板的公司，越容易关注股价；主板公司则相对不那么关注。这两件事是有显著关系的。</strong></p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214210203226.png" alt="image-20251214210203226"></p><p>这道题的数据量更大了，是一个 <strong>$4\times3$</strong> 的表格（4种价格档位，3个地区）。</p><p>虽然格子变多了（一共12个格子），但不要慌，解题逻辑还是那唯一的套路。</p><p>我们要解决的问题是：<strong>所在的“地区”不同，买车的“价格”偏好是否有区别？</strong>（即：地区和购车价格是否独立？）</p><hr><h3 id="第一步：整理数据与计算合计"><a href="#第一步：整理数据与计算合计" class="headerlink" title="第一步：整理数据与计算合计"></a>第一步：整理数据与计算合计</h3><p>先把表格的行合计（Row Total）和列合计（Column Total）算出来，这是基础中的基础。</p><div class="table-container"><table><thead><tr><th style="text-align:left">汽车价格</th><th style="text-align:left">东部</th><th style="text-align:left">中部</th><th style="text-align:left">西部</th><th style="text-align:left"><strong>行合计</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>10万以下</strong></td><td style="text-align:left">20</td><td style="text-align:left">40</td><td style="text-align:left">40</td><td style="text-align:left"><strong>100</strong></td></tr><tr><td style="text-align:left"><strong>10万-20万</strong></td><td style="text-align:left">50</td><td style="text-align:left">60</td><td style="text-align:left">50</td><td style="text-align:left"><strong>160</strong></td></tr><tr><td style="text-align:left"><strong>20万-30万</strong></td><td style="text-align:left">30</td><td style="text-align:left">20</td><td style="text-align:left">20</td><td style="text-align:left"><strong>70</strong></td></tr><tr><td style="text-align:left"><strong>30万以上</strong></td><td style="text-align:left">40</td><td style="text-align:left">20</td><td style="text-align:left">10</td><td style="text-align:left"><strong>70</strong></td></tr><tr><td style="text-align:left"><strong>列合计</strong></td><td style="text-align:left"><strong>140</strong></td><td style="text-align:left"><strong>140</strong></td><td style="text-align:left"><strong>120</strong></td><td style="text-align:left"><strong>总人数 400</strong></td></tr></tbody></table></div><p><strong>建立假设：</strong></p><ul><li><strong>原假设 ($H_0$)：</strong> 地区与所购买的汽车价格<strong>相互独立</strong>（没关系）。<ul><li><em>意思是：不管你在哪个区，买豪车或买便宜车的比例应该是一样的。</em></li></ul></li><li><strong>备择假设 ($H_1$)：</strong> 地区与所购买的汽车价格<strong>不独立</strong>（有关系）。</li></ul><hr><h3 id="第二步：计算期望频数-E-3"><a href="#第二步：计算期望频数-E-3" class="headerlink" title="第二步：计算期望频数 ($E$)"></a>第二步：计算期望频数 ($E$)</h3><p><strong>公式：</strong> $E = \frac{\text{该行合计} \times \text{该列合计}}{\text{总人数}}$</p><p>我们要算12个格子的期望值（总人数 $N=400$）：</p><p><strong>第1行（10万以下，行合计100）：</strong></p><ul><li>东部：$100 \times 140 / 400 = \mathbf{35}$</li><li>中部：$100 \times 140 / 400 = \mathbf{35}$</li><li>西部：$100 \times 120 / 400 = \mathbf{30}$</li></ul><p><strong>第2行（10-20万，行合计160）：</strong></p><ul><li>东部：$160 \times 140 / 400 = \mathbf{56}$</li><li>中部：$160 \times 140 / 400 = \mathbf{56}$</li><li>西部：$160 \times 120 / 400 = \mathbf{48}$</li></ul><p><strong>第3行（20-30万，行合计70）：</strong></p><ul><li>东部：$70 \times 140 / 400 = \mathbf{24.5}$</li><li>中部：$70 \times 140 / 400 = \mathbf{24.5}$</li><li>西部：$70 \times 120 / 400 = \mathbf{21}$</li></ul><p><strong>第4行（30万以上，行合计70）：</strong></p><ul><li>东部：$70 \times 140 / 400 = \mathbf{24.5}$</li><li>中部：$70 \times 140 / 400 = \mathbf{24.5}$</li><li>西部：$70 \times 120 / 400 = \mathbf{21}$</li></ul><hr><h3 id="第三步：计算卡方统计量-chi-2-3"><a href="#第三步：计算卡方统计量-chi-2-3" class="headerlink" title="第三步：计算卡方统计量 ($\chi^2$)"></a>第三步：计算卡方统计量 ($\chi^2$)</h3><p><strong>公式：</strong> $\chi^2 = \sum \frac{(O - E)^2}{E}$</p><p>这一步是体力活，把12个格子的差异都算出来：</p><ol><li><p><strong>10万以下组：</strong></p><ul><li>东：$(20-35)^2 / 35 \approx \mathbf{6.43}$</li><li>中：$(40-35)^2 / 35 \approx \mathbf{0.71}$</li><li>西：$(40-30)^2 / 30 \approx \mathbf{3.33}$</li></ul></li><li><p><strong>10-20万组：</strong></p><ul><li>东：$(50-56)^2 / 56 \approx \mathbf{0.64}$</li><li>中：$(60-56)^2 / 56 \approx \mathbf{0.29}$</li><li>西：$(50-48)^2 / 48 \approx \mathbf{0.08}$</li></ul></li><li><p><strong>20-30万组：</strong></p><ul><li>东：$(30-24.5)^2 / 24.5 \approx \mathbf{1.23}$</li><li>中：$(20-24.5)^2 / 24.5 \approx \mathbf{0.83}$</li><li>西：$(20-21)^2 / 21 \approx \mathbf{0.05}$</li></ul></li><li><p><strong>30万以上组（注意这里差异很大）：</strong></p><ul><li>东：$(40-24.5)^2 / 24.5 \approx \mathbf{9.81}$  <em>(实际买豪车的人远超预期)</em></li><li>中：$(20-24.5)^2 / 24.5 \approx \mathbf{0.83}$</li><li>西：$(10-21)^2 / 21 \approx \mathbf{5.76}$ <em>(实际买豪车的人远低于预期)</em></li></ul></li></ol><p><strong>总加和：</strong><br>$\chi^2 \approx 6.43 + 0.71 + 3.33 + 0.64 + 0.29 + 0.08 + 1.23 + 0.83 + 0.05 + 9.81 + 0.83 + 5.76 = \mathbf{29.99}$</p><hr><h3 id="第四步：确定临界值并比较-3"><a href="#第四步：确定临界值并比较-3" class="headerlink" title="第四步：确定临界值并比较"></a>第四步：确定临界值并比较</h3><ol><li><p><strong>确定自由度 ($df$)：</strong><br>公式：$df = (\text{行数}-1) \times (\text{列数}-1)$<br>这里有4种价格，3个地区。<br>$df = (4-1) \times (3-1) = 3 \times 2 = \mathbf{6}$</p></li><li><p><strong>查找临界值：</strong><br>显著性水平 $\alpha = 0.05$，自由度 $df=6$。<br>查卡方分布表可得：临界值 <strong>$\chi^2_{0.05}(6) = 12.592$</strong>。</p></li><li><p><strong>比较：</strong></p><ul><li>计算值：<strong>$29.99$</strong></li><li>临界值：<strong>$12.592$</strong></li></ul><p><strong>$29.99 &gt; 12.592$</strong></p></li></ol><hr><h3 id="第五步：得出结论-3"><a href="#第五步：得出结论-3" class="headerlink" title="第五步：得出结论"></a>第五步：得出结论</h3><ul><li><strong>统计结论：</strong> 因为计算出的卡方值（29.99）远大于临界值（12.59），落在拒绝域，所以<strong>拒绝原假设 $H_0$</strong>。</li><li><strong>业务结论：</strong> 在0.05的显著性水平下，我们认为：<strong>所在的地区与购买的汽车价格是有显著关系的（不独立）。</strong></li></ul><p><strong>💡 详细解读（看数据说话）：</strong><br>通过对比 $O$（实际）和 $E$（期望），我们发现了明显的地域消费特征：</p><ul><li><strong>东部地区：</strong> 实际买“30万以上”豪车的人（40人）远多于理论期望（24.5人），而买“10万以下”便宜车的人（20人）远少于期望（35人）。<strong>结论：东部人更有钱，偏爱高价车。</strong></li><li><strong>西部地区：</strong> 恰恰相反，买“30万以上”的人（10人）远少于期望（21人），买“10万以下”的人（40人）多于期望（30人）。<strong>结论：西部地区消费者更偏向经济型车。</strong></li><li><strong>中部地区：</strong> 实际值和期望值差别不大（卡方贡献值都很小），说明比较平均。</li></ul><p><strong>方差分析（ANOVA）</strong>这一章是统计学中的“重头戏”，也是继t检验（两组比较）之后的自然进阶。</p><p>我来帮你拆解这一章到底在讲什么，以及考试的通关秘籍。</p><hr><h3 id="一、-这一章讲的是什么？（大白话版）"><a href="#一、-这一章讲的是什么？（大白话版）" class="headerlink" title="一、 这一章讲的是什么？（大白话版）"></a>一、 这一章讲的是什么？（大白话版）</h3><p><strong>1. 核心目的：比较“三个或更多”群体的平均值。</strong></p><ul><li><strong>以前学的（t检验）：</strong> 比较“男生的身高”和“女生的身高”有没有区别？（两组）</li><li><strong>现在学的（方差分析）：</strong> 比较“大一、大二、大三、大四”四个年级的平均绩点有没有区别？（多组）</li></ul><p><strong>2. 为什么叫“方差”分析？（明明是在比平均值）</strong><br>这是初学者最大的困惑。</p><ul><li><strong>原理是这样的：</strong> 我们把数据的总波动（总方差）拆成两部分来看。<ul><li><strong>一部分是因为“分组”造成的（组间差异/信号）：</strong> 比如大四学生确实比大一学生绩点高。</li><li><strong>一部分是因为“随机”造成的（组内差异/噪音）：</strong> 同是大一学生，每个人绩点也不一样，这是随机误差。</li></ul></li><li><strong>判断逻辑：</strong> 如果<strong>“组间差异”</strong>（信号）远远大于<strong>“组内差异”</strong>（噪音），我们就认为这些组之间是真的有区别，而不是瞎猫碰死耗子。</li><li>因为是用“方差”的比值（F统计量）来判断，所以叫方差分析。</li></ul><p><strong>3. 这一章的两个主角：</strong></p><ul><li><strong>单因子方差分析：</strong> 只看一个变量的影响。<ul><li><em>例子：</em> <strong>灯泡品牌</strong>（A/B/C）对<strong>寿命</strong>的影响。</li></ul></li><li><strong>双因子方差分析：</strong> 看两个变量的影响，以及它们合起来的影响（交互效应）。<ul><li><em>例子：</em> <strong>灯泡品牌</strong>（A/B/C）和<strong>瓦数</strong>（60W/100W）对<strong>寿命</strong>的影响。</li></ul></li></ul><hr><h3 id="二、-考试会怎么考？（高分攻略）"><a href="#二、-考试会怎么考？（高分攻略）" class="headerlink" title="二、 考试会怎么考？（高分攻略）"></a>二、 考试会怎么考？（高分攻略）</h3><p>方差分析的考题非常套路化，掌握了<strong>“一张表、三个公式、一个假设”</strong>，基本就能拿高分。</p><h4 id="考点-1：补全“方差分析表”-ANOVA-Table-——-⭐⭐⭐⭐⭐-必考"><a href="#考点-1：补全“方差分析表”-ANOVA-Table-——-⭐⭐⭐⭐⭐-必考" class="headerlink" title="考点 1：补全“方差分析表” (ANOVA Table) —— ⭐⭐⭐⭐⭐ (必考)"></a>考点 1：补全“方差分析表” (ANOVA Table) —— ⭐⭐⭐⭐⭐ (必考)</h4><p>考试最喜欢给你一个缺胳膊少腿的表格，让你把空填上。你必须死记硬背下面这个逻辑关系：</p><div class="table-container"><table><thead><tr><th style="text-align:left">来源</th><th style="text-align:left">平方和 (SS)</th><th style="text-align:left">自由度 (df)</th><th style="text-align:left">均方 (MS)</th><th style="text-align:left">F值</th></tr></thead><tbody><tr><td style="text-align:left"><strong>组间 (因素/处理)</strong></td><td style="text-align:left">SSA</td><td style="text-align:left">$k-1$ (组数-1)</td><td style="text-align:left">$MSA = \frac{SSA}{df}$</td><td style="text-align:left">$F = \frac{MSA}{MSE}$</td></tr><tr><td style="text-align:left"><strong>组内 (误差)</strong></td><td style="text-align:left">SSE</td><td style="text-align:left">$n-k$ (总人数-组数)</td><td style="text-align:left">$MSE = \frac{SSE}{df}$</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">SST</td><td style="text-align:left">$n-1$ (总人数-1)</td><td style="text-align:left"></td></tr></tbody></table></div><p><strong>高分秘籍（记公式）：</strong></p><ol><li><strong>横向关系：</strong> $MS = SS \div df$ （均方 = 平方和 除以 自由度）</li><li><strong>纵向关系：</strong> $SST = SSA + SSE$ （总波动 = 组间 + 组内）</li><li><strong>自由度关系：</strong>总自由度 = 组间自由度 + 组内自由度</li><li><strong>F值核心：</strong> $F = MSA \div MSE$ （F值越大，说明组间差异越显著，越容易拒绝原假设）</li></ol><h4 id="考点-2：怎么写假设？-Hypothesis-——-⭐⭐⭐"><a href="#考点-2：怎么写假设？-Hypothesis-——-⭐⭐⭐" class="headerlink" title="考点 2：怎么写假设？ (Hypothesis) —— ⭐⭐⭐"></a>考点 2：怎么写假设？ (Hypothesis) —— ⭐⭐⭐</h4><p>方差分析的假设写法很特别，千万别写错。</p><ul><li><strong>原假设 ($H_0$)：</strong> $\mu_1 = \mu_2 = \mu_3 = … = \mu_k$<ul><li>(所有组的平均值都相等，大家没区别)</li></ul></li><li><strong>备择假设 ($H_1$)：</strong> <strong>至少有一组</strong>的平均值与其他组不同。<ul><li><em>注意：千万别写成 $\mu_1 \neq \mu_2 \neq \mu_3$（全都不相等），只要有一个“叛徒”不一样，$H_1$就成立。</em></li></ul></li></ul><h4 id="考点-3：双因子分析中的“交互效应”-——-⭐⭐⭐⭐"><a href="#考点-3：双因子分析中的“交互效应”-——-⭐⭐⭐⭐" class="headerlink" title="考点 3：双因子分析中的“交互效应” —— ⭐⭐⭐⭐"></a>考点 3：双因子分析中的“交互效应” —— ⭐⭐⭐⭐</h4><p>双因子分析多了一个考点：<strong>A和B碰到一起会不会产生化学反应？</strong></p><ul><li><strong>例子：</strong> “止痛药类型”和“性别”。可能药A对男生管用，药B对女生管用。这就是交互效应。</li><li><strong>看图技巧：</strong> 考试如果给你画了两条线图：<ul><li>如果两条线<strong>平行</strong> $\rightarrow$ 没有交互效应。</li><li>如果两条线<strong>交叉</strong> $\rightarrow$ 有交互效应。</li></ul></li></ul><h4 id="考点-4：前提条件-Assumptions-——-⭐⭐-通常考选择-填空"><a href="#考点-4：前提条件-Assumptions-——-⭐⭐-通常考选择-填空" class="headerlink" title="考点 4：前提条件 (Assumptions) —— ⭐⭐ (通常考选择/填空)"></a>考点 4：前提条件 (Assumptions) —— ⭐⭐ (通常考选择/填空)</h4><p>方差分析能用，必须满足三个条件（书上图里也有）：</p><ol><li><strong>正态性：</strong> 每一组数据都要符合正态分布。</li><li><strong>方差齐性：</strong> 每一组数据的波动程度（方差）应该差不多（Levene检验就是干这个的）。</li><li><strong>独立性：</strong> 样本之间互不干扰。</li></ol><hr><h3 id="三、-你应该怎么做？（复习计划）"><a href="#三、-你应该怎么做？（复习计划）" class="headerlink" title="三、 你应该怎么做？（复习计划）"></a>三、 你应该怎么做？（复习计划）</h3><ol><li><p><strong>死磕“方差分析表”：</strong><br>找几道例题，遮住答案。题目只给你SS和df，你要能自己算出MS和F值。这是送分题，算错了就太亏了。</p></li><li><p><strong>理解SST、SSA、SSE的含义：</strong></p><ul><li>SST (Total)：总的波动。</li><li>SSA (Factor/Treatment)：是你研究的那个因素搞出来的动静。</li><li>SSE (Error)：是随机误差，是你没法解释的噪音。</li><li><strong>核心思想：</strong> SSA 占 SST 的比例越大，说明你研究的因素影响越大。</li></ul></li><li><p><strong>搞定自由度 ($df$) 的计算：</strong><br>这是最容易晕的地方。</p><ul><li>假设有3个班，每班10人，共30人。</li><li>组间df = 3 - 1 = 2</li><li>总df = 30 - 1 = 29</li><li>组内df = 29 - 2 = 27 (或者 30-3=27)</li><li><em>考试时经常只给你两个df，让你推算第三个。</em></li></ul></li><li><p><strong>事后比较（LSD/HSD）：</strong><br>知道这是干嘛的就行。如果F检验通过了（说明有差异），到底是哪两组有差异？（是大一和大三不同？还是大一和大四不同？）这时候才用LSD或HSD去具体抓“凶手”。</p></li></ol><p><strong>总结：</strong><br>这一章数学推导很繁琐，但<strong>应用</strong>很简单。<br><strong>重点抓：</strong> $H_0$怎么写、ANOVA表格怎么填、F值怎么算、最后怎么根据P值或F临界值下结论。</p><p>接下来如果你遇到方差分析的具体计算题，发给我，我带你填一次表你就懂了！</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214211839937.png" alt="image-20251214211839937"></p><p>这是一道标准的<strong>单因子方差分析（One-Way ANOVA）</strong>综合题。</p><p>这道题非常经典，因为它涵盖了方差分析的完整流程：<strong>计算F值判断整体差异 $\rightarrow$ 事后比较找具体差异 $\rightarrow$ 检验前提条件</strong>。</p><p>我们分三步带你把这道题吃透。</p><hr><h3 id="第一步：整理数据与计算统计量（为ANOVA做准备）"><a href="#第一步：整理数据与计算统计量（为ANOVA做准备）" class="headerlink" title="第一步：整理数据与计算统计量（为ANOVA做准备）"></a>第一步：整理数据与计算统计量（为ANOVA做准备）</h3><p>首先，我们不能光看原始数字，要先算出每一组（每一台机器）的<strong>平均值</strong>和<strong>样本量</strong>。这是所有计算的基础。</p><ul><li><strong>机器1 ($n_1=4$)：</strong> $(4.05+4.01+4.02+4.04)/4 = \mathbf{4.03}$</li><li><strong>机器2 ($n_2=6$)：</strong> $(3.99+4.02+4.01+3.99+4.00+4.00)/6 \approx \mathbf{4.002}$</li><li><strong>机器3 ($n_3=5$)：</strong> $(3.97+3.98+3.97+3.95+4.00)/5 = \mathbf{3.974}$</li><li><p><strong>机器4 ($n_4=4$)：</strong> $(4.00+4.02+3.99+4.01)/4 = \mathbf{4.005}$</p></li><li><p><strong>总样本量 ($n$)：</strong> $4+6+5+4 = \mathbf{19}$</p></li><li><strong>总平均值 ($\bar{\bar{x}}$)：</strong> 所有数据的平均 $\approx \mathbf{4.001}$</li></ul><p><strong>👀 直观观察：</strong><br>还没开始算你就能发现，<strong>机器1（4.03）</strong>好像装得有点多，<strong>机器3（3.974）</strong>装得有点少，机器2和4比较接近标准（4.00）。方差分析就是要验证这个直观感觉是不是“显著”的。</p><hr><h3 id="第二步：解答第-1-问——方差分析检验"><a href="#第二步：解答第-1-问——方差分析检验" class="headerlink" title="第二步：解答第(1)问——方差分析检验"></a>第二步：解答第(1)问——方差分析检验</h3><p><strong>1. 建立假设</strong></p><ul><li>$H_0$：$\mu_1 = \mu_2 = \mu_3 = \mu_4$ （四台机器的平均装填量<strong>没有</strong>显著差异）。</li><li>$H_1$：至少有一台机器的平均装填量与其他机器<strong>不同</strong>。</li></ul><p><strong>2. 构造方差分析表（核心计算）</strong><br>我们需要计算三个关键指标：<strong>SSA（组间差异）</strong>、<strong>SSE（组内误差）</strong> 和 <strong>F统计量</strong>。</p><p><em>(此处省略繁琐的手算平方过程，直接给出计算结果逻辑)</em></p><ul><li><p><strong>SSA (组间平方和)：</strong> 反映不同机器之间的差异。<br>$SSA \approx 0.0071$<br>自由度 $df_A = k-1 = 4-1 = \mathbf{3}$<br>$MSA = 0.0071 / 3 \approx \mathbf{0.00237}$</p></li><li><p><strong>SSE (组内误差平方和)：</strong> 反映机器自身的随机波动（这是分母，用来衡量噪音）。<br>$SSE \approx 0.0037$<br>自由度 $df_E = n-k = 19-4 = \mathbf{15}$<br>$MSE = 0.0037 / 15 \approx \mathbf{0.00025}$</p></li><li><p><strong>计算 F值：</strong><br>$F = \frac{MSA}{MSE} = \frac{0.00237}{0.00025} \approx \mathbf{9.48}$</p></li></ul><p><strong>3. 查表与决策</strong></p><ul><li>题目要求显著性水平 $\alpha=0.01$。</li><li>查F分布表（分子自由度3，分母自由度15）：$F_{0.01}(3, 15) \approx \mathbf{5.42}$。</li><li><strong>比较：</strong> 我们算出来的 $F=9.48$ <strong>&gt;</strong> 临界值 $5.42$。</li></ul><p><strong>4. 结论</strong><br>因为F值落在拒绝域，所以<strong>拒绝原假设 $H_0$</strong>。<br><strong>结论：</strong> 在0.01的显著性水平下，我们可以认为<strong>不同机器对装填量有显著影响</strong>（即这4台机器装出来的牛奶不一样多）。</p><hr><h3 id="第三步：解答第-2-问——事后比较-LSD-和-HSD"><a href="#第三步：解答第-2-问——事后比较-LSD-和-HSD" class="headerlink" title="第三步：解答第(2)问——事后比较 (LSD 和 HSD)"></a>第三步：解答第(2)问——事后比较 (LSD 和 HSD)</h3><p>既然方差分析告诉我们“有区别”，那到底是<strong>谁和谁</strong>有区别？是机器1出了问题？还是机器3？这就需要事后比较。</p><p><strong>1. LSD (最小显著差异法) 分析：</strong><br>LSD 比较“敏感”，容易发现差异。</p><ul><li><strong>逻辑：</strong> 只要两台机器平均值的差值 $&gt; LSD$ 值，就认为有差异。</li><li><strong>观察我们的均值：</strong><ul><li>机器1 (4.03) vs 机器3 (3.974) $\rightarrow$ 差了 <strong>0.056</strong> (差异巨大)。</li><li>机器1 (4.03) vs 机器2 (4.002) $\rightarrow$ 差了 <strong>0.028</strong> (差异明显)。</li></ul></li><li><strong>LSD结论预判：</strong> 机器1明显装多了，机器3明显装少了。机器2和4之间（4.002 vs 4.005）差别很小，应该没区别。</li></ul><p><strong>2. HSD (Tukey的诚实显著差异法) 分析：</strong><br>HSD 比较“保守”，只有差异真的很大时才承认。</p><ul><li><strong>逻辑：</strong> 它会计算一个比LSD更严格的标准。</li><li><strong>HSD结论预判：</strong> 即使在严格标准下，<strong>机器1（最高）和机器3（最低）</strong> 之间的差异（0.056）肯定也是显著的。</li></ul><p><strong>📝 答题话术：</strong><br>通过计算比较，<strong>机器1的装填量显著高于机器3</strong>。机器1可能也显著高于机器2和4。机器3显著低于其他机器。机器2和4之间没有显著差异。</p><hr><h3 id="第四步：解答第-3-问——前提条件评估"><a href="#第四步：解答第-3-问——前提条件评估" class="headerlink" title="第四步：解答第(3)问——前提条件评估"></a>第四步：解答第(3)问——前提条件评估</h3><p>这道题其实是在考你方差分析的<strong>理论假设</strong>。做ANOVA必须满足以下条件，否则结果不可信：</p><p><strong>1. 正态性 (Normality)：</strong></p><ul><li><strong>含义：</strong> 每一台机器的装填量数据，应该呈现“中间多、两头少”的钟形分布。</li><li><strong>如何评估：</strong> 如果是用软件（SPSS），我们会看 <strong>Shapiro-Wilk 检验</strong> 的P值。如果 P &gt; 0.05，说明符合正态分布。或者看 Q-Q 图，点是不是都在直线上。</li></ul><p><strong>2. 方差齐性 (Homogeneity of Variance)：</strong></p><ul><li><strong>含义：</strong> 4台机器的稳定性应该差不多。不能说机器1特别稳（波动极小），而机器2忽高忽低（波动极大）。如果波动程度差别太大，ANOVA就不准了。</li><li><strong>如何评估：</strong> 使用 <strong>Levene 检验</strong>。<ul><li>假设 $H_0$：各组方差相等。</li><li>如果 Levene检验的 P值 &gt; 0.05，说明方差是齐的（满足条件）。</li><li>如果 P值 &lt; 0.05，说明方差不齐，需要用其他的矫正方法（如Welch检验）。</li></ul></li></ul><hr><h3 id="💡-总结：考试时这题怎么拿分？"><a href="#💡-总结：考试时这题怎么拿分？" class="headerlink" title="💡 总结：考试时这题怎么拿分？"></a>💡 总结：考试时这题怎么拿分？</h3><ol><li><strong>算准均值：</strong> 这一步错了后面全错，一定要按两遍计算器。</li><li><strong>背熟ANOVA表：</strong> 只要你能把 SSA、SSE、MSA、MSE、F 这一串数算出来，80%的分数就到手了。</li><li><strong>结论要完整：</strong> 不要光写“拒绝$H_0$”，要写“说明不同机器对装填量有显著影响”。</li><li><strong>前提条件是送分题：</strong> 只要写出“正态性”和“方差齐性”这两个词，基本上分就拿到了。</li></ol><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214212432549.png" alt="image-20251214212432549"></p><p>这也是一道非常标准的<strong>单因子方差分析（One-way ANOVA）</strong>题目。</p><p>与上一题（牛奶装填）唯一的区别在于：<strong>这一题各组的样本量（人数）是不一样的</strong>。</p><ul><li>高级管理者：5人</li><li>中级管理者：7人</li><li>初级管理者：6人</li></ul><p>但这完全不影响计算逻辑。我们按照标准步骤来解题。</p><hr><h3 id="第一步：整理数据与计算均值"><a href="#第一步：整理数据与计算均值" class="headerlink" title="第一步：整理数据与计算均值"></a>第一步：整理数据与计算均值</h3><p>这是所有后续计算的基础，先算出每组的平均分和总平均分。</p><p><strong>1. 高级管理者组 ($n_1=5$)：</strong></p><ul><li>总分 $T_1 = 7+7+8+7+9 = 38$</li><li>均值 $\bar{x}_1 = 38 \div 5 = \mathbf{7.6}$</li></ul><p><strong>2. 中级管理者组 ($n_2=7$)：</strong></p><ul><li>总分 $T_2 = 8+9+8+10+9+10+8 = 62$</li><li>均值 $\bar{x}_2 = 62 \div 7 \approx \mathbf{8.86}$</li></ul><p><strong>3. 初级管理者组 ($n_3=6$)：</strong></p><ul><li>总分 $T_3 = 5+6+5+7+4+8 = 35$</li><li>均值 $\bar{x}_3 = 35 \div 6 \approx \mathbf{5.83}$</li></ul><p><strong>4. 全体汇总 ($n=18$)：</strong></p><ul><li>总人数 $n = 5+7+6 = 18$</li><li>总分和 $T = 38+62+35 = 135$</li><li>总均值 $\bar{\bar{x}} = 135 \div 18 = \mathbf{7.5}$</li></ul><p><strong>👀 直观观察：</strong><br>还没算方差，你就能看出来：<strong>中级管理者（8.86分）</strong>对讲座非常满意，而<strong>初级管理者（5.83分）</strong>似乎不太买账。这种明显的差异，预示着最后的F值可能会很大。</p><hr><h3 id="第二步：建立假设"><a href="#第二步：建立假设" class="headerlink" title="第二步：建立假设"></a>第二步：建立假设</h3><ul><li><strong>原假设 ($H_0$)：</strong> $\mu_1 = \mu_2 = \mu_3$<ul><li><em>意思是：不同层次的管理者的平均满意度<strong>没有</strong>显著差异。</em></li></ul></li><li><strong>备择假设 ($H_1$)：</strong> 管理者的层次不同<strong>会</strong>导致评分的显著差异。</li></ul><hr><h3 id="第三步：计算平方和-SS-与-均方-MS"><a href="#第三步：计算平方和-SS-与-均方-MS" class="headerlink" title="第三步：计算平方和 (SS) 与 均方 (MS)"></a>第三步：计算平方和 (SS) 与 均方 (MS)</h3><p>这是计算中最繁琐的一步，建议考试时列个表。</p><p><strong>1. 计算总平方和 (SST)：</strong><br>（反映所有数据的总波动）</p><script type="math/tex; mode=display">SST = \sum x^2 - \frac{(\sum x)^2}{n}</script><p>先算出所有18个数据的平方和：<br>$7^2+…9^2 + 8^2…+8^2 + 5^2…+8^2 = 1061$<br>修正项：$135^2 \div 18 = 1012.5$<br><strong>$SST = 1061 - 1012.5 = 48.5$</strong></p><p><strong>2. 计算组间平方和 (SSA)：</strong><br>（反映“职位层次”带来的差异）<br>公式：$SSA = \sum n_i(\bar{x}_i - \bar{\bar{x}})^2$</p><ul><li>高级组贡献：$5 \times (7.6 - 7.5)^2 = 0.05$</li><li>中级组贡献：$7 \times (8.86 - 7.5)^2 \approx 12.95$</li><li>初级组贡献：$6 \times (5.83 - 7.5)^2 \approx 16.73$<br><strong>$SSA = 0.05 + 12.95 + 16.73 = 29.73$</strong><br><em>(由于小数点保留问题，精确计算结果约为 29.6，我们按 <strong>29.6</strong> 计算)</em></li></ul><p><strong>3. 计算组内平方和 (SSE)：</strong><br>（反映随机误差，即同一层次内部的人评分也不一样）<br>$SSE = SST - SSA$<br><strong>$SSE = 48.5 - 29.6 = 18.9$</strong></p><hr><h3 id="第四步：构造方差分析表（计算F值）"><a href="#第四步：构造方差分析表（计算F值）" class="headerlink" title="第四步：构造方差分析表（计算F值）"></a>第四步：构造方差分析表（计算F值）</h3><div class="table-container"><table><thead><tr><th style="text-align:left">差异来源</th><th style="text-align:left">平方和 (SS)</th><th style="text-align:left">自由度 (df)</th><th style="text-align:left">均方 (MS)</th><th style="text-align:left">F值</th></tr></thead><tbody><tr><td style="text-align:left"><strong>组间 (因素)</strong></td><td style="text-align:left">29.6</td><td style="text-align:left">$k-1 = 3-1 = \mathbf{2}$</td><td style="text-align:left">$29.6 \div 2 = \mathbf{14.8}$</td><td style="text-align:left"><strong>$14.8 \div 1.26 \approx 11.75$</strong></td></tr><tr><td style="text-align:left"><strong>组内 (误差)</strong></td><td style="text-align:left">18.9</td><td style="text-align:left">$n-k = 18-3 = \mathbf{15}$</td><td style="text-align:left">$18.9 \div 15 = \mathbf{1.26}$</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">48.5</td><td style="text-align:left">$n-1 = 17$</td><td style="text-align:left"></td></tr></tbody></table></div><p>我们算出的统计量 <strong>$F \approx 11.75$</strong>。</p><hr><h3 id="第五步：查表与决策"><a href="#第五步：查表与决策" class="headerlink" title="第五步：查表与决策"></a>第五步：查表与决策</h3><ol><li><p><strong>确定临界值：</strong></p><ul><li>显著性水平 $\alpha = 0.05$</li><li>分子自由度 = 2</li><li>分母自由度 = 15</li><li>查F分布表：$F_{0.05}(2, 15) = \mathbf{3.68}$</li></ul></li><li><p><strong>比较：</strong></p><ul><li>计算出的F值：<strong>11.75</strong></li><li>临界值：<strong>3.68</strong></li><li><strong>$11.75 &gt; 3.68$</strong></li></ul></li></ol><hr><h3 id="第六步：最终结论"><a href="#第六步：最终结论" class="headerlink" title="第六步：最终结论"></a>第六步：最终结论</h3><ul><li><strong>统计结论：</strong> 因为 F值 落在拒绝域内（远大于临界值），所以<strong>拒绝原假设 $H_0$</strong>。</li><li><strong>业务解释：</strong> 在0.05的显著性水平下，我们有充分的理由认为：<strong>管理者的层次不同会导致对讲座的满意度有显著差异。</strong></li></ul><p><strong>💡 深入分析（给老板看的报告）：</strong><br>不仅是有差异，结合平均分看：</p><ul><li><strong>中级管理者 (8.86)</strong> 最喜欢这个讲座。</li><li><strong>高级管理者 (7.6)</strong> 感觉一般。</li><li><strong>初级管理者 (5.83)</strong> 评分显著偏低。<br><strong>建议：</strong> 这个讲座内容可能太深奥或太理论，适合中层听，初级员工听不懂或觉得没用。如果要给初级员工培训，建议调整内容。</li></ul><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214212603275.png" alt="image-20251214212603275"></p><p>这道题是一道非常经典的<strong>“单因子方差分析 + 事后比较（HSD）”</strong>的组合拳题目。</p><p>它模拟了真实的商业决策场景：如果你是采购经理，面对三家供应商，你应该怎么选？</p><p>我们分两部分来解决：首先做<strong>方差分析</strong>判断有没有差异，然后做<strong>HSD检验</strong>看具体谁好谁坏。</p><hr><h3 id="第一部分：方差分析检验-ANOVA"><a href="#第一部分：方差分析检验-ANOVA" class="headerlink" title="第一部分：方差分析检验 (ANOVA)"></a>第一部分：方差分析检验 (ANOVA)</h3><p><strong>1. 准备工作：计算均值</strong><br>先把最基础的数据算出来，这是后续所有计算的地基。</p><ul><li><strong>企业 A ($n=5$)：</strong><ul><li>总和 = $50+50+43+40+39 = 222$</li><li>均值 $\bar{x}_A = 222 \div 5 = \mathbf{44.4}$ (小时)</li></ul></li><li><strong>企业 B ($n=5$)：</strong><ul><li>总和 = $32+28+30+34+26 = 150$</li><li>均值 $\bar{x}_B = 150 \div 5 = \mathbf{30.0}$ (小时)</li></ul></li><li><p><strong>企业 C ($n=5$)：</strong></p><ul><li>总和 = $45+42+38+48+40 = 213$</li><li>均值 $\bar{x}_C = 213 \div 5 = \mathbf{42.6}$ (小时)</li></ul></li><li><p><strong>总体 ($N=15$)：</strong></p><ul><li>总和 $G = 222 + 150 + 213 = 585$</li><li>总均值 $\bar{\bar{x}} = 585 \div 15 = \mathbf{39.0}$</li></ul></li></ul><p><strong>👀 直观观察：</strong><br>还没算你就能发现：A（44.4）和 C（42.6）的表现很接近且都很高，而 B（30.0）明显是个“差生”。我们的计算应该会证实这一点。</p><p><strong>2. 建立假设</strong></p><ul><li>$H_0$: $\mu_A = \mu_B = \mu_C$ （三家企业的电池平均寿命没区别）。</li><li>$H_1$: 至少有一家企业的平均寿命与其他不同。</li></ul><p><strong>3. 计算平方和 (Sum of Squares)</strong></p><ul><li><p><strong>组间平方和 (SSA)：</strong> 反映品牌之间的差异。</p><script type="math/tex; mode=display">SSA = \sum n_i(\bar{x}_i - \bar{\bar{x}})^2</script><ul><li>A贡献：$5 \times (44.4 - 39)^2 = 5 \times 29.16 = 145.8$</li><li>B贡献：$5 \times (30.0 - 39)^2 = 5 \times 81 = 405.0$</li><li>C贡献：$5 \times (42.6 - 39)^2 = 5 \times 12.96 = 64.8$</li><li><strong>$SSA = 145.8 + 405.0 + 64.8 = \mathbf{615.6}$</strong></li></ul></li><li><p><strong>组内平方和 (SSE)：</strong> 反映误差（计算繁琐，这里直接给结果）。<br>通过计算每个数据点减去各自组均值的平方和。</p><ul><li><strong>$SSE = 216.4$</strong></li></ul></li><li><p><strong>总平方和 (SST)：</strong></p><ul><li>$SST = SSA + SSE = 615.6 + 216.4 = 832.0$</li></ul></li></ul><p><strong>4. 构造方差分析表 (ANOVA Table)</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">来源</th><th style="text-align:left">平方和 (SS)</th><th style="text-align:left">自由度 (df)</th><th style="text-align:left">均方 (MS)</th><th style="text-align:left">F值</th></tr></thead><tbody><tr><td style="text-align:left"><strong>组间 (因素)</strong></td><td style="text-align:left">615.6</td><td style="text-align:left">$3-1 = \mathbf{2}$</td><td style="text-align:left">$615.6 \div 2 = \mathbf{307.8}$</td><td style="text-align:left">$307.8 \div 18.03$</td></tr><tr><td style="text-align:left"><strong>组内 (误差)</strong></td><td style="text-align:left">216.4</td><td style="text-align:left">$15-3 = \mathbf{12}$</td><td style="text-align:left">$216.4 \div 12 \approx \mathbf{18.03}$</td><td style="text-align:left">$\approx \mathbf{17.07}$</td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">832.0</td><td style="text-align:left">$14$</td><td style="text-align:left"></td></tr></tbody></table></div><p><strong>5. 检验结论</strong></p><ul><li>查表：$F_{0.05}(2, 12) = \mathbf{3.89}$</li><li>比较：$17.07 &gt; 3.89$</li><li><strong>结论：</strong> F值落入拒绝域，<strong>拒绝原假设</strong>。说明这三家企业的电池寿命<strong>存在显著差异</strong>。</li></ul><hr><h3 id="第二部分：HSD-事后比较-Tukey’s-HSD"><a href="#第二部分：HSD-事后比较-Tukey’s-HSD" class="headerlink" title="第二部分：HSD 事后比较 (Tukey’s HSD)"></a>第二部分：HSD 事后比较 (Tukey’s HSD)</h3><p>既然有差异，那到底是谁和谁不一样？题目要求用 <strong>HSD (Honestly Significant Difference)</strong> 方法。</p><p><strong>1. 计算临界值 (HSD Value)</strong><br>公式：$HSD = q_{\alpha}(k, df_E) \sqrt{\frac{MSE}{n}}$</p><p>这里需要查 <strong>学生化极差分布表 (q table)</strong>：</p><ul><li>$k=3$ (3个组)</li><li>$df_E = 12$ (误差自由度)</li><li>$\alpha = 0.05$</li><li>查表得 $q$值 $\approx 3.77$ (考试时会给出或允许查表)</li></ul><p>代入数据：</p><ul><li>$MSE = 18.03$</li><li>$n = 5$</li><li>$HSD = 3.77 \times \sqrt{\frac{18.03}{5}} = 3.77 \times \sqrt{3.606} \approx 3.77 \times 1.90 \approx \mathbf{7.16}$</li></ul><p><strong>意思就是：两组平均值的差，只要超过 7.16，就算有显著差异。</strong></p><p><strong>2. 两两比较</strong></p><ul><li><strong>A vs B:</strong> $|44.4 - 30.0| = \mathbf{14.4}$<ul><li>$14.4 &gt; 7.16$ $\rightarrow$ <strong>有显著差异</strong> (A比B好得多)</li></ul></li><li><strong>C vs B:</strong> $|42.6 - 30.0| = \mathbf{12.6}$<ul><li>$12.6 &gt; 7.16$ $\rightarrow$ <strong>有显著差异</strong> (C比B好得多)</li></ul></li><li><strong>A vs C:</strong> $|44.4 - 42.6| = \mathbf{1.8}$<ul><li>$1.8 &lt; 7.16$ $\rightarrow$ <strong>无显著差异</strong> (A和C差不多)</li></ul></li></ul><hr><h3 id="💡-最终业务结论-给老板的建议"><a href="#💡-最终业务结论-给老板的建议" class="headerlink" title="💡 最终业务结论 (给老板的建议)"></a>💡 最终业务结论 (给老板的建议)</h3><ol><li><strong>整体来看：</strong> 三家供应商的电池质量参差不齐，必须进行筛选。</li><li><strong>具体来看：</strong><ul><li><strong>供应商B是“坑”：</strong> 它的平均寿命只有30小时，显著低于A和C，<strong>直接淘汰</strong>。</li><li><strong>A和C不分伯仲：</strong> 供应商A（44.4小时）虽然看起来比C（42.6小时）高一点点，但在统计学上这属于“误差范围内的波动”，<strong>两者质量相当</strong>。</li></ul></li><li><strong>采购建议：</strong> 既然A和C质量没区别，建议<strong>谁便宜买谁</strong>，或者谁交货快买谁。不要买B。</li></ol><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214212738711.png" alt="image-20251214212738711"></p><p>这是一道典型的<strong>补全方差分析表</strong>的题目。这是考试中最容易拿分的题型，因为它不需要你去算繁琐的原始数据，只需要利用表格内部的逻辑关系做加减乘除。</p><h3 id="核心逻辑回顾"><a href="#核心逻辑回顾" class="headerlink" title="核心逻辑回顾"></a>核心逻辑回顾</h3><p>在做题前，请记住这三个核心关系：</p><ol><li><strong>自由度 (df) 关系：</strong> 总计df = 处理df + 误差df。</li><li><strong>平方和 (SS) 关系：</strong> 总计SS = 处理SS + 误差SS。</li><li><strong>均方 (MS) 计算：</strong> $MS = SS \div df$ （这是横向关系）。</li><li><strong>F值计算：</strong> $F = MS(处理) \div MS(误差)$。</li></ol><hr><h3 id="第-1-问：完成方差分析表"><a href="#第-1-问：完成方差分析表" class="headerlink" title="第 (1) 问：完成方差分析表"></a>第 (1) 问：完成方差分析表</h3><p>我们需要通过已知的数字，推导出空格里的数字。</p><p><strong>1. 确定自由度 (df)</strong></p><ul><li>题目说了有 <strong>3种方法</strong> ($k=3$)，<strong>30名工人</strong> ($n=30$)。</li><li><strong>总计 df：</strong> 题目已给出是 <strong>29</strong> (验证：$n-1 = 30-1=29$)，正确。</li><li><strong>处理 (组间) df：</strong> $k - 1 = 3 - 1 = \mathbf{2}$。</li><li><strong>误差 (组内) df：</strong> 总df - 处理df $= 29 - 2 = \mathbf{27}$。</li></ul><p><strong>2. 确定平方和 (SS)</strong></p><ul><li><strong>处理 SS：</strong> 我们已知处理的 $MS = 210$，且刚算出来 $df = 2$。<br>根据公式 $SS = MS \times df$，所以 处理 $SS = 210 \times 2 = \mathbf{420}$。</li><li><strong>误差 SS：</strong> 题目已给出是 <strong>3836</strong>。</li><li><strong>总计 SS：</strong> 处理SS + 误差SS $= 420 + 3836 = \mathbf{4256}$。</li></ul><p><strong>3. 确定均方 (MS)</strong></p><ul><li><strong>处理 MS：</strong> 题目已给出是 210。</li><li><strong>误差 MS：</strong> $MSE = \text{误差SS} \div \text{误差df}$。<br>$MSE = 3836 \div 27 \approx \mathbf{142.07}$。</li></ul><p><strong>4. 确定 F值</strong></p><ul><li>$F = MSA \div MSE$<br>$F = 210 \div 142.07 \approx \mathbf{1.48}$。</li></ul><p><strong>✅ 最终补全后的表格如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">差异源</th><th style="text-align:left">SS (平方和)</th><th style="text-align:left">df (自由度)</th><th style="text-align:left">MS (均方)</th><th style="text-align:left">F</th><th style="text-align:left">P-value</th></tr></thead><tbody><tr><td style="text-align:left"><strong>处理 (组间)</strong></td><td style="text-align:left"><strong>420</strong></td><td style="text-align:left"><strong>2</strong></td><td style="text-align:left">210</td><td style="text-align:left"><strong>1.48</strong></td><td style="text-align:left">0.245946</td></tr><tr><td style="text-align:left"><strong>误差 (组内)</strong></td><td style="text-align:left">3836</td><td style="text-align:left"><strong>27</strong></td><td style="text-align:left"><strong>142.07</strong></td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left"><strong>4256</strong></td><td style="text-align:left">29</td><td style="text-align:left">—</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr></tbody></table></div><hr><h3 id="第-2-问：检验是否有显著差异-alpha-0-05"><a href="#第-2-问：检验是否有显著差异-alpha-0-05" class="headerlink" title="第 (2) 问：检验是否有显著差异 ($\alpha=0.05$)"></a>第 (2) 问：检验是否有显著差异 ($\alpha=0.05$)</h3><p>这一问其实是送分题，因为表格里直接给了 <strong>P-value (P值)</strong>。</p><p><strong>方法一：看 P值 (最快)</strong></p><ul><li><strong>规则：</strong><ul><li>如果 P值 &lt; 0.05，拒绝原假设 (有显著差异)。</li><li>如果 P值 &gt; 0.05，不拒绝原假设 (无显著差异)。</li></ul></li><li><strong>判断：</strong><br>表格中给出的 $P\text{-value} = 0.245946$。<br>因为 <strong>$0.245946 &gt; 0.05$</strong>。</li><li><strong>结论：</strong><br>我们<strong>不拒绝原假设</strong>。即：没有充分的证据表明这3种组装方法生产的产品数量有显著差异。</li></ul><p><strong>方法二：看 F值 (传统方法)</strong></p><ul><li>我们计算出的 $F = 1.48$。</li><li>查临界值表 $F_{0.05}(2, 27)$，大概在 <strong>3.35</strong> 左右。</li><li>因为 $1.48 &lt; 3.35$ (没超过警戒线)，所以结论一样：<strong>无显著差异</strong>。</li></ul><p><strong>💡 业务结论 (说人话)：</strong><br>这一轮测试下来，这三种组装方法的效率其实<strong>半斤八烈，差不多</strong>。不用纠结选哪一种，因为它们之间没啥本质区别。</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214213017367.png" alt="image-20251214213017367"></p><p>这道题难度升级了！恭喜你进入了<strong>双因子方差分析（Two-way ANOVA）</strong>的领域。</p><p><strong>为什么叫“双因子”？</strong><br>之前的题（比如电池、牛奶）只看一个因素（品牌或机器）。而这道题我们要同时看两个因素对收成的影响：</p><ol><li><strong>因素 A：</strong> 品种（有5种）</li><li><strong>因素 B：</strong> 施肥方案（有4种）</li></ol><p>而且，仔细看表格，每个格子只有<strong>一个数据</strong>。这叫做<strong>“无重复双因子方差分析”</strong>。这意味着我们暂时不考虑两个因素搅在一起的“交互效应”，只看它们各自的主效应。</p><p>下面带你一步步拆解：</p><hr><h3 id="第一步：整理数据（算合计）"><a href="#第一步：整理数据（算合计）" class="headerlink" title="第一步：整理数据（算合计）"></a>第一步：整理数据（算合计）</h3><p>做双因子分析，必须先把<strong>“行合计”</strong>和<strong>“列合计”</strong>算出来。</p><p><strong>1. 计算行合计（品种的影响）：</strong></p><ul><li>品种1：$12.0+9.5+10.4+9.7 = \mathbf{41.6}$</li><li>品种2：$13.7+11.5+12.4+9.6 = \mathbf{47.2}$</li><li>品种3：$14.3+12.3+11.4+11.1 = \mathbf{49.1}$</li><li>品种4：$14.2+14.0+12.5+12.0 = \mathbf{52.7}$</li><li>品种5：$13.0+14.0+13.1+11.4 = \mathbf{51.5}$</li></ul><p><strong>2. 计算列合计（施肥的影响）：</strong></p><ul><li>方案1：$12.0+13.7+14.3+14.2+13.0 = \mathbf{67.2}$</li><li>方案2：$9.5+11.5+12.3+14.0+14.0 = \mathbf{61.3}$</li><li>方案3：$10.4+12.4+11.4+12.5+13.1 = \mathbf{59.8}$</li><li>方案4：$9.7+9.6+11.1+12.0+11.4 = \mathbf{53.8}$</li></ul><p><strong>3. 总计：</strong><br>所有数据之和 = $242.1$<br>总样本量 $n = 20$<br>修正系数 $C = 242.1^2 / 20 \approx 2930.6$</p><hr><h3 id="第二步：建立假设-1"><a href="#第二步：建立假设-1" class="headerlink" title="第二步：建立假设"></a>第二步：建立假设</h3><p>我们需要分别对两个因素提问：</p><p><strong>针对品种（行）：</strong></p><ul><li>$H_0$：不同品种的平均收获量相同（品种没影响）。</li><li>$H_1$：不同品种的平均收获量<strong>有显著差异</strong>。</li></ul><p><strong>针对施肥（列）：</strong></p><ul><li>$H_0$：不同施肥方案的平均收获量相同（肥料没影响）。</li><li>$H_1$：不同施肥方案的平均收获量<strong>有显著差异</strong>。</li></ul><hr><h3 id="第三步：计算平方和-SS"><a href="#第三步：计算平方和-SS" class="headerlink" title="第三步：计算平方和 (SS)"></a>第三步：计算平方和 (SS)</h3><p>这步比较繁琐，我们直接列出计算逻辑和结果：</p><ol><li><p><strong>总平方和 (SST)：</strong><br>所有20个数据的平方和 - 修正系数。<br>$SST = (12.0^2 + … + 11.4^2) - 2930.6 = 2985.65 - 2930.6 = \mathbf{55.05}$</p></li><li><p><strong>行平方和 (SSR - 品种)：</strong><br>$\sum(\text{行合计}^2 / 4) - \text{修正系数}$<br>$SSR = (41.6^2+…+51.5^2)/4 - 2930.6 = \mathbf{20.57}$</p></li><li><p><strong>列平方和 (SSC - 施肥)：</strong><br>$\sum(\text{列合计}^2 / 5) - \text{修正系数}$<br>$SSC = (67.2^2+…+53.8^2)/5 - 2930.6 = \mathbf{19.38}$</p></li><li><p><strong>误差平方和 (SSE)：</strong><br>$SSE = SST - SSR - SSC$<br>$SSE = 55.05 - 20.57 - 19.38 = \mathbf{15.10}$</p></li></ol><hr><h3 id="第四步：构造方差分析表（关键步骤）"><a href="#第四步：构造方差分析表（关键步骤）" class="headerlink" title="第四步：构造方差分析表（关键步骤）"></a>第四步：构造方差分析表（关键步骤）</h3><p>这里我们需要两个F值，分别检验两个因素。</p><div class="table-container"><table><thead><tr><th style="text-align:left">变异来源</th><th style="text-align:left">平方和 (SS)</th><th style="text-align:left">自由度 (df)</th><th style="text-align:left">均方 (MS)</th><th style="text-align:left">F值</th><th style="text-align:left">临界值 $F_\alpha$</th></tr></thead><tbody><tr><td style="text-align:left"><strong>行 (品种)</strong></td><td style="text-align:left">20.57</td><td style="text-align:left">$5-1=\mathbf{4}$</td><td style="text-align:left">$20.57 \div 4 = \mathbf{5.14}$</td><td style="text-align:left">$\frac{5.14}{1.26} = \mathbf{4.08}$</td><td style="text-align:left">$F_{0.05}(4,12)=\mathbf{3.26}$</td></tr><tr><td style="text-align:left"><strong>列 (施肥)</strong></td><td style="text-align:left">19.38</td><td style="text-align:left">$4-1=\mathbf{3}$</td><td style="text-align:left">$19.38 \div 3 = \mathbf{6.46}$</td><td style="text-align:left">$\frac{6.46}{1.26} = \mathbf{5.13}$</td><td style="text-align:left">$F_{0.05}(3,12)=\mathbf{3.49}$</td></tr><tr><td style="text-align:left"><strong>误差</strong></td><td style="text-align:left">15.10</td><td style="text-align:left">$4 \times 3 = \mathbf{12}$</td><td style="text-align:left">$15.10 \div 12 \approx \mathbf{1.26}$</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">55.05</td><td style="text-align:left">19</td><td style="text-align:left">—</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr></tbody></table></div><p><em>(注：误差自由度 = 行自由度 $\times$ 列自由度)</em></p><hr><h3 id="第五步：比较与结论"><a href="#第五步：比较与结论" class="headerlink" title="第五步：比较与结论"></a>第五步：比较与结论</h3><p>我们需要做两次判断：</p><p><strong>1. 判断“品种”是否有影响：</strong></p><ul><li>计算出的 $F_{\text{品种}} = \mathbf{4.08}$</li><li>临界值 $F_{0.05}(4, 12) = \mathbf{3.26}$</li><li><strong>$4.08 &gt; 3.26$</strong> $\rightarrow$ <strong>拒绝 $H_0$</strong>。</li><li><strong>结论：</strong> 不同<strong>品种</strong>对收获量有显著影响。</li></ul><p><strong>2. 判断“施肥方案”是否有影响：</strong></p><ul><li>计算出的 $F_{\text{施肥}} = \mathbf{5.13}$</li><li>临界值 $F_{0.05}(3, 12) = \mathbf{3.49}$</li><li><strong>$5.13 &gt; 3.49$</strong> $\rightarrow$ <strong>拒绝 $H_0$</strong>。</li><li><strong>结论：</strong> 不同<strong>施肥方案</strong>对收获量也有显著影响。</li></ul><hr><h3 id="💡-总结与业务洞察"><a href="#💡-总结与业务洞察" class="headerlink" title="💡 总结与业务洞察"></a>💡 总结与业务洞察</h3><p>这道题告诉我们：<br>要想庄稼长得好，<strong>选种子很重要，选肥料也很重要！</strong></p><ul><li>从数据看，<strong>品种4</strong>（总和52.7）表现最好，品种1（总和41.6）表现最差。</li><li>从肥料看，<strong>方案1</strong>（总和67.2）效果最好，方案4（总和53.8）效果最差。</li></ul><p>如果你是农场主，根据这个分析，明年的策略应该是：<strong>优先种植品种4，并采用方案1进行施肥</strong>。这就是双因子方差分析的价值所在。</p><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214213118727.png" alt="image-20251214213118727"></p><p>这道题是方差分析章节的<strong>“终极BOSS”</strong>：<strong>有重复观测的双因子方差分析</strong>。</p><p>它比上一题（种子与肥料）多了一个非常关键的概念：<strong>“交互作用” (Interaction)</strong>。</p><p><strong>什么是“交互作用”？</strong></p><ul><li><strong>独立作用：</strong> 也许高峰期堵车，也许路段1路况差。</li><li><strong>交互作用：</strong> 是不是路段1在高峰期<strong>特别</strong>堵（堵得不正常），而在非高峰期却很顺畅？也就是说，路段的影响是否依赖于时间段？</li></ul><p>表格里每个格子有 <strong>5个数据</strong>（而不是上一题的1个），这就是我们计算交互作用的基础。</p><p>我们分步来拆解这道题。</p><hr><h3 id="第一步：数据整理（计算均值与合计）"><a href="#第一步：数据整理（计算均值与合计）" class="headerlink" title="第一步：数据整理（计算均值与合计）"></a>第一步：数据整理（计算均值与合计）</h3><p>为了看清规律，我们先算出每个“格子”的合计，以及行、列的合计。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">路段1</th><th style="text-align:left">路段2</th><th style="text-align:left">路段3</th><th style="text-align:left"><strong>行合计 (时段)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>高峰期</strong> (5个数据)</td><td style="text-align:left">$181.4$</td><td style="text-align:left">$151.8$</td><td style="text-align:left">$172.2$</td><td style="text-align:left"><strong>$505.4$</strong></td></tr><tr><td style="text-align:left"><strong>非高峰期</strong> (5个数据)</td><td style="text-align:left">$150.0$</td><td style="text-align:left">$121.0$</td><td style="text-align:left">$141.4$</td><td style="text-align:left"><strong>$412.4$</strong></td></tr><tr><td style="text-align:left"><strong>列合计 (路段)</strong></td><td style="text-align:left"><strong>$331.4$</strong></td><td style="text-align:left"><strong>$272.8$</strong></td><td style="text-align:left"><strong>$313.6$</strong></td><td style="text-align:left"><strong>总计: $917.8$</strong></td></tr></tbody></table></div><ul><li><strong>总样本量 $N$：</strong> 30</li><li><strong>每个格子的样本量 $n$：</strong> 5</li></ul><p><strong>👀 直观观察（这步很重要）：</strong></p><ol><li><strong>看时段：</strong> 高峰期总计 (505.4) 明显比非高峰期 (412.4) 高。 $\rightarrow$ <strong>时段肯定有显著影响。</strong></li><li><strong>看路段：</strong> 路段1 (331.4) 最高，路段2 (272.8) 最低。 $\rightarrow$ <strong>路段应该也有显著影响。</strong></li><li><strong>看交互（关键）：</strong><ul><li>高峰期：路段1 比 路段2 多花了约 30分钟 ($181.4 - 151.8$)。</li><li>非高峰期：路段1 依然比 路段2 多花了约 29分钟 ($150.0 - 121.0$)。</li><li><strong>预判：</strong> 无论什么时间，路段1都比路段2慢同样的时间。这说明两者是“平行”的，<strong>大概率没有交互作用</strong>。</li></ul></li></ol><hr><h3 id="第二步：建立假设-2"><a href="#第二步：建立假设-2" class="headerlink" title="第二步：建立假设"></a>第二步：建立假设</h3><p>我们要检验三个东西，所以要有三组假设：</p><ol><li><strong>交互作用：</strong><ul><li>$H_0$：路段与时段之间<strong>不存在</strong>交互作用。</li><li>$H_1$：路段与时段之间<strong>存在</strong>交互作用。</li></ul></li><li><strong>行因素（时段）：</strong><ul><li>$H_0$：高峰与非高峰的行车时间无差异。</li></ul></li><li><strong>列因素（路段）：</strong><ul><li>$H_0$：不同路段的行车时间无差异。</li></ul></li></ol><hr><h3 id="第三步：方差分析表计算逻辑"><a href="#第三步：方差分析表计算逻辑" class="headerlink" title="第三步：方差分析表计算逻辑"></a>第三步：方差分析表计算逻辑</h3><p>我们需要计算4种变异来源：<strong>行（时段）</strong>、<strong>列（路段）</strong>、<strong>交互（时段×路段）</strong>、<strong>误差</strong>。</p><p><em>(省略繁琐的平方和计算过程，直接展示各部分自由度与逻辑)</em></p><ol><li><p><strong>确定自由度 (df)：</strong></p><ul><li><strong>行 (时段) df：</strong> $2 - 1 = \mathbf{1}$</li><li><strong>列 (路段) df：</strong> $3 - 1 = \mathbf{2}$</li><li><strong>交互 df：</strong> 行df $\times$ 列df $= 1 \times 2 = \mathbf{2}$</li><li><strong>误差 df：</strong> 总数据 - 格子数 $= 30 - 6 = \mathbf{24}$ （或者 $3 \times 2 \times (5-1) = 24$）</li><li><strong>总计 df：</strong> $30 - 1 = 29$</li></ul></li><li><p><strong>计算结果（近似值）：</strong></p><ul><li><strong>SSA (时段)：</strong> 差异巨大，F值会很大。</li><li><strong>SSB (路段)：</strong> 差异也大，F值也会大。</li><li><strong>SSAB (交互)：</strong> 根据我们刚才的直观观察，差异极小，F值应该很小。</li></ul></li></ol><p><strong>构造方差分析表（模拟计算结果）：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">变异来源</th><th style="text-align:left">SS (平方和)</th><th style="text-align:left">df (自由度)</th><th style="text-align:left">MS (均方)</th><th style="text-align:left">F值</th><th style="text-align:left">临界值 ($F_{0.05}$)</th><th style="text-align:left">P值估计</th></tr></thead><tbody><tr><td style="text-align:left"><strong>时段 (行)</strong></td><td style="text-align:left">288.3</td><td style="text-align:left">1</td><td style="text-align:left">288.3</td><td style="text-align:left"><strong>87.5</strong></td><td style="text-align:left">$4.26$</td><td style="text-align:left">$&lt;0.001$</td></tr><tr><td style="text-align:left"><strong>路段 (列)</strong></td><td style="text-align:left">184.2</td><td style="text-align:left">2</td><td style="text-align:left">92.1</td><td style="text-align:left"><strong>27.9</strong></td><td style="text-align:left">$3.40$</td><td style="text-align:left">$&lt;0.001$</td></tr><tr><td style="text-align:left"><strong>交互作用</strong></td><td style="text-align:left">1.1</td><td style="text-align:left">2</td><td style="text-align:left">0.55</td><td style="text-align:left"><strong>0.17</strong></td><td style="text-align:left">$3.40$</td><td style="text-align:left">$&gt;0.05$</td></tr><tr><td style="text-align:left"><strong>误差</strong></td><td style="text-align:left">79.1</td><td style="text-align:left">24</td><td style="text-align:left">3.3</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">552.7</td><td style="text-align:left">29</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p><em>(注：以上SS值为基于数据的估算，用于展示逻辑，考试时需按公式计算)</em></p><hr><h3 id="第四步：下结论（核心步骤）"><a href="#第四步：下结论（核心步骤）" class="headerlink" title="第四步：下结论（核心步骤）"></a>第四步：下结论（核心步骤）</h3><p>我们要依次看这三个F值：</p><p><strong>1. 检验交互作用 (Interaction)：</strong></p><ul><li>$F = 0.17 &lt; 3.40$</li><li><strong>结论：</strong> 不拒绝原假设。<strong>路段和时段之间没有显著的交互作用。</strong><ul><li><em>解释：</em> 路段烂就是路段烂，跟是不是高峰期没关系；高峰期堵就是高峰期堵，跟哪条路没关系。两者互不干涉。</li></ul></li></ul><p><strong>2. 检验时段影响 (Main Effect A)：</strong></p><ul><li>$F = 87.5 &gt; 4.26$</li><li><strong>结论：</strong> 拒绝原假设。<strong>高峰期和非高峰期的行车时间有显著差异。</strong>（这显然是常识，数据也证实了）。</li></ul><p><strong>3. 检验路段影响 (Main Effect B)：</strong></p><ul><li>$F = 27.9 &gt; 3.40$</li><li><strong>结论：</strong> 拒绝原假设。<strong>不同的路段行车时间有显著差异。</strong>（说明有的路确实比别的路更堵）。</li></ul><hr><h3 id="💡-考试通关总结"><a href="#💡-考试通关总结" class="headerlink" title="💡 考试通关总结"></a>💡 考试通关总结</h3><p>遇到这种<strong>“有重复双因子”</strong>的题，解题顺序是固定的：</p><ol><li><p><strong>先看交互作用！</strong></p><ul><li>如果交互作用<strong>不显著</strong>（像这道题），我们就说两个因素各自独立起作用，然后分别去分析A和B。</li><li>如果交互作用<strong>显著</strong>（比如F很大），那么单独分析A和B就没意义了。结论得写成：“时段对行车时间的影响，<strong>依赖于</strong>你走的是哪条路”。</li></ul></li><li><p><strong>怎么算自由度 (df)？</strong><br>记住这一串数字：</p><ul><li>行：$r-1$</li><li>列：$c-1$</li><li>交互：$(r-1)(c-1)$</li><li>误差：$rc(n-1)$ —— 也就是 <strong>总数 - 格子数</strong>。</li></ul></li><li><p><strong>业务建议：</strong><br>根据数据，路段1最堵，路段2最快。交警应该重点疏导路段1，而且这种疏导工作在高峰期和非高峰期都需要，因为它是“全天候”的堵。</p></li></ol><p><img src="D:\我的博客\myblog\source\_posts\其他\管理统计学.assets\image-20251214213305382.png" alt="image-20251214213305382"></p><p>这道题和上一道题（路段与时段）属于同一类，都是<strong>有重复观测的双因子方差分析</strong>。</p><p>我们要解决的问题是：<strong>不同的“广告方案”（A/B/C）和不同的“广告媒体”（报纸/电视）对销售量有没有影响？它们之间有没有“交互作用”？</strong></p><p>让我们按部就班，像剥洋葱一样解决它。</p><hr><h3 id="第一步：整理数据（计算核心指标）"><a href="#第一步：整理数据（计算核心指标）" class="headerlink" title="第一步：整理数据（计算核心指标）"></a>第一步：整理数据（计算核心指标）</h3><p>我们需要算出每个格子的总和、行合计、列合计，以及所有数据的总和。</p><p><strong>1. 每个格子的合计 (Cell Totals):</strong></p><ul><li><strong>A - 报纸:</strong> $8 + 12 = \mathbf{20}$</li><li><strong>A - 电视:</strong> $12 + 8 = \mathbf{20}$</li><li><strong>B - 报纸:</strong> $22 + 14 = \mathbf{36}$</li><li><strong>B - 电视:</strong> $26 + 30 = \mathbf{56}$</li><li><strong>C - 报纸:</strong> $10 + 18 = \mathbf{28}$</li><li><strong>C - 电视:</strong> $18 + 14 = \mathbf{32}$</li></ul><p><strong>2. 行合计 (方案 Scheme):</strong></p><ul><li>方案 A: $20 + 20 = \mathbf{40}$</li><li>方案 B: $36 + 56 = \mathbf{92}$</li><li>方案 C: $28 + 32 = \mathbf{60}$</li></ul><p><strong>3. 列合计 (媒体 Media):</strong></p><ul><li>报纸: $20 + 36 + 28 = \mathbf{84}$</li><li>电视: $20 + 56 + 32 = \mathbf{108}$</li></ul><p><strong>4. 总合计 (Grand Total):</strong></p><ul><li>$T = 40 + 92 + 60 = \mathbf{192}$</li><li>总样本量 $N = 12$，每组样本量 $n = 2$。</li></ul><hr><h3 id="第二步：计算平方和-SS-与-均方-MS"><a href="#第二步：计算平方和-SS-与-均方-MS" class="headerlink" title="第二步：计算平方和 (SS) 与 均方 (MS)"></a>第二步：计算平方和 (SS) 与 均方 (MS)</h3><p>我们需要计算5个平方和，这里直接给出计算结果，帮你理清逻辑：</p><ol><li><strong>修正系数 (C):</strong> $192^2 \div 12 = 3072$</li><li><strong>总平方和 (SST):</strong> 所有12个原始数据的平方和 - C。<br>$SST = 3616 - 3072 = \mathbf{544}$</li><li><strong>行平方和 (SSA - 方案):</strong><br>$SSA = (40^2 + 92^2 + 60^2) \div 4 - C = 3416 - 3072 = \mathbf{344}$</li><li><strong>列平方和 (SSB - 媒体):</strong><br>$SSB = (84^2 + 108^2) \div 6 - C = 3120 - 3072 = \mathbf{48}$</li><li><strong>误差平方和 (SSE):</strong><br>我们需要算出每个格子内部的差异。比如A-报纸组是8和12，差异贡献是 $(8-10)^2 + (12-10)^2 = 8$。<br>把所有6个格子的内部差异加起来，算得 <strong>$SSE = 96$</strong>。</li><li><strong>交互平方和 (SSAB):</strong><br>$SSAB = SST - SSA - SSB - SSE$<br>$SSAB = 544 - 344 - 48 - 96 = \mathbf{56}$</li></ol><hr><h3 id="第三步：构造方差分析表-ANOVA-Table"><a href="#第三步：构造方差分析表-ANOVA-Table" class="headerlink" title="第三步：构造方差分析表 (ANOVA Table)"></a>第三步：构造方差分析表 (ANOVA Table)</h3><p>这是解题的核心，我们需要算出三个 <strong>F值</strong>，并查表比较。</p><p><strong>自由度计算 (df):</strong></p><ul><li>方案 (行): $3 - 1 = \mathbf{2}$</li><li>媒体 (列): $2 - 1 = \mathbf{1}$</li><li>交互: $2 \times 1 = \mathbf{2}$</li><li>误差: $总数 - 格子数 = 12 - 6 = \mathbf{6}$</li></ul><p><strong>均方计算 (MS) = SS / df:</strong></p><ul><li>$MSA = 344 \div 2 = 172$</li><li>$MSB = 48 \div 1 = 48$</li><li>$MSAB = 56 \div 2 = 28$</li><li>$MSE = 96 \div 6 = 16$</li></ul><p><strong>F值计算 = MS / MSE:</strong></p><ul><li>$F_{\text{方案}} = 172 \div 16 = \mathbf{10.75}$</li><li>$F_{\text{媒体}} = 48 \div 16 = \mathbf{3.00}$</li><li>$F_{\text{交互}} = 28 \div 16 = \mathbf{1.75}$</li></ul><p><strong>临界值查表 ($\alpha=0.05$):</strong></p><ul><li>$F_{0.05}(2, 6) = \mathbf{5.14}$ (用于方案和交互)</li><li>$F_{0.05}(1, 6) = \mathbf{5.99}$ (用于媒体)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">差异源</th><th style="text-align:left">SS</th><th style="text-align:left">df</th><th style="text-align:left">MS</th><th style="text-align:left">F</th><th style="text-align:left">临界值</th><th style="text-align:left">结论</th></tr></thead><tbody><tr><td style="text-align:left"><strong>方案 (行)</strong></td><td style="text-align:left">344</td><td style="text-align:left">2</td><td style="text-align:left">172</td><td style="text-align:left"><strong>10.75</strong></td><td style="text-align:left">5.14</td><td style="text-align:left"><strong>显著</strong></td></tr><tr><td style="text-align:left"><strong>媒体 (列)</strong></td><td style="text-align:left">48</td><td style="text-align:left">1</td><td style="text-align:left">48</td><td style="text-align:left"><strong>3.00</strong></td><td style="text-align:left">5.99</td><td style="text-align:left">不显著</td></tr><tr><td style="text-align:left"><strong>交互作用</strong></td><td style="text-align:left">56</td><td style="text-align:left">2</td><td style="text-align:left">28</td><td style="text-align:left"><strong>1.75</strong></td><td style="text-align:left">5.14</td><td style="text-align:left">不显著</td></tr><tr><td style="text-align:left"><strong>误差</strong></td><td style="text-align:left">96</td><td style="text-align:left">6</td><td style="text-align:left">16</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>总计</strong></td><td style="text-align:left">544</td><td style="text-align:left">11</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><hr><h3 id="第四步：最终结论与业务建议"><a href="#第四步：最终结论与业务建议" class="headerlink" title="第四步：最终结论与业务建议"></a>第四步：最终结论与业务建议</h3><p>我们依照顺序来解读结果：</p><p><strong>1. 先看交互作用：</strong></p><ul><li>$F = 1.75 &lt; 5.14$。</li><li><strong>结论：</strong> <strong>没有显著的交互作用。</strong></li><li><em>意思是：</em> 无论你用哪种方案，电视和报纸的效果差距是固定的；或者说，方案的好坏不取决于你在哪打广告。两者互不干扰。</li></ul><p><strong>2. 再看主效应 A（广告方案）：</strong></p><ul><li>$F = 10.75 &gt; 5.14$。</li><li><strong>结论：</strong> <strong>广告方案对销售量有显著影响。</strong></li><li><em>分析：</em> 看行合计数据（A=40, B=92, C=60），<strong>方案 B (92) 明显是最好的</strong>，方案 A (40) 最差。</li></ul><p><strong>3. 最后看主效应 B（广告媒体）：</strong></p><ul><li>$F = 3.00 &lt; 5.99$。</li><li><strong>结论：</strong> <strong>广告媒体对销售量没有显著影响。</strong></li><li><em>分析：</em> 虽然电视的总销量 (108) 看起来比报纸 (84) 高一些，但在统计学上，这点差距被认为是“误差范围内的波动”，并不显著。</li></ul><hr><h3 id="💡-给营销公司的建议"><a href="#💡-给营销公司的建议" class="headerlink" title="💡 给营销公司的建议"></a>💡 给营销公司的建议</h3><ol><li><strong>方案选择：</strong> 必须用 <strong>方案 B</strong>！它的效果是碾压性的。</li><li><strong>媒体投放：</strong> 数据显示<strong>电视和报纸效果差不多</strong>（无显著差异）。<ul><li><strong>策略：</strong> 既然效果差不多，那就<strong>谁便宜投谁</strong>！如果报纸广告费比电视便宜很多，那就全部投报纸，配合方案B，性价比最高。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">管理统计学</summary>
    
    
    
    <category term="统计学" scheme="https://yjyrichard.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
    
    <category term="统计学" scheme="https://yjyrichard.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>别做那个“情绪暴徒”：关于爱、争吵和情绪价值的随想</title>
    <link href="https://yjyrichard.github.io/posts/24059cb2.html"/>
    <id>https://yjyrichard.github.io/posts/24059cb2.html</id>
    <published>2025-11-24T01:09:18.697Z</published>
    <updated>2025-11-29T14:21:54.615Z</updated>
    
    <content type="html"><![CDATA[<p><strong>别做那个“情绪暴徒”：关于爱、争吵和情绪价值的随想</strong></p><p><strong>发布时间：</strong> 2025年11月24日<br><strong>分类：</strong> 个人成长 / 碎碎念 </p><p>早上在地铁上刷到一个关于辩论的切片视频，里面的一段话像把温柔的手术刀，精准地剖开了我心里对于“亲密关系”和“家庭沟通”的陈旧认知。</p><p>看完之后，我坐在宿舍的椅子上发呆了好久。作为一名大学生，我们正处在一个微妙的阶段：一边试图摆脱原生家庭的束缚，一边又在跌跌撞撞地探索恋爱和友谊。</p><p>视频里那个辩手-罗淼说了一句让我起鸡皮疙瘩的话：<strong>“很多时候，我们是被血缘绑定的情绪暴徒。”</strong></p><p>今天想和大家聊聊，我从这段话里学到的，关于“情绪价值”的真正含义。</p><h3 id="01-我们总是急着争“对错”，却忘了“正当性”"><a href="#01-我们总是急着争“对错”，却忘了“正当性”" class="headerlink" title="01. 我们总是急着争“对错”，却忘了“正当性”"></a>01. 我们总是急着争“对错”，却忘了“正当性”</h3><p>在家里，或者在和男女朋友吵架时，我发现我们最常做的一件事就是——<strong>证明我是对的，你是错的。</strong></p><p>只要你的要求跟我不一样，那你就是无理取闹，你就是不懂事。<br>这种争论的终局，往往是有人出来“和稀泥”，说一句我最讨厌的话：“哎呀算了，家里不是分对错的地方。”</p><p>以前我觉得这句话很虚伪，现在我终于明白了为什么。因为这句话的潜台词是：“别争了，哪怕你受了委屈也忍着吧。”它根本没有解决问题，也没有尊重任何人的情绪。</p><p>视频里那个观点太赞了：<strong>真正的提供情绪价值，是承认对方的情绪和需求具有“正当性”，哪怕它跟我的需求完全冲突。</strong></p><p>举个那个很绝的例子：<br>情侣出去玩，男生很累想睡觉，女生想凌晨三点去爬山看日出。<br>通常我们会怎么吵？<br>男生：“你这个疯婆子，不让人睡觉。”（指责女生错）<br>女生：“你这个直男，一点都不浪漫。”（指责男生错）</p><p>但其实，<strong>这根本不是“对与错”的冲突，而是“对与对”的冲突。</strong><br>你想睡觉是对的，她想看日出也是对的。</p><p>如果能意识到这一点，对话就会变成：“我知道看日出对你很重要，但我真的太累了，没法陪你去，我很抱歉。”<br>——<strong>这就是情绪价值。我不一定能满足你，但我尊重你的需求，我不会因为我要睡觉就贬低你的愿望。</strong></p><h3 id="02-亲密关系是为了看见不一样的世界"><a href="#02-亲密关系是为了看见不一样的世界" class="headerlink" title="02. 亲密关系是为了看见不一样的世界"></a>02. 亲密关系是为了看见不一样的世界</h3><p>我以前总觉得，找对象就是找个三观一致、能顺着我的人。但视频里说，亲密关系不是为了找个顺从的一辈子的仆人，而是<strong>“透过他/她的眼睛，看见世界原来还可以是这个样子。”</strong></p><p>就像辩手提到的那个“棉花糖”的故事。一张被蒸汽挡住脸的照片，大人觉得拍废了，孩子却说：“哇，妈妈在棉花糖里。”</p><p>这让我想到我们这代人，总是活得很累，活在各种焦虑和“最优解”里。如果我们的伴侣、我们的朋友，能用一种我们理解不了但很可爱的逻辑去看待世界，那其实是一种馈赠，而不是一种麻烦。</p><p>当我们无法理解对方为什么要做某件“荒唐”的事时，先别急着骂。试着去想：<strong>作为一个正常人，他这么做一定有支撑他的理由。</strong> 去好奇那个理由，而不是审判那个行为。</p><h3 id="03-“带着情绪表达”-vs-“表达情绪”"><a href="#03-“带着情绪表达”-vs-“表达情绪”" class="headerlink" title="03. “带着情绪表达” vs “表达情绪”"></a>03. “带着情绪表达” vs “表达情绪”</h3><p>这是我这学期学到的最重要的一课。</p><p>很多人（包括我）以为，表达情绪就是大吼大叫、摔门、冷战。<br>错！那是<strong>“带着强烈情绪的表达”</strong>，那是宣泄，那是暴力。</p><p>真正的<strong>“表达情绪”</strong>，是在冷静下来后，诚实地说出自己的感受。</p><p>比如妈妈做了一大桌子菜，我们吃不完。<br><strong>糟糕的沟通：</strong> “哎呀你做这么多干嘛！浪费死了！跟你说过多少次了！”（贴标签，指责对错）<br><strong>稍微好点的沟通：</strong> “妈，虽然家里条件好了，但还是要节约，下次少做点。”（还在讲道理，还在评判行为）<br><strong>真正的情绪表达：</strong> “妈，看到你做这么多菜我很开心。但是太多了吃不完，我心里会很有负担，觉得很愧疚。下次做少一点，我吃得更香，心情也会更好。”</p><p>看，不用吵架，不用指责，只是把“我的感受”说出来，同时肯定“你的付出”。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>我们这代人，可能很多都在“打击式教育”或“以爱之名的控制”下长大。所以当我们自己开始经营关系时，很容易变成我们曾经讨厌的样子——变成一个新的“情绪暴徒”。</p><p>今天的分享其实也是写给我自己的备忘录：<br><strong>所谓的高情商和情绪价值，不需要你委屈自己去讨好别人。</strong><br>它只需要多一点点耐心，去相信：<br><strong>“你是对的，我也是对的。我们只是不一样，而这种不一样，值得被尊重。”</strong></p><p>愿我们都能在关系里，被温柔地“看见”。</p><hr><p><em>P.S. 那个视频真的值得反复观看，尤其是关于孩子摸电门那段，原来理解一个人的逻辑，比强行纠正他的行为，更能建立连接。</em></p><p>链接地址：【“强调情绪价值”对亲密关系利大于弊/弊大于利丨复赛第四场 天津大学vs北京大学】<a href="https://www.bilibili.com/video/BV1FW4y1c7Pt?vd_source=b0f2742e7b4a2838ad4d1870af693bc1">https://www.bilibili.com/video/BV1FW4y1c7Pt?vd_source=b0f2742e7b4a2838ad4d1870af693bc1</a></p>]]></content>
    
    
    <summary type="html">辩题：”强调情绪价值对亲密关系利大于弊“</summary>
    
    
    
    <category term="感想" scheme="https://yjyrichard.github.io/categories/%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="感想" scheme="https://yjyrichard.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>华语辩论赛-花束般的恋爱有感</title>
    <link href="https://yjyrichard.github.io/posts/8d03c736.html"/>
    <id>https://yjyrichard.github.io/posts/8d03c736.html</id>
    <published>2025-11-21T06:36:50.009Z</published>
    <updated>2025-11-21T06:39:07.725Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文送给你，也送给所有在青春的分岔路口，挥手告别过那个“曾经以为是一辈子”的人的我们。</p><hr><h3 id="花束般的恋爱：感谢那年遗憾，成全了此刻的我"><a href="#花束般的恋爱：感谢那年遗憾，成全了此刻的我" class="headerlink" title="花束般的恋爱：感谢那年遗憾，成全了此刻的我"></a>花束般的恋爱：感谢那年遗憾，成全了此刻的我</h3><p>大三的某个深夜，我在B站刷到了这段关于《花束般的恋爱》的辩论。屏幕里的声音喧嚣，有人说“不讲道理”，有人谈“生产关系”，还有人说“那是自由意志的沉沦”。</p><p>我听着听着，眼眶却湿了。</p><p>我想起了三年前的大一。那时候，我和谈了三年的高中初恋分手了。从那之后，我的感情生活就像是一片空白的雪地，我也曾问自己：<strong>是因为没遇到更好的人吗？还是因为我还在等一个回不来的旧梦？</strong></p><p>直到今晚，听完这些话，我终于找到了答案。</p><h4 id="一、-我们曾以为那是“命中注定”"><a href="#一、-我们曾以为那是“命中注定”" class="headerlink" title="一、 我们曾以为那是“命中注定”"></a>一、 我们曾以为那是“命中注定”</h4><p>视频里有人说，男女主角刚开始太像了，一样的球鞋，一样的书单，一样的歌。这种“百分之百的合拍”，像极了高中时代的我们。</p><p>那时的爱情太干净了。我们穿着一样的校服，做着一样的试卷，在这个小小的围墙里，我们共享着对未来的全部幻想。我们以为这就是爱，以为只要我们喜欢一样的东西，我们就是同一个世界的人。</p><p>就像视频里那个犀利的观点：“<strong>那不是爱，那只是我们在对方身上寻找自己的倒影。</strong>”</p><p>那时候的我不懂，以为三年的时光足够把我们绑在一起一辈子。可当我们迈入大学的那一刻，现实的洪流瞬间冲散了那一束精心包装的“花束”。</p><h4 id="二、-分手，其实是两个世界的“各归各位”"><a href="#二、-分手，其实是两个世界的“各归各位”" class="headerlink" title="二、 分手，其实是两个世界的“各归各位”"></a>二、 分手，其实是两个世界的“各归各位”</h4><p>大一那年的分手，来得并不激烈，甚至带着一种无力的默契。</p><p>就像视频里那个学姐说的：“我们不仅要看风花雪月，还要看面对困难时的勇气。”而那个大厂程序员的故事更是狠狠戳中了我——<strong>错位。</strong></p><p>高中时，我们的世界只有成绩单；大学后，世界变成了无数个选择题。</p><p>也许是我还没长大，还在怀念那个可以在操场走一圈又一圈的夏天；而她已经在那一刻，看到了更广阔的世界，或者是更现实的压力。我们不再是“一路人”了。</p><p>那个辩手说得好：“<strong>既然知道有了裂缝，为什么还要像握沙子一样越握越紧？最后只能是遍体鳞伤。</strong>”</p><p>以前我觉得分手是“失败”，是“被抛弃”。现在我才明白，那个转身，其实是我们对彼此最大的诚实。我们都在那一刻认清了：<strong>勉强把两条不再平行的线画在一起，是对过往美好的亵渎。</strong></p><h4 id="三、-我怀念的，是那个“笨拙去爱”的自己"><a href="#三、-我怀念的，是那个“笨拙去爱”的自己" class="headerlink" title="三、 我怀念的，是那个“笨拙去爱”的自己"></a>三、 我怀念的，是那个“笨拙去爱”的自己</h4><p>这两年我一直没谈恋爱。朋友们笑我深情，我自己却觉得迷茫。</p><p>视频里席瑞那句话，像一颗子弹击中了我：“<strong>我再也没有吃过那么好的一顿麦当劳，因为我知道那里有我所有对青春爱情的幻想，有我所有的勇气、赤诚和浪漫天真。</strong>”</p><p>我突然明白，为什么我大三了还单身。</p><p><strong>我不是还爱着那个高中同学，我是舍不得那个“为了一个人可以对抗全世界”的十八岁的自己。</strong></p><p>那时候的我，爱得毫无保留，爱得愚蠢又热烈。而现在的我，学会了权衡利弊，学会了在去爱之前先评估“适不适合”。那种纯粹的能量，随着那段花束般的恋爱，一起凋零了。</p><p>这才是最大的遗憾。<strong>不是遗憾失去了你，而是遗憾我也许再也无法像爱你那样，去爱后来的人。</strong></p><h4 id="四、-背对背挥手，是最好的Happy-Ending"><a href="#四、-背对背挥手，是最好的Happy-Ending" class="headerlink" title="四、 背对背挥手，是最好的Happy Ending"></a>四、 背对背挥手，是最好的Happy Ending</h4><p>视频的最后说，男女主角分手后背对背挥手，没有回头，这是一种圆满。</p><p>以前我不信，我觉得相爱就要厮守。现在我信了。</p><p>如果那段恋爱是一束花，它注定会枯萎。因为它没有根，它插在名为“青春”的花瓶里，只负责美，不负责结果。</p><p>但也正是因为这束花开过，我知道了什么是美，什么是痛，什么是成长的代价。</p><p><strong>我不再因为那段分手而感到羞耻或失败。</strong><br>正如那位辩手所说：“哪怕是写满遗憾的青春里，我的遗憾与你有关。”</p><p>这就够了。</p><p>致我的大三，也致那段封存在高中的回忆：</p><p>哪怕后来的我们，面对生活时一地鸡毛，哪怕我们变成了无趣的大人。但我永远感谢十六七岁的那个夏天，感谢你曾接住过我所有的天真。</p><p><strong>我们没有走到最后，但这不妨碍，那曾是最好的爱情。</strong></p><p>现在，我可以真正的转过身，向那个十八岁的背影挥挥手了。<br>再见。<br>我也该去种我自己的树了。</p>]]></content>
    
    
    <summary type="html">谈一场花束般的恋爱是遗憾还是圆满？</summary>
    
    
    
    <category term="感想" scheme="https://yjyrichard.github.io/categories/%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="感想" scheme="https://yjyrichard.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>21岁生日，我送给自己一份《西游记》里的“成人礼”</title>
    <link href="https://yjyrichard.github.io/posts/e7eedc60.html"/>
    <id>https://yjyrichard.github.io/posts/e7eedc60.html</id>
    <published>2025-08-29T14:51:24.979Z</published>
    <updated>2025-08-29T14:53:21.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="21岁生日，我送给自己一份《西游记》里的“成人礼”"><a href="#21岁生日，我送给自己一份《西游记》里的“成人礼”" class="headerlink" title="21岁生日，我送给自己一份《西游记》里的“成人礼”"></a><strong>21岁生日，我送给自己一份《西游记》里的“成人礼”</strong></h3><p>大家好呀😄，</p><p>今天是我21岁的生日，一个标志着我即将迈入大三的特殊日子。过去一个多月，我没有去旅行，也没有沉迷于游戏，而是做了一件有点“复古”的事——我重新“学习”了一遍《西游记》。</p><p>不是看电视剧（小时候看的太多了嘿嘿），而是啃下了一份几十万字的深度解读。坦白说，这个过程颠覆了我过去二十年对这个故事的所有认知。它不再是那个简单的“打怪升级”神话，而是一部写给成年人、关于选择、权力和生存法则的“秘密之书”。</p><p>今天，我想把这份学到的智慧，当作送给我自己的生日礼物，也分享给正在看这篇文章的你。</p><h4 id="1-为什么要“成正果”？因为单打独斗，守不住自己的“花果山”"><a href="#1-为什么要“成正果”？因为单打独斗，守不住自己的“花果山”" class="headerlink" title="1. 为什么要“成正果”？因为单打独斗，守不住自己的“花果山”"></a><strong>1. 为什么要“成正果”？因为单打独斗，守不住自己的“花果山”</strong></h4><p>小时候，我们都崇拜孙悟空，觉得他大闹天宫，无法无天，简直帅爆啦（我是这么想的哈哈）。但我们忽略了结局——他被压在五指山下整整五百年。</p><p>我学到的第一课就是：<strong>没有体系的保护，你的所有成就都可能在旦夕之间化为乌有。</strong></p><p>就像那篇文稿里说的，花果山福地，水帘洞洞天，为什么孙悟空能住？因为剧本需要他。当他任务完成，如果不“听话”，不被纳入“正果”体系，这块风水宝地随时可以换下一个主人。</p><p>这让我想到了现实。我们努力学习，拼命实习，渴望拥有属于自己的“花果山”——一份好工作，一个安稳的家。但如果没有一个强大、稳定的平台（也就是所谓的“正果体系”）作为依靠，个人的奋斗成果在时代的浪潮面前，其实非常脆弱。</p><p>所以，为什么要努力考进好公司，进入好平台？因为我们需要一个能抵御风险的“屋檐”，而不是在旷野里独自面对风雨。</p><h4 id="2-方向比努力重要：你是想进“雷部”，还是“雨部”？"><a href="#2-方向比努力重要：你是想进“雷部”，还是“雨部”？" class="headerlink" title="2. 方向比努力重要：你是想进“雷部”，还是“雨部”？"></a><strong>2. 方向比努力重要：你是想进“雷部”，还是“雨部”？</strong></h4><p>《西游记》里的天庭，像一个庞大的组织架构。其中，雷部是玉帝的嫡系，地位尊崇，前途无量；而雨部（龙王们）干着最累的活，却地位卑微，动辄得咎。</p><p>这给了我第二个巨大的启发：<strong>选择，远比努力更重要。你进入的“部门”，决定了你的天花板。</strong></p><p>作为即将面临职业选择的学生，我们常常被“只要努力就能成功”的口号激励。但现实是，在一个核心部门里，你的努力会被看见，你的成长是指数级的；而在一个边缘部门，你可能付出十倍的汗水，也只是原地踏步。</p><p>所以，在选择行业、公司和岗位时，一定要睁大眼睛。问问自己：这是组织的核心业务吗？它有足够的发展前景吗？我是在“雷部”蓄力，还是在“雨部”消耗？这个选择，可能会影响我们未来十年甚至更久的人生轨迹。</p><h4 id="3-你的“通关文牒”：忠诚、嘴严和一颗越挫越勇的心"><a href="#3-你的“通关文牒”：忠诚、嘴严和一颗越挫越勇的心" class="headerlink" title="3. 你的“通关文牒”：忠诚、嘴严和一颗越挫越勇的心"></a><strong>3. 你的“通关文牒”：忠诚、嘴严和一颗越挫越勇的心</strong></h4><p>选对了方向，如何才能走得更远？《西游记》给了我三个关键词。</p><p><strong>第一是“忠诚”。</strong> 文稿里说，“跟了谁，这辈子就是谁”。这听起来有点江湖气，但本质是说，在一个组织里，立场坚定、不当墙头草，是建立信任的基石。孙悟空后期对佛祖的效忠，甚至不惜得罪观音菩萨，正是他彻底融入体系的投名状。</p><p><strong>第二是“嘴严”。</strong> 这点让我印象极其深刻。无论是金角银角，还是灵感大王，那些能被大佬委以重任的“棋子”，都有一个共同点：守口如瓶。文稿里那句“事以密成，言以泄败”，简直是职场天条。在一个信息爆炸的时代，能管住自己嘴巴的人，反而更容易获得核心圈层的信任。</p><p><strong>第三是“逆境力”。</strong> 孙悟空是一块“庚金”，必须经过“丁火”（太上老君的八卦炉）的千锤百炼，才能成器。我们的人生也是如此，那些让你痛苦的挫折、让你无助的困境，恰恰是锻造你、让你变得更强大的“炉火”。只有在逆境中不断反思、找办法，才能真正成长。</p><h4 id="4-先取经，后成佛：别在起点谈“四大皆空”"><a href="#4-先取经，后成佛：别在起点谈“四大皆空”" class="headerlink" title="4. 先取经，后成佛：别在起点谈“四大皆空”"></a><strong>4. 先取经，后成佛：别在起点谈“四大皆空”</strong></h4><p>这是我学到最高级的一点智慧。</p><p>《西游记》告诉我们，所谓的“功成圆满”、“看破红尘”，不是想出来的，而是“干”出来的。孙悟空是在走完了十万八千里，立下了赫赫战功之后，头上的紧箍咒才自然消失，心里的狂躁才自然平息。</p><p>在我们这个年纪，很容易陷入一种迷茫：思考人生的意义，却迟迟不肯行动。我们总想等自己“想明白了”、“准备好了”再出发。</p><p>但《西游记》的逻辑恰恰相反：<strong>你得先上路，先去“取经”，在解决一个又一个具体问题的过程中，你才能最终“成佛”。</strong> 拥有之后，再谈境界；成功之后，再谈超脱。什么都没有经历过，就说一切都没意思，那只是弱者无能的托词。</p><hr><p>写下这些文字时，窗外的天已经亮了。这个21岁的生日，没有蛋糕，没有派对，却让我感到前所未有的充实。</p><p>《西游记》，这份我送给自己的成人礼，它教会我：<strong>人生就是一场向西的远行，我们要心怀希望，日拱一卒，像玄奘大师一样，活一天，就努力一天。</strong></p><p>前路漫漫，道阻且长，但我们，已经在路上了。</p><p>与各位共勉。</p>]]></content>
    
    
    <summary type="html">西游记</summary>
    
    
    
    <category term="其他" scheme="https://yjyrichard.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="https://yjyrichard.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第十二讲</title>
    <link href="https://yjyrichard.github.io/posts/7cb65bfe.html"/>
    <id>https://yjyrichard.github.io/posts/7cb65bfe.html</id>
    <published>2025-08-25T11:59:30.173Z</published>
    <updated>2025-08-25T12:06:14.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第十二讲"><a href="#介词第十二讲" class="headerlink" title="介词第十二讲"></a>介词第十二讲</h1><h3 id="介词辨析第二讲：方式、时间、地点与逻辑关系"><a href="#介词辨析第二讲：方式、时间、地点与逻辑关系" class="headerlink" title="介词辨析第二讲：方式、时间、地点与逻辑关系"></a><strong>介词辨析第二讲：方式、时间、地点与逻辑关系</strong></h3><p>大家好！</p><p>今天我们将深入探讨几组非常重要且容易混淆的介词。它们涉及做事的方式、时间的界限、地点的内外以及逻辑上的包含与排除。掌握它们，你的英语表达会迈上一个新台阶！</p><hr><h3 id="第一部分：表示“方式”的介词-With-By-In"><a href="#第一部分：表示“方式”的介词-With-By-In" class="headerlink" title="第一部分：表示“方式”的介词 (With, By, In)"></a><strong>第一部分：表示“方式”的介词 (With, By, In)</strong></h3><p>这三个介词都可翻译为“用”，但侧重点完全不同。</p><h4 id="1-With-用…工具"><a href="#1-With-用…工具" class="headerlink" title="1. With (用…工具)"></a><strong>1. With (用…工具)</strong></h4><ul><li><strong>核心含义</strong>：强调使用<strong>具体的、有形的工具、仪器或身体部位</strong>来完成一个动作。</li><li><strong>例句解析</strong>：<ul><li><code>I often do my homework **with a pen**.</code><ul><li>我经常<strong>用钢笔</strong>做作业。（“钢笔”是一个你能握在手里的具体工具。）</li></ul></li><li><code>He cut the apple **with a knife**.</code><ul><li>他<strong>用刀</strong>切开了苹果。（“刀”是具体的工具。）</li></ul></li><li><code>I saw it **with my own eyes**.</code><ul><li>我<strong>用我自己的眼睛</strong>看到了。（“眼睛”是具体的身体部位。）</li></ul></li></ul></li></ul><h4 id="2-By-用…方式-手段"><a href="#2-By-用…方式-手段" class="headerlink" title="2. By (用…方式/手段)"></a><strong>2. By (用…方式/手段)</strong></h4><ul><li><strong>核心含义</strong>：强调通过<strong>抽象的方式、手段或方法</strong>来达到一个目的。</li><li><strong>例句解析</strong>：<ul><li><code>I learn English well **by working hard**.</code><ul><li>我<strong>通过努力学习</strong>的方式学好英语。（“努力学习”是一个抽象的方法，而不是具体工具。）</li></ul></li><li><code>She travels to work **by car**.</code><ul><li>她<strong>乘汽车</strong>去上班。（这里指“驾车”这种交通方式，而不是特指某辆车这个工具。）</li></ul></li><li><code>You can pay **by credit card**.</code><ul><li>你可以<strong>用信用卡</strong>支付。（“信用卡支付”是一种支付手段。）</li></ul></li></ul></li></ul><h4 id="3-In-用…语言-材料"><a href="#3-In-用…语言-材料" class="headerlink" title="3. In (用…语言/材料)"></a><strong>3. In (用…语言/材料)</strong></h4><ul><li><strong>核心含义</strong>：强调使用某种<strong>语言、材料、媒介或方式</strong>来表达或呈现。</li><li><strong>例句解析</strong>：<ul><li><code>I can introduce myself **in English**.</code><ul><li>我能<strong>用英语</strong>做自我介绍。（“英语”是一种语言。）</li></ul></li><li><code>Please write your name **in ink**.</code><ul><li>请<strong>用墨水</strong>写下你的名字。（“墨水”是一种书写材料。）</li></ul></li><li><code>He paid for the book **in cash**.</code><ul><li>他<strong>用现金</strong>付了书款。（“现金”是一种支付媒介。）</li></ul></li></ul></li></ul><hr><h3 id="第二部分：表示“时间”的介词"><a href="#第二部分：表示“时间”的介词" class="headerlink" title="第二部分：表示“时间”的介词"></a><strong>第二部分：表示“时间”的介词</strong></h3><h4 id="1-For-vs-Since-持续时间-vs-起点"><a href="#1-For-vs-Since-持续时间-vs-起点" class="headerlink" title="1. For vs. Since (持续时间 vs. 起点)"></a><strong>1. For vs. Since (持续时间 vs. 起点)</strong></h4><ul><li><strong>For (持续了多久)</strong>：后接<strong>一段时间</strong>，回答 <code>how long</code> 的问题，表示动作或状态持续的总时长。<ul><li><code>She has worked here **for ten years**.</code><ul><li>她在这里已经工作<strong>十年了</strong>。（强调总时长是十年。）</li></ul></li></ul></li><li><strong>Since (自从何时)</strong>：后接<strong>一个时间点</strong>，回答 <code>since when</code> 的问题，表示动作或状态从过去某个点开始，一直持续到现在。<ul><li><code>She has lived in Beidaihe **since 1995**.</code><ul><li><strong>自从1995年</strong>，她就一直住在北戴河。（强调起点是1995年。）</li></ul></li></ul></li></ul><h4 id="2-By-vs-Before-vs-Until-截止日期-vs-之前-vs-持续到"><a href="#2-By-vs-Before-vs-Until-截止日期-vs-之前-vs-持续到" class="headerlink" title="2. By vs. Before vs. Until (截止日期 vs. 之前 vs. 持续到)"></a><strong>2. By vs. Before vs. Until (截止日期 vs. 之前 vs. 持续到)</strong></h4><ul><li><strong>Before (在…之前)</strong>：表示某个动作必须发生在<strong>某个时间点之前</strong>。<ul><li><code>We must leave here **before 9:00**.</code><ul><li>我们必须在<strong>九点前</strong>离开这里。（离开这个动作发生在九点这个时刻到来之前。）</li></ul></li></ul></li><li><strong>By (到…为止/不晚于)</strong>：强调某个动作完成的<strong>最终期限 (deadline)</strong>。<ul><li><code>You need to finish your homework **by tomorrow**.</code><ul><li>你必须<strong>在明天之前</strong>完成作业。（明天是最后期限。）</li></ul></li></ul></li><li><strong>Until/Till (直到…为止)</strong>：强调一个<strong>持续性的动作或状态</strong>一直延续到某个时间点才结束。常与持续性动词连用，或用于 <code>not...until</code> (直到…才…) 结构。<ul><li><code>I will be right here waiting for you **until you come back**.</code><ul><li>我会一直在这里等你，<strong>直到你回来为止</strong>。（“等待”这个动作会一直持续。）</li></ul></li><li><code>He didn&#39;t do it **until his mum left**.</code><ul><li>他<strong>直到他妈妈离开后才</strong>做这件事。（“不做”的状态一直持续到妈妈离开。）</li></ul></li></ul></li></ul><hr><h3 id="第三部分：表示“排除”与“包含”的介词-Except-Besides-But"><a href="#第三部分：表示“排除”与“包含”的介词-Except-Besides-But" class="headerlink" title="第三部分：表示“排除”与“包含”的介词 (Except, Besides, But)"></a><strong>第三部分：表示“排除”与“包含”的介词 (Except, Besides, But)</strong></h3><p>这三个词都可翻译为“除了”，但含义截然相反或用法不同。</p><ul><li><strong>Except (排除掉)</strong>：表示“除了…之外（不包括在内）”，是从整体中<strong>减去</strong>一部分。<ul><li><code>We all like dogs **except you**.</code><ul><li><strong>除了你</strong>，我们都喜欢狗。（把“你”排除在外，你不喜欢狗。）</li></ul></li></ul></li><li><strong>Besides (还包括)</strong>：表示“除了…之外（还包括在内）”，是在一部分的基础上<strong>加上</strong>另一部分。<ul><li><code>**Besides me**, they all like dogs.</code><ul><li><strong>除了我之外</strong>，他们也都喜欢狗。（意思是他们喜欢狗，我也喜欢狗，大家都在同一边。）</li></ul></li></ul></li><li><strong>But (除了)</strong>：意思接近 <code>except</code>，也表示排除，但常用于否定词（<code>nobody</code>, <code>none</code>）或 <code>all</code>, <code>any</code> 之后。<ul><li><code>She likes **nobody but you**.</code><ul><li>她谁都不喜欢，<strong>只喜欢你</strong>。（除了你之外，没有别人了。）</li></ul></li></ul></li></ul><hr><h3 id="第四部分：表示“地点”的介词-In-front-of-vs-In-the-front-of"><a href="#第四部分：表示“地点”的介词-In-front-of-vs-In-the-front-of" class="headerlink" title="第四部分：表示“地点”的介词 (In front of vs. In the front of)"></a><strong>第四部分：表示“地点”的介词 (In front of vs. In the front of)</strong></h3><ul><li><strong>In front of (在…外部的前面)</strong>：指一个物体在另一个物体<strong>范围之外</strong>的前方。两者是分离的。<ul><li><code>She is walking **in front of the bus**.</code><ul><li>她在公交车<strong>前面</strong>走。（她在车外，车的前方。）</li></ul></li></ul></li><li><strong>In the front of (在…内部的前部)</strong>：指在某个空间或物体<strong>内部范围</strong>的前半部分。<ul><li><code>Mary sits **in the front of the classroom**.</code><ul><li>玛丽坐在教室的<strong>前排</strong>。（她在教室这个空间的内部。）</li></ul></li></ul></li></ul><hr><h3 id="专项练习题"><a href="#专项练习题" class="headerlink" title="专项练习题"></a><strong>专项练习题</strong></h3><p><strong>请从 A, B, C, D 四个选项中选择最合适的一个填入空白处。</strong></p><ol><li><p>Please sign the document <strong>__</strong> a blue pen.<br>A. by<br>B. in<br>C. with<br>D. for</p></li><li><p><strong>__</strong> English, what other languages can you speak?<br>A. Except<br>B. Besides<br>C. But<br>D. Beside</p></li><li><p>I have been waiting for the bus here <strong>__</strong> more than half an hour.<br>A. since<br>B. for<br>C. by<br>D. until</p></li><li><p>The teacher asked us to hand in the project <strong>__</strong> next Monday.<br>A. until<br>B. since<br>C. by<br>D. before</p></li><li><p>A beautiful garden is located <strong>__</strong> the museum.<br>A. in the front of<br>B. in front of<br>C. except<br>D. besides</p></li><li><p>He didn’t go to bed <strong>__</strong> he finished all his tasks.<br>A. by<br>B. until<br>C. for<br>D. since</p></li><li><p>He has changed a lot <strong>__</strong> he graduated from college.<br>A. for<br>B. since<br>C. until<br>D. by</p></li><li><p>Everyone passed the test <strong>__</strong> Tom; he will have to take it again.<br>A. besides<br>B. but<br>C. except<br>D. with</p></li><li><p>We can solve this problem <strong>__</strong> communicating with each other.<br>A. with<br>B. in<br>C. by<br>D. for</p></li><li><p>The driver always sits <strong>__</strong> the car.<br>A. in front of<br>B. in the front of<br>C. beside<br>D. except</p></li></ol><hr><h3 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a><strong>答案与解析</strong></h3><ol><li><strong>C. with</strong><ul><li><strong>解析</strong>：“a blue pen”（一支蓝色的笔）是具体的书写工具，所以用 <code>with</code>。</li></ul></li><li><strong>B. Besides</strong><ul><li><strong>解析</strong>：句意是“除了英语之外，你还会说什么别的语言？”，表示在英语的基础上“还包括”其他语言，所以用 <code>Besides</code>。</li></ul></li><li><strong>B. for</strong><ul><li><strong>解析</strong>：“more than half an hour”（半个多小时）是一段时间，表示等待这个动作持续的时长，所以用 <code>for</code>。</li></ul></li><li><strong>C. by</strong><ul><li><strong>解析</strong>：“next Monday”（下周一）是上交项目的最终期限 (deadline)，所以用 <code>by</code>。</li></ul></li><li><strong>B. in front of</strong><ul><li><strong>解析</strong>：花园和博物馆是两个独立的物体，花园位于博物馆的“外部前方”，所以用 <code>in front of</code>。</li></ul></li><li><strong>B. until</strong><ul><li><strong>解析</strong>：这是一个 <code>not...until</code> 结构，表示“直到…才…”。“他直到完成所有任务才去睡觉”，强调“不去睡觉”这个状态一直持续到任务完成。</li></ul></li><li><strong>B. since</strong><ul><li><strong>解析</strong>：“he graduated from college”（他大学毕业）是一个过去的时间点，表示变化的起点，所以用 <code>since</code>。</li></ul></li><li><strong>C. except</strong><ul><li><strong>解析</strong>：句意是“除了汤姆，所有人都通过了考试”，表示将汤姆从通过考试的集体中“排除”出去，所以用 <code>except</code>。</li></ul></li><li><strong>C. by</strong><ul><li><strong>解析</strong>：“communicating with each other”（互相沟通）是一种解决问题的抽象方式或手段，所以用 <code>by</code>。</li></ul></li><li><strong>B. in the front of</strong><ul><li><strong>解析</strong>：司机坐在汽车的“内部前部”，是汽车这个空间的一部分，所以用 <code>in the front of</code>。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">英语介词第十二讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第十一讲</title>
    <link href="https://yjyrichard.github.io/posts/4ca0b726.html"/>
    <id>https://yjyrichard.github.io/posts/4ca0b726.html</id>
    <published>2025-08-25T11:59:30.076Z</published>
    <updated>2025-08-25T12:06:14.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第十一讲"><a href="#介词第十一讲" class="headerlink" title="介词第十一讲"></a>介词第十一讲</h1><h3 id="介词辨析第一讲：时间介词-In-On-At-amp-After"><a href="#介词辨析第一讲：时间介词-In-On-At-amp-After" class="headerlink" title="介词辨析第一讲：时间介词 In, On, At &amp; After"></a><strong>介词辨析第一讲：时间介词 In, On, At &amp; After</strong></h3><p>大家好！</p><p>在英语中，表示时间的介词 <code>in</code>, <code>on</code>, <code>at</code> 是最基础也最容易混淆的。它们就像一个金字塔，范围由大到小。今天我们还会辨析 <code>in</code> 和 <code>after</code> 在表示“之后”时的区别。让我们一起彻底搞懂它们！</p><hr><h3 id="第一部分：时间介词金字塔-In-On-At"><a href="#第一部分：时间介词金字塔-In-On-At" class="headerlink" title="第一部分：时间介词金字塔 In, On, At"></a><strong>第一部分：时间介词金字塔 In, On, At</strong></h3><p>我们可以把这三个词想象成一个从大到小的范围：</p><ul><li><strong>In (在…里)</strong>：用于最长、最模糊的时间段。</li><li><strong>On (在…上)</strong>：用于具体到“天”。</li><li><strong>At (在…点)</strong>：用于最短、最精确的时间点。</li></ul><h4 id="1-IN-用于大于一天的时间"><a href="#1-IN-用于大于一天的时间" class="headerlink" title="1. IN (用于大于一天的时间)"></a><strong>1. IN (用于大于一天的时间)</strong></h4><ul><li><strong>核心规则</strong>：<code>in</code> 用于表示一段较长的时间，通常是<strong>大于一天</strong>的单位。</li><li><p><strong>具体用法</strong>：</p><ul><li><strong>年份</strong>：<code>in 1990</code> (在1990年)</li><li><strong>月份</strong>：<code>in February</code> (在二月)</li><li><strong>季节</strong>：<code>in spring</code> (在春天), <code>in summer</code> (在夏天)</li><li><strong>泛指的上/下午/晚上</strong>：<code>in the morning</code> (在早晨), <code>in the afternoon</code> (在下午), <code>in the evening</code> (在晚上)</li><li><strong>世纪</strong>：<code>in the 21st century</code> (在21世纪)</li></ul></li><li><p><strong>例句</strong>：</p><ul><li><code>My grandfather was born **in 1950**.</code></li><li><code>We usually go skiing **in winter**.</code></li><li><code>I like to read books **in the evening**.</code></li></ul></li></ul><h4 id="2-ON-用于具体某一天"><a href="#2-ON-用于具体某一天" class="headerlink" title="2. ON (用于具体某一天)"></a><strong>2. ON (用于具体某一天)</strong></h4><ul><li><strong>核心规则</strong>：<code>on</code> 的范围缩小到<strong>具体某一天</strong>。</li><li><p><strong>具体用法</strong>：</p><ul><li><strong>星期几</strong>：<code>on Sunday</code> (在周日), <code>on Monday</code> (在周一)</li><li><strong>具体日期</strong>：<code>on March 1st</code> (在三月一号), <code>on my birthday</code> (在我生日那天)</li><li><strong>特指某一天的上/下午/晚上</strong>：<code>on a sunny morning</code> (在一个晴朗的早晨), <code>on a rainy night</code> (在一个雨夜)</li></ul></li><li><p><strong>⭐ 辨析小贴士</strong>：</p><ul><li><code>in the morning</code> (在早上) vs. <code>on Sunday morning</code> (在周日早上)</li><li><code>in the morning</code> 是泛指任何一天的早上，而一旦这个“早上”被具体到某一天（比如周日、一个晴天），就要用 <code>on</code>。</li></ul></li><li><p><strong>例句</strong>：</p><ul><li><code>The meeting is scheduled **on Friday**.</code></li><li><code>He received a special gift **on his birthday**.</code></li><li><code>**On that cold evening**, we sat by the fire.</code></li></ul></li></ul><h4 id="3-AT-用于精确的时间点"><a href="#3-AT-用于精确的时间点" class="headerlink" title="3. AT (用于精确的时间点)"></a><strong>3. AT (用于精确的时间点)</strong></h4><ul><li><strong>核心规则</strong>：<code>at</code> 的范围最小，用于表示一个<strong>精确的、短暂的时间点</strong>。</li><li><p><strong>具体用法</strong>：</p><ul><li><strong>具体时刻 (钟点)</strong>：<code>at 10 o&#39;clock</code>, <code>at 7:30 a.m.</code></li><li><strong>一些固定的时间点</strong>：<code>at noon</code> (在中午), <code>at night</code> (在夜间), <code>at midnight</code> (在午夜)</li><li><strong>黎明/黄昏</strong>：<code>at dawn</code> (在黎明), <code>at dusk</code> (在黄昏)</li><li><strong>某个特定时刻</strong>：<code>at that time</code> (在那时), <code>at the moment</code> (此刻)</li></ul></li><li><p><strong>⭐ 辨析小贴士</strong>：</p><ul><li>我们说 <code>in the morning/afternoon/evening</code>，但习惯上说 <code>at night</code>。可以记为“白天用in，夜晚用at”。</li></ul></li><li><p><strong>例句</strong>：</p><ul><li><code>The train arrives **at 3 p.m.**</code></li><li><code>I usually feel tired **at noon**.</code></li><li><code>The stars are beautiful **at night**.</code></li></ul></li></ul><hr><h3 id="第二部分：“之后”的两种表达-In-vs-After"><a href="#第二部分：“之后”的两种表达-In-vs-After" class="headerlink" title="第二部分：“之后”的两种表达 In vs. After"></a><strong>第二部分：“之后”的两种表达 In vs. After</strong></h3><p>这两个词都表示“之后”，但用法和时态语境完全不同。</p><h4 id="1-In-一段时间-用于将来"><a href="#1-In-一段时间-用于将来" class="headerlink" title="1. In + 一段时间 (用于将来)"></a><strong>1. In + 一段时间 (用于将来)</strong></h4><ul><li><strong>核心规则</strong>：<code>in</code> 加一段时间，表示<strong>从现在算起，将来的一段时间之后</strong>。通常与<strong>将来时态</strong>连用。</li><li><strong>含义</strong>：“…之后”</li><li><strong>例句</strong>：<ul><li><code>I will be back **in two days**.</code> (我<strong>两天后</strong>回来。)<ul><li>(从现在开始算，两天之后)</li></ul></li><li><code>The bridge will be completed **in three years**.</code> (这座桥将在<strong>三年后</strong>建成。)<ul><li>(从现在开始算，三年之后)</li></ul></li></ul></li></ul><h4 id="2-After-用于过去或任何时刻之后"><a href="#2-After-用于过去或任何时刻之后" class="headerlink" title="2. After (用于过去或任何时刻之后)"></a><strong>2. After (用于过去或任何时刻之后)</strong></h4><p><code>after</code> 的用法更灵活，主要有两种情况：</p><ul><li><p><strong>用法一：<code>after</code> + 一段时间 (常用于过去)</strong></p><ul><li><strong>核心规则</strong>：表示<strong>从过去某个时间点算起，一段时间之后</strong>。通常与<strong>过去时态</strong>连用。</li><li><strong>例句</strong>：<ul><li><code>He left home in 2010. **After a few days**, his family started to worry.</code> (他2010年离家。<strong>几天之后</strong>，他的家人开始担心。)<ul><li>(从他离家那个过去的时刻算起)</li></ul></li></ul></li></ul></li><li><p><strong>用法二：<code>after</code> + 具体时间点</strong></p><ul><li><strong>核心规则</strong>：表示<strong>在某个具体时刻之后</strong>，可用于任何时态。</li><li><strong>例句</strong>：<ul><li><code>The class will end **after 10:00 a.m.**</code> (课程将在<strong>上午10点后</strong>结束。)</li><li><code>Let&#39;s meet **after lunch**.</code> (我们<strong>午饭后</strong>见。)</li></ul></li></ul></li></ul><hr><h3 id="专项练习题"><a href="#专项练习题" class="headerlink" title="专项练习题"></a><strong>专项练习题</strong></h3><p><strong>请从 A, B, C, D 四个选项中选择最合适的一个填入空白处。</strong></p><ol><li><p>My birthday is <strong>__</strong> October 25th.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>The movie starts <strong>__</strong> 8:00 p.m. sharp.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>She told me she would call me back <strong>__</strong> an hour.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>I usually do my homework <strong>__</strong> the afternoon.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>He left his hometown <strong>__</strong> a cold winter morning.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>She felt much better <strong>__</strong> a few days of rest.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>The first man walked on the moon <strong>__</strong> 1969.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>We always have a big family dinner <strong>__</strong> Christmas Day.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>Don’t worry, the bus will arrive <strong>__</strong> ten minutes.<br>A. in<br>B. on<br>C. at<br>D. after</p></li><li><p>I can’t talk right now, I have a meeting <strong>__</strong> noon.<br>A. in<br>B. on<br>C. at<br>D. after</p></li></ol><hr><h3 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a><strong>答案与解析</strong></h3><ol><li><strong>B. on</strong><ul><li><strong>解析</strong>：用于具体的日期 (October 25th)，用 <code>on</code>。</li></ul></li><li><strong>C. at</strong><ul><li><strong>解析</strong>：用于精确的钟点时刻 (8:00 p.m.)，用 <code>at</code>。</li></ul></li><li><strong>A. in</strong><ul><li><strong>解析</strong>：句中时态是将来时 (would call)，表示“一小时后”，用 <code>in</code> + 一段时间。</li></ul></li><li><strong>A. in</strong><ul><li><strong>解析</strong>：泛指“在下午”，是大于一天的时间单位的一部分，用 <code>in</code>。</li></ul></li><li><strong>B. on</strong><ul><li><strong>解析</strong>：“一个寒冷的冬日早晨”是特指某一天的早晨，所以用 <code>on</code>。</li></ul></li><li><strong>D. after</strong><ul><li><strong>解析</strong>：句中时态是过去时 (felt better)，表示“休息几天之后”，描述过去发生的事情，用 <code>after</code>。</li></ul></li><li><strong>A. in</strong><ul><li><strong>解析</strong>：用于年份 (1969)，用 <code>in</code>。</li></ul></li><li><strong>B. on</strong><ul><li><strong>解析</strong>：Christmas Day (圣诞节当天) 是一个具体的日子，用 <code>on</code>。</li></ul></li><li><strong>A. in</strong><ul><li><strong>解析</strong>：句中时态是将来时 (will arrive)，表示“十分钟后”到达，用 <code>in</code>。</li></ul></li><li><strong>C. at</strong><ul><li><strong>解析</strong>：<code>noon</code> (中午) 是一个固定的精确时间点，用 <code>at</code>。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">英语介词第十一讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第十讲</title>
    <link href="https://yjyrichard.github.io/posts/8ac408a.html"/>
    <id>https://yjyrichard.github.io/posts/8ac408a.html</id>
    <published>2025-08-25T11:59:05.926Z</published>
    <updated>2025-08-25T12:06:14.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第十讲"><a href="#介词第十讲" class="headerlink" title="介词第十讲"></a>介词第十讲</h1><h3 id="inside-outside-into-onto-within-without-toward-beside-except"><a href="#inside-outside-into-onto-within-without-toward-beside-except" class="headerlink" title="inside ,outside,into,onto,within,without,toward,beside,except"></a>inside ,outside,into,onto,within,without,toward,beside,except</h3><p>大家好！</p><p>在上一部分我们学习了表示时间、比较和转折的介词。今天，我们将继续深入，学习一组与<strong>空间位置、移动方向、范围界限</strong>和<strong>包含/排除</strong>关系密切相关的介词。掌握它们，你的英语表达将更加精准和生动！</p><hr><h3 id="第一部分：表示位置的“内外”对立"><a href="#第一部分：表示位置的“内外”对立" class="headerlink" title="第一部分：表示位置的“内外”对立"></a><strong>第一部分：表示位置的“内外”对立</strong></h3><h4 id="1-inside-在…内部-vs-outside-在…外部"><a href="#1-inside-在…内部-vs-outside-在…外部" class="headerlink" title="1. inside (在…内部) vs. outside (在…外部)"></a><strong>1. inside (在…内部) vs. outside (在…外部)</strong></h4><p>这是一对非常直观的反义词，用于描述某个物体相对于一个封闭空间或边界的位置。</p><ul><li><p><strong>inside (在…里面)</strong></p><ul><li><strong>核心含义</strong>：强调位于一个空间或物体的<strong>内部</strong>。可以把它拆解为 <code>in + side</code> (在里面的一侧)。</li><li><strong>例句解析</strong>：<ul><li><code>Luckily, no one was **inside** the building when it collapsed.</code><ul><li>幸运的是，房子倒塌时<strong>里面</strong>没有人。（强调在建筑物这个封闭空间的内部）</li></ul></li><li><code>What&#39;s **inside** that box? It smells delicious.</code><ul><li>那个盒子<strong>里面</strong>是什么？闻起来好香。</li></ul></li><li><code>Please keep the dog **inside** the house.</code><ul><li>请把狗留在房子<strong>里</strong>。</li></ul></li></ul></li></ul></li><li><p><strong>outside (在…外面)</strong></p><ul><li><strong>核心含义</strong>：强调位于一个空间或物体的<strong>外部</strong>。可以拆解为 <code>out + side</code> (在外面的一侧)。</li><li><strong>例句解析</strong>：<ul><li><code>She sat for two hours on the floor **outside** her house.</code><ul><li>她在房子<strong>外面</strong>的地板上坐了两个小时。（强调在房子这个空间的外部）</li></ul></li><li><code>The children are playing **outside** in the garden.</code><ul><li>孩子们正在<strong>外面</strong>的花园里玩。</li></ul></li><li><code>It was a sunny day **outside**, but the room was dark.</code><ul><li><strong>外面</strong>天气晴朗，但房间里很暗。</li></ul></li></ul></li></ul></li></ul><hr><h3 id="第二部分：表示移动的“动态”过程"><a href="#第二部分：表示移动的“动态”过程" class="headerlink" title="第二部分：表示移动的“动态”过程"></a><strong>第二部分：表示移动的“动态”过程</strong></h3><h4 id="2-into-进入到…里-vs-onto-移动到…上"><a href="#2-into-进入到…里-vs-onto-移动到…上" class="headerlink" title="2. into (进入到…里) vs. onto (移动到…上)"></a><strong>2. into (进入到…里) vs. onto (移动到…上)</strong></h4><p>这对词都强调一个<strong>从A点到B点的动态过程</strong>，一个表示“进入”，一个表示“上到表面”。</p><ul><li><p><strong>into (进入到…里)</strong></p><ul><li><strong>核心含义</strong>：表示从<strong>外部移动到内部</strong>的动作。可以拆解为 <code>in + to</code> (到里面去)。</li><li><strong>例句解析</strong>：<ul><li><code>Let&#39;s get **into** the car; it&#39;s starting to rain.</code><ul><li>我们上车吧，开始下雨了。（从车外移动到车内的动作）</li></ul></li><li><code>He poured the milk **into** the glass.</code><ul><li>他把牛奶倒<strong>进</strong>了杯子里。（牛奶从外部进入杯子内部）</li></ul></li><li><code>The company is expanding **into** new markets.</code><ul><li>（抽象用法）这家公司正在扩展<strong>到</strong>新市场中。</li></ul></li></ul></li></ul></li><li><p><strong>onto (移动到…上)</strong></p><ul><li><strong>核心含义</strong>：表示移动到某个物体的<strong>表面之上</strong>。可以拆解为 <code>on + to</code> (到上面去)。</li><li><strong>例句解析</strong>：<ul><li><code>The cat jumped **onto** the roof.</code><ul><li>猫跳<strong>到</strong>了屋顶<strong>上</strong>。（从低处移动到屋顶这个表面）</li></ul></li><li><code>The sheep were loaded **onto** trucks.</code><ul><li>羊被装<strong>上</strong>了卡车。（从地面移动到卡车的载货平面上）</li></ul></li><li><code>How did we get **onto** this subject?</code><ul><li>（抽象用法）我们是怎么谈<strong>到</strong>这个话题<strong>上</strong>的？</li></ul></li></ul></li></ul></li></ul><hr><h3 id="第三部分：表示范围与伴随的“界限”"><a href="#第三部分：表示范围与伴随的“界限”" class="headerlink" title="第三部分：表示范围与伴随的“界限”"></a><strong>第三部分：表示范围与伴随的“界限”</strong></h3><h4 id="3-within-在…之内-vs-without-没有，不伴随"><a href="#3-within-在…之内-vs-without-没有，不伴随" class="headerlink" title="3. within (在…之内) vs. without (没有，不伴随)"></a><strong>3. within (在…之内) vs. without (没有，不伴随)</strong></h4><p>这对词也构成反义关系，一个表示在某个界限“之内”，一个表示“没有”或“在…之外”。</p><ul><li><p><strong>within (在…之内)</strong></p><ul><li><strong>核心含义</strong>：表示不超过某个<strong>范围、时间或距离的界限</strong>。</li><li><strong>用法精讲</strong>：<ul><li><strong>表示时间</strong>：<code>within two days</code> 意为“两天之内（不超过两天）”，可能是一天，也可能是几个小时。这与 <code>in two days</code>（两天后）不同。</li><li><strong>表示距离/范围</strong>：<code>within 2 miles</code> 意为“在2英里范围之内”。</li></ul></li><li><strong>例句解析</strong>：<ul><li><code>The tickets will reach you **within** two days.</code><ul><li>票将在<strong>两天之内</strong>送到您手中。（强调不会超过两天）</li></ul></li><li><code>We live **within** 2 miles of the coast.</code><ul><li>我们住在离海岸线<strong>不到2英里</strong>的地方。</li></ul></li><li><code>Please keep your spending **within** the budget.</code><ul><li>请将您的开支控制在预算<strong>范围之内</strong>。</li></ul></li></ul></li></ul></li><li><p><strong>without (没有，不伴随)</strong></p><ul><li><strong>核心含义</strong>：它是 <code>with</code> (伴随) 的反义词，表示“缺乏”或“没有”。</li><li><strong>例句解析</strong>：<ul><li><code>He went to take a walk **without** you.</code><ul><li>他<strong>没带你</strong>就去散步了。</li></ul></li><li><code>**Without** your help, none of us could have finished the project.</code><ul><li><strong>没有</strong>你的帮助，我们谁也无法完成这个项目。</li></ul></li><li><code>You can&#39;t make an omelet **without** breaking eggs.</code><ul><li>（谚语）不打碎鸡蛋就做不成煎蛋卷（有得必有失）。</li></ul></li></ul></li></ul></li></ul><hr><h3 id="第四部分：表示方向、位置与排除"><a href="#第四部分：表示方向、位置与排除" class="headerlink" title="第四部分：表示方向、位置与排除"></a><strong>第四部分：表示方向、位置与排除</strong></h3><h4 id="4-toward-towards-朝着，向着"><a href="#4-toward-towards-朝着，向着" class="headerlink" title="4. toward / towards (朝着，向着)"></a><strong>4. toward / towards (朝着，向着)</strong></h4><ul><li><strong>核心含义</strong>：表示移动的<strong>方向</strong>，或者一种<strong>态度</strong>的朝向。不一定到达终点，只强调方向。</li><li><strong>用法说明</strong>：<code>toward</code> 是美式英语，<code>towards</code> 是英式英语，意思完全相同。</li><li><strong>例句解析</strong>：<ul><li><code>She stood up and walked **toward** him.</code><ul><li>她站起来，<strong>朝</strong>他走去。（强调行走的方向）</li></ul></li><li><code>They&#39;ve always been very friendly **toward** me.</code><ul><li>（抽象用法）他们对我的态度一直很友好。（态度朝向我）</li></ul></li><li><code>He was running **towards** the finish line.</code><ul><li>他正<strong>朝着</strong>终点线奔跑。</li></ul></li></ul></li></ul><h4 id="5-except-除了…之外"><a href="#5-except-除了…之外" class="headerlink" title="5. except (除了…之外)"></a><strong>5. except (除了…之外)</strong></h4><ul><li><strong>核心含义</strong>：表示<strong>从整体中排除</strong>某一部分。</li><li><strong>例句解析</strong>：<ul><li><code>Everyone passed the exam **except** Tom.</code><ul><li><strong>除了</strong>汤姆，所有人都通过了考试。（把汤姆排除在外）</li></ul></li><li><code>The store is open every day **except** Sunday.</code><ul><li>这家商店<strong>除了</strong>周日，每天都营业。</li></ul></li></ul></li></ul><h4 id="6-beside-在…旁边"><a href="#6-beside-在…旁边" class="headerlink" title="6. beside (在…旁边)"></a><strong>6. beside (在…旁边)</strong></h4><ul><li><strong>核心含义</strong>：表示位置上的“紧挨着，在…旁边”，等同于 <code>next to</code>。</li><li><strong>易混淆词</strong>：注意不要和 <code>besides</code> (除了…还有…) 混淆。<code>beside</code> 是位置，<code>besides</code> 是添加。</li><li><strong>例句解析</strong>：<ul><li><code>He sat **beside** her on the sofa.</code><ul><li>他坐在她<strong>旁边</strong>的沙发上。</li></ul></li><li><code>There is a small table **beside** the bed.</code><ul><li>床<strong>旁边</strong>有一张小桌子。</li></ul></li></ul></li></ul><hr><h3 id="介词用法专项练习题"><a href="#介词用法专项练习题" class="headerlink" title="介词用法专项练习题"></a><strong>介词用法专项练习题</strong></h3><p><strong>请从 A, B, C, D 四个选项中选择最合适的一个填入空白处。</strong></p><ol><li><p>The kitten was scared and hid <strong>__</strong> the sofa.<br>A. onto<br>B. outside<br>C. inside<br>D. into</p></li><li><p>Could you please put these books <strong>__</strong> the top shelf?<br>A. onto<br>B. into<br>C. within<br>D. without</p></li><li><p>All the students attended the meeting <strong>__</strong> John, who was sick.<br>A. beside<br>B. except<br>C. without<br>D. toward</p></li><li><p>I promise I will finish the report <strong>__</strong> this Friday.<br>A. without<br>B. outside<br>C. within<br>D. toward</p></li><li><p>He walked straight <strong>__</strong> the door without looking back.<br>A. toward<br>B. beside<br>C. inside<br>D. onto</p></li><li><p>We can’t complete this puzzle <strong>__</strong> your help; you have the last piece!<br>A. except<br>B. within<br>C. without<br>D. beside</p></li><li><p>The children jumped <strong>__</strong> the swimming pool to cool off.<br>A. onto<br>B. into<br>C. outside<br>D. beside</p></li><li><p>Come and sit <strong>__</strong> me, there’s plenty of space here.<br>A. except<br>B. without<br>C. toward<br>D. beside</p></li><li><p>It’s dangerous to play <strong>__</strong> the construction site.<br>A. without<br>B. onto<br>C. inside<br>D. except</p></li><li><p>His attitude <strong>__</strong> his work has improved a lot recently.<br>A. onto<br>B. within<br>C. toward<br>D. beside</p></li></ol><hr><h3 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a><strong>答案与解析</strong></h3><ol><li><strong>C. inside</strong><ul><li><strong>解析</strong>：这里描述的是一个静态的位置，小猫藏在沙发“里面”。<code>into</code> 强调进入的动作，但这里更侧重藏在里面的状态。如果句子是 “The kitten ran and hid <strong>__</strong> the sofa”，那么<code>into</code> 也可以考虑，但<code>inside</code>更强调最终位置。</li></ul></li><li><strong>A. onto</strong><ul><li><strong>解析</strong>：把书“放到顶层的架子上”，这是一个从别处移动到架子“表面”的动作，所以用 <code>onto</code>。</li></ul></li><li><strong>B. except</strong><ul><li><strong>解析</strong>：句意是“除了生病的约翰，所有学生都参加了会议”，表示将约翰从全体中“排除”，所以用 <code>except</code>。</li></ul></li><li><strong>C. within</strong><ul><li><strong>解析</strong>：“在本周五之内”完成报告，表示一个时间期限，强调不晚于周五，用 <code>within</code>。</li></ul></li><li><strong>A. toward</strong><ul><li><strong>解析</strong>：“径直朝门口走去”，表示一个方向，所以用 <code>toward</code>。</li></ul></li><li><strong>C. without</strong><ul><li><strong>解析</strong>：“没有你的帮助”，我们无法完成拼图。<code>without</code> 表示“缺乏，没有”。</li></ul></li><li><strong>B. into</strong><ul><li><strong>解析</strong>：“跳进游泳池”，表示一个从池外移动到池内的动作，所以用 <code>into</code>。</li></ul></li><li><strong>D. beside</strong><ul><li><strong>解析</strong>：“过来坐在我旁边”，表示位置上的“紧挨着”，所以用 <code>beside</code>。</li></ul></li><li><strong>C. inside</strong><ul><li><strong>解析</strong>：“在建筑工地内部玩耍是危险的”，<code>inside</code> 表示在某个区域或空间内部。</li></ul></li><li><strong>C. toward</strong><ul><li><strong>解析</strong>：“他对工作的态度”，<code>toward</code> 在这里用于抽象含义，表示态度所朝向的对象。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">英语介词第十讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第五讲</title>
    <link href="https://yjyrichard.github.io/posts/b7365014.html"/>
    <id>https://yjyrichard.github.io/posts/b7365014.html</id>
    <published>2025-08-25T11:59:05.905Z</published>
    <updated>2025-08-25T12:06:14.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第五讲"><a href="#介词第五讲" class="headerlink" title="介词第五讲"></a>介词第五讲</h1><h3 id="by-near-about-around-against-opposite"><a href="#by-near-about-around-against-opposite" class="headerlink" title="by near about around against opposite"></a>by near about around against opposite</h3><h3 id="1-by-核心思想：在旁边-挨着-Beside-Next-to"><a href="#1-by-核心思想：在旁边-挨着-Beside-Next-to" class="headerlink" title="1. by - 核心思想：在旁边 / 挨着 (Beside / Next to)"></a><strong>1. by - 核心思想：在旁边 / 挨着 (Beside / Next to)</strong></h3><p>想象一下，任何事物，无论是人、时间还是方法，都“紧挨着”另一个事物，这就是 <code>by</code> 的感觉。</p><p><strong>用法一：空间上的“旁边”</strong><br>这是最直观的意思，指位置上紧挨着。</p><ul><li><code>Please come and sit by me.</code> (请过来坐我旁边。)</li><li><code>There is a beautiful house by the sea.</code> (海边有一座漂亮的房子。)</li><li><code>We walked past by the library on our way home.</code> (我们回家路上经过了图书馆旁边。)</li><li><code>The children stood side by side to take a photo.</code> (孩子们肩并肩站着拍照。)</li></ul><p><strong>用法二：时间上的“旁边”（不晚于… / 截止到…）</strong><br>表示一个动作完成的最后期限，时间点紧挨着，但不能超过。</p><ul><li><code>You must finish your homework by Friday.</code> (你必须在周五前完成作业。)</li><li><code>Please return the book to me by tomorrow.</code> (请在明天前把书还给我。)</li><li><code>By the end of the year, we will have learned 1000 new words.</code> (到今年年底，我们将学完1000个新单词。)</li><li><code>Time goes by so quickly.</code> (时间过得真快啊。)</li></ul><p><strong>用法三：方式上的“旁边”（依靠 / 通过）</strong><br>表示做某事所依靠或使用的方法、工具，这个“方法”就像伴随在动作旁边。</p><ul><li><code>I go to school by bus every day.</code> (我每天乘公交车上学。)</li><li><code>You can contact me by email or by phone.</code> (你可以通过邮件或电话联系我。)</li><li><code>He paid for the new coat by credit card.</code> (他用信用卡支付了这件新外套。)</li><li><code>I learned the poem by heart.</code> (我靠用心记下了这首诗。)</li><li><code>I met her completely by chance.</code> (我完全是偶然遇见她的。)</li></ul><p><strong>用法四：语法上的“旁边”（被动语态的动作发出者）</strong><br>在被动句中，动作是谁做的，就用 <code>by</code> 把它放在动作旁边。</p><ul><li><code>This cake was made by my mother.</code> (这个蛋糕是我妈妈做的。)</li><li><code>The window was broken by the naughty boy.</code> (窗户是被那个淘气的男孩打碎的。)</li><li><code>The story was written by a famous writer.</code> (这个故事是一位著名作家写的。)</li></ul><hr><h3 id="2-near-核心思想：在…附近-In-the-vicinity-of-Close-to"><a href="#2-near-核心思想：在…附近-In-the-vicinity-of-Close-to" class="headerlink" title="2. near - 核心思想：在…附近 (In the vicinity of / Close to)"></a><strong>2. near - 核心思想：在…附近 (In the vicinity of / Close to)</strong></h3><p><code>near</code> 表示距离上的靠近，但中间有一定空间，不像 <code>by</code> 那样紧挨着。</p><p><strong>用法一：空间上的“附近”</strong><br>指具体的地理位置很近。</p><ul><li><code>Is there a supermarket near our school?</code> (我们学校附近有超市吗？)</li><li><code>Don&#39;t stand near the fire; it&#39;s dangerous.</code> (别站在火的附近，很危险。)</li><li><code>My best friend lives near my home, so we often play together.</code> (我最好的朋友住在我家附近，所以我们经常一起玩。)</li></ul><p><strong>用法二：抽象概念的“接近”</strong><br>指时间、状态或情感上的靠近。</p><ul><li><code>The summer holiday is drawing near.</code> (暑假快要到了。)</li><li><code>She was near tears when she heard the sad news.</code> (当她听到那个悲伤的消息时，她都快哭了。)</li><li><code>It&#39;s near midnight, you should go to bed.</code> (快到午夜了，你应该去睡觉了。)</li></ul><p><strong>小贴士：<code>near</code> (附近) vs <code>nearly</code> (几乎)</strong></p><ul><li><code>The hotel is **near** the station.</code> (酒店在车站附近。) -&gt; 表位置</li><li><code>The bottle is **nearly** empty.</code> (瓶子差不多空了。) -&gt; 表程度</li></ul><hr><h3 id="3-about-around-核心思想：围绕着-四周"><a href="#3-about-around-核心思想：围绕着-四周" class="headerlink" title="3. about / around - 核心思想：围绕着 / 四周"></a><strong>3. about / around - 核心思想：围绕着 / 四周</strong></h3><p>这两个词都有一种“围绕一个中心”的感觉。<code>about</code> 更偏向抽象的话题或大概的范围，而 <code>around</code> 更偏向具体的物理空间。</p><h4 id="about-更偏向抽象的“围绕”"><a href="#about-更偏向抽象的“围绕”" class="headerlink" title="about (更偏向抽象的“围绕”)"></a><strong>about (更偏向抽象的“围绕”)</strong></h4><p><strong>用法一：表示“关于” (围绕一个话题)</strong></p><ul><li><code>This is a story about a brave knight.</code> (这是一个关于勇敢骑士的故事。)</li><li><code>What are you talking about?</code> (你们在聊什么呢?)</li><li><code>I&#39;m so worried about the final exam.</code> (我非常担心期末考试。)</li><li><code>Tell me all about your trip to Beijing.</code> (跟我讲讲你北京之行的所有事吧。)</li></ul><p><strong>用法二：表示“大约” (围绕一个数字或时间)</strong></p><ul><li><code>There are about 50 students in our class.</code> (我们班大约有50名学生。)</li><li><code>I waited for you for about half an hour.</code> (我等了你大约半个小时。)</li><li><code>Hurry up! The train is about to leave.</code> (快点！火车马上就要开了。)</li></ul><h4 id="around-更偏向具体的“围绕”"><a href="#around-更偏向具体的“围绕”" class="headerlink" title="around (更偏向具体的“围绕”)"></a><strong>around (更偏向具体的“围绕”)</strong></h4><p><strong>用法一：表示“环绕 / 在…四周”</strong></p><ul><li><code>We all sat around the table for dinner.</code> (我们都围坐在桌边吃晚饭。)</li><li><code>He plans to travel around the world next year.</code> (他计划明年环游世界。)</li><li><code>The earth moves around the sun.</code> (地球围绕太阳转。)</li><li><code>There are many trees around the lake.</code> (湖的四周有很多树。)</li></ul><p><strong>小贴士：何时可以通用？</strong><br>当表示“到处”或“四处”时，两者有时可以互换。</p><ul><li><code>He looked **around/about** the room, but couldn&#39;t find his keys.</code> (他环顾了一下房间，但没找到钥匙。)</li></ul><hr><h3 id="4-against-opposite-核心思想：对抗-对面"><a href="#4-against-opposite-核心思想：对抗-对面" class="headerlink" title="4. against / opposite - 核心思想：对抗 / 对面"></a><strong>4. against / opposite - 核心思想：对抗 / 对面</strong></h3><p>这两个词都带有“对”的含义，但感觉完全不同。</p><h4 id="against-核心：对抗-顶着"><a href="#against-核心：对抗-顶着" class="headerlink" title="against (核心：对抗 / 顶着)"></a><strong>against (核心：对抗 / 顶着)</strong></h4><p><strong>用法一：表示“反对 / 对抗” (带有冲突感)</strong></p><ul><li><code>Many people are against the plan to build a new factory here.</code> (很多人反对在这里建新工厂的计划。)</li><li><code>It is against the school rules to use a mobile phone in class.</code> (在课堂上使用手机是违反校规的。)</li><li><code>Our team will play against the champion team tomorrow.</code> (我们队明天要和冠军队比赛。)</li></ul><p><strong>用法二：表示“倚靠 / 顶着” (身体靠在某物上)</strong></p><ul><li><code>He was leaning against the wall, waiting for his friend.</code> (他正倚着墙等他的朋友。)</li><li><code>Don&#39;t put your bike against the clean window!</code> (别把你的自行车靠在干净的窗户上！)</li></ul><h4 id="opposite-核心：在…对面-相反"><a href="#opposite-核心：在…对面-相反" class="headerlink" title="opposite (核心：在…对面 / 相反)"></a><strong>opposite (核心：在…对面 / 相反)</strong></h4><p><strong>用法一：表示“在…对面” (位置上的相对)</strong></p><ul><li><code>The post office is just opposite the bank.</code> (邮局就在银行的对面。)</li><li><code>In the meeting, my teacher sat opposite me.</code> (会议上，我的老师坐在我的对面。)</li><li><code>Our house is opposite a big park.</code> (我们家对面是一个大公园。)</li></ul><p><strong>用法二：表示“相反的” (方向或性质上的对立)</strong></p><ul><li><code>&quot;Up&quot; is the opposite of &quot;down&quot;.</code> (“上”是“下”的反义词。)</li><li><code>They ran in opposite directions.</code> (他们朝着相反的方向跑去。)</li></ul><p><strong>小贴士：如何区分？</strong></p><ul><li><code>against</code> 强调 <strong>冲突</strong> 或 <strong>压力</strong>。<code>fight against him</code> (和他对抗)。</li><li><code>opposite</code> 强调 <strong>位置</strong> 或 <strong>方向</strong>。<code>sit opposite him</code> (坐在他对面)。</li></ul><hr><p>希望这份更详细的讲义能让你彻底明白这些介词的用法！</p>]]></content>
    
    
    <summary type="html">英语介词第五讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第七讲</title>
    <link href="https://yjyrichard.github.io/posts/386c52.html"/>
    <id>https://yjyrichard.github.io/posts/386c52.html</id>
    <published>2025-08-25T11:59:05.870Z</published>
    <updated>2025-08-25T12:06:14.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第七讲"><a href="#介词第七讲" class="headerlink" title="介词第七讲"></a>介词第七讲</h1><h3 id="beyond-blow-before-behind-after"><a href="#beyond-blow-before-behind-after" class="headerlink" title="beyond blow before behind after"></a>beyond blow before behind after</h3><p>我们来系统地学习和梳理这五个以<code>be-</code>开头的介词：<code>beyond</code>, <code>below</code>, <code>before</code>, <code>behind</code>，以及与它们相关的<code>after</code>。</p><hr><h3 id="词义深度解析"><a href="#词义深度解析" class="headerlink" title="词义深度解析"></a>词义深度解析</h3><p>首先，我们抓住一个核心概念：<br><strong>be-</strong>: 这个前缀常常有“使…”或“处于…状态”的含义。当我们用这个思路去理解这组词时，会发现它们的逻辑非常清晰。</p><h4 id="1-beyond"><a href="#1-beyond" class="headerlink" title="1. beyond"></a>1. <strong>beyond</strong></h4><ul><li><strong>词源解析</strong>: <code>be</code> (处于) + <code>yond</code> (更远的那边)。字面意思就是“<strong>处于更远的那边</strong>”。</li><li><p><strong>核心含义</strong>: <strong>超越，超出（某个范围、限度、时间或地点）</strong>。这个词充满了“突破界限”的感觉。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示空间位置</strong>: 在…的那一边，远于</p><ul><li><em>The village is <strong>beyond</strong> the hills.</em><br>村庄在山的那一边。</li><li><em>Our house is just <strong>beyond</strong> the bridge.</em><br>我们的房子刚过桥就是。</li></ul></li><li><p><strong>表示时间</strong>: 晚于，迟于</p><ul><li><em>We can’t allow the work to continue <strong>beyond</strong> the end of the year.</em><br>我们不能允许这项工作延期到明年。</li><li><em>Few people live <strong>beyond</strong> the age of a hundred.</em><br>很少有人活过一百岁。</li></ul></li><li><p><strong>表示抽象范围（最常用）</strong>: 超出（能力、理解、控制、想象等）</p><ul><li><em>The situation was completely <strong>beyond</strong> her control.</em><br>局势完全超出了她的控制。</li><li><em>His car was damaged <strong>beyond</strong> repair.</em><br>他的车损坏严重，已经无法修复了。（超出了维修的范围）</li><li><em>What he did was <strong>beyond</strong> belief.</em><br>他所做的事简直令人难以置信。（超出了相信的范围）</li><li><em>Physics is completely <strong>beyond</strong> me.</em><br>物理这门学科完全超出了我的理解能力。</li><li><em>This task is <strong>beyond</strong> my capabilities.</em><br>这个任务超出了我的能力范围。</li></ul></li></ol></li></ul><hr><h4 id="2-below"><a href="#2-below" class="headerlink" title="2. below"></a>2. <strong>below</strong></h4><ul><li><strong>词源解析</strong>: <code>be</code> (处于) + <code>low</code> (低的)。字面意思就是“<strong>处于低的位置</strong>”。</li><li><p><strong>核心含义</strong>: <strong>在…下方，低于</strong>。它强调的是在一个垂直平面或等级上的相对位置较低，不一定是正下方（<code>under</code>更强调在正下方）。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示空间位置</strong>: 在…下方</p><ul><li><em>His name is <strong>below</strong> the title.</em><br>他的名字在标题下面。</li><li><em>From the top of the mountain, we could see the clouds <strong>below</strong> us.</em><br>从山顶上，我们可以看到脚下的云层。</li></ul></li><li><p><strong>表示等级、数量、标准</strong>: 低于</p><ul><li><em>The temperature remained <strong>below</strong> freezing all day.</em><br>气温一整天都保持在零度以下。</li><li><em>Her performance was <strong>below</strong> average.</em><br>她的表现低于平均水平。</li><li><em>Children <strong>below</strong> the age of five are not allowed.</em><br>五岁以下的儿童不得入内。</li></ul></li><li><p><strong>表示职位、地位</strong>: 在…之下，级别低于</p><ul><li><em>She has three people working <strong>below</strong> her.</em><br>她有三名下属。</li><li><em>In the army, a captain is <strong>below</strong> a major.</em><br>在军队中，上尉的军衔低于少校。</li></ul></li></ol></li></ul><hr><h4 id="3-before"><a href="#3-before" class="headerlink" title="3. before"></a>3. <strong>before</strong></h4><ul><li><strong>词源解析</strong>: <code>be</code> (处于) + <code>fore</code> (前面)。字面意思就是“<strong>处于前面的位置</strong>”。</li><li><p><strong>核心含义</strong>: <strong>在…前面</strong>。这个“前面”可以是时间上的、空间上的，也可以是顺序上的。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示时间</strong>: 在…之前</p><ul><li><em>Please wash your hands <strong>before</strong> meals.</em><br>请在饭前洗手。</li><li><em>I had never seen a panda <strong>before</strong> I went to China.</em><br>在我去中国之前，我从未见过熊猫。</li><li><em>She left the day <strong>before</strong> yesterday.</em><br>她前天离开的。</li></ul></li><li><p><strong>表示空间位置</strong>: 在…前面</p><ul><li><em>The bus stop is just <strong>before</strong> the school.</em><br>公交站就在学校前面一点。</li><li><em>He stood up <strong>before</strong> us and sang an English song.</em><br>他站在我们面前，唱了一首英文歌。</li></ul></li><li><p><strong>表示顺序</strong>: 在…之前</p><ul><li><em>The letter D comes <strong>before</strong> H in the alphabet.</em><br>在字母表中，字母D在H的前面。</li></ul></li><li><p><strong>常用短语</strong>:</p><ul><li><strong>before long</strong>: 不久之后</li><li><strong>before one’s eyes</strong>: 当着…的面，亲眼</li></ul></li></ol></li></ul><hr><h4 id="4-behind"><a href="#4-behind" class="headerlink" title="4. behind"></a>4. <strong>behind</strong></h4><ul><li><strong>词源解析</strong>: <code>be</code> (处于) + <code>hind</code> (后面，与<code>hide</code>-藏有关)。字面意思就是“<strong>处于后面的/隐藏的位置</strong>”。</li><li><p><strong>核心含义</strong>: <strong>在…后面</strong>。这既可以是具体的物理位置，也可以是抽象的落后或支持。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示空间位置</strong>: 在…后面</p><ul><li><em>The little boy is hiding <strong>behind</strong> the door.</em><br>那个小男孩正躲在门后。</li><li><em>Look <strong>behind</strong> you! There’s a beautiful rainbow.</em><br>看你身后！有一道美丽的彩虹。</li></ul></li><li><p><strong>表示时间</strong>: 晚于，落后于</p><ul><li><em>He is <strong>behind</strong> schedule with his project.</em><br>他的项目进度落后了。</li><li><em>My watch is five minutes <strong>behind</strong>.</em><br>我的手表慢了五分钟。</li></ul></li><li><p><strong>表示支持</strong>: 在背后支持</p><ul><li><em>Whatever you decide, we are all <strong>behind</strong> you.</em><br>无论你做什么决定，我们都支持你。</li><li><em>He is the man <strong>behind</strong> this successful project.</em><br>他是这个成功项目背后的关键人物。</li></ul></li><li><p><strong>表示原因</strong>: 是…背后的原因</p><ul><li><em>What is the real reason <strong>behind</strong> his decision?</em><br>他这个决定背后的真正原因是什么？</li></ul></li></ol></li></ul><hr><h4 id="5-after"><a href="#5-after" class="headerlink" title="5. after"></a>5. <strong>after</strong></h4><ul><li><strong>词源解析</strong>: <code>after</code>虽然不完全遵循<code>be-</code>结构，但它在时空关系上与<code>before</code>和<code>behind</code>形成对比，所以放在一起学习。它的词源意为“更后面”。</li><li><p><strong>核心含义</strong>: <strong>在…之后</strong>。主要用于时间，也可以表示跟随、追逐或模仿。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示时间</strong>: 在…之后</p><ul><li><em>Let’s go for a walk <strong>after</strong> dinner.</em><br>我们晚饭后去散步吧。</li><li><em>He arrived the day <strong>after</strong> tomorrow.</em><br>他后天到达。</li></ul></li><li><p><strong>表示顺序或位置</strong>: 在…后面</p><ul><li><em>Please shut the door <strong>after</strong> you.</em><br>进来后请随手关门。</li><li><em>In the list, my name comes <strong>after</strong> yours.</em><br>名单上我的名字在你后面。</li></ul></li><li><p><strong>表示追逐、跟随</strong>:</p><ul><li><em>The police are running <strong>after</strong> the thief.</em><br>警察正在追赶小偷。</li><li><em>The dog ran <strong>after</strong> the ball.</em><br>狗追着球跑。</li></ul></li><li><p><strong>表示模仿或以…命名</strong>:</p><ul><li><em>This is a painting <strong>after</strong> Van Gogh.</em><br>这是一幅模仿梵高风格的画。</li><li><em>She was named Grace <strong>after</strong> her grandmother.</em><br>她以她祖母的名字命名为格蕾丝。</li></ul></li></ol></li></ul><p>因为从字面上看，“look”（看）和“after”（在…之后）确实很难直接组合成“照顾”的意思。</p><p>要理解它，我们需要跳出字面意思，从一个更生动的画面去想象。我们可以从以下几个角度来“盘活”这个短语：</p><h3 id="角度一：用目光“追随”在后面-The-“Following-Gaze”-Analogy"><a href="#角度一：用目光“追随”在后面-The-“Following-Gaze”-Analogy" class="headerlink" title="角度一：用目光“追随”在后面 (The “Following Gaze” Analogy)"></a>角度一：用目光“追随”在后面 (The “Following Gaze” Analogy)</h3><p>这是最核心、最形象的理解方式。</p><p>想象一下，一个妈妈带着一个刚会走路的小孩在公园里玩。小孩在前面摇摇晃晃地跑，妈妈会怎么做？</p><ul><li>她不会只<strong>看一眼</strong> (<code>look at</code>) 孩子。</li><li>她会持续地、不间断地用目光<strong>跟在</strong>孩子的<strong>后面</strong> (<code>look after</code>)，确保他不会摔倒，不会跑到危险的地方去。</li></ul><p>在这个场景里，“look after”的画面感就出来了：<strong>你的目光始终追随着那个你需要负责的人或物，你是在用眼神“护送”着他/她/它。</strong> 这种持续关注、确保其安全的状态，不就是“照顾”的核心吗？</p><p>所以，<code>look after</code> ≠ 看 + 后面，而是 <strong>目光追随在后 → 持续关注 → 负责、照看、照顾</strong>。</p><hr><h3 id="角度二：与相关短语对比，凸显含义"><a href="#角度二：与相关短语对比，凸显含义" class="headerlink" title="角度二：与相关短语对比，凸显含义"></a>角度二：与相关短语对比，凸显含义</h3><p>对比一下其他由 <code>look</code> 组成的短语，你就能更清楚地看到 <code>look after</code> 的独特性：</p><ul><li><p><strong>look at</strong>: <strong>看</strong> (一个瞬间的、直接的动作)</p><ul><li><em>Look at the blackboard.</em> (看黑板)</li><li>这只是一个简单的“视线投向”的动作。</li></ul></li><li><p><strong>look for</strong>: <strong>寻找</strong> (带着目的去看，为了找到)</p><ul><li><em>I’m looking for my keys.</em> (我正在找我的钥匙)</li><li>这个动作有一个明确的目标：找到东西。</li></ul></li><li><p><strong>look after</strong>: <strong>照顾</strong> (持续的、负责任的关注)</p><ul><li><em>Please look after my dog while I’m away.</em> (我不在的时候，请帮我照顾我的狗)</li><li>这不是让你“看”狗一下，也不是让你“找”狗，而是让你对它负责，喂它、陪它，确保它一切都好。这是一种<strong>延续性的责任</strong>。</li></ul></li></ul><p>通过对比，你会发现 <code>after</code> 这个词给 <code>look</code> 增加了一种“<strong>延续性</strong>”和“<strong>跟随性</strong>”的意味，从而引申出了“照顾”的含义。</p><hr><h3 id="角度三：引申到“负责处理”"><a href="#角度三：引申到“负责处理”" class="headerlink" title="角度三：引申到“负责处理”"></a>角度三：引申到“负责处理”</h3><p>这个“照顾”的含义还可以进一步引申。除了照顾人或动物，你也可以“照顾”一件事情，意思就是“负责处理”。</p><ul><li><p><em>Don’t worry about the arrangements for the meeting. I’ll <strong>look after</strong> it.</em><br>别担心会议的安排，我来<strong>处理</strong>。<br>（这里的意思是：我会像照顾一个孩子一样，负责到底，确保这件事的方方面面都妥当。）</p></li><li><p><em>It’s important to <strong>look after</strong> your own health.</em><br>照顾好你自己的健康很重要。<br>（你需要持续关注你的身体状况，对它负责。）</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，下次你看到 <code>look after</code> 时，不要再把它拆成“看”和“后面”。</p><p><strong>请在脑海里浮现这个画面：一个负责任的人，他的目光始终温柔地、警觉地跟在他需要保护的人或物的身后，随时准备提供帮助。</strong></p><p>这个画面，就是 <code>look after</code> 的精髓——<strong>用持续的关注来履行一份责任</strong>，也就是“照顾”。</p><hr><h3 id="巩固练习-Consolidation-Exercises"><a href="#巩固练习-Consolidation-Exercises" class="headerlink" title="巩固练习 (Consolidation Exercises)"></a>巩固练习 (Consolidation Exercises)</h3><p>请用 <code>beyond</code>, <code>below</code>, <code>before</code>, <code>behind</code>, <code>after</code> 填空。</p><ol><li>The beauty of the sunset was <strong><strong>_</strong></strong> description.</li><li>Don’t forget to turn off the lights <strong><strong>_</strong></strong> you leave the room.</li><li>No matter what happens, I’ll always be right <strong><strong>_</strong></strong> you, supporting you.</li><li>The temperature in winter often drops <strong><strong>_</strong></strong> zero degrees Celsius here.</li><li>The cat jumped onto the table and started chasing the mouse <strong><strong>_</strong></strong> a few seconds.</li><li>The mystery of the universe is far <strong><strong>_</strong></strong> human understanding.</li><li>He knelt <strong><strong>_</strong></strong> the queen to receive his knighthood.</li><li>We are falling <strong><strong>_</strong></strong> schedule; we need to work faster.</li><li>A sergeant’s rank is <strong><strong>_</strong></strong> a lieutenant’s in the army.</li><li>He takes <strong><strong>_</strong></strong> his father; they both have the same smile.</li></ol><hr><h3 id="答案与解析-Answers-and-Explanations"><a href="#答案与解析-Answers-and-Explanations" class="headerlink" title="答案与解析 (Answers and Explanations)"></a>答案与解析 (Answers and Explanations)</h3><ol><li><strong>beyond</strong>. 句意：日落的美丽无法用言语形容。“Beyond description”是固定搭配，意为“难以形容”，表示超出了描述的范围。</li><li><strong>before</strong>. 句意：离开房间之前，别忘了关灯。这里表示时间上的“在…之前”。</li><li><strong>behind</strong>. 句意：无论发生什么，我都会在你身后支持你。这里的<code>behind</code>是引申义，表示“支持”。</li><li><strong>below</strong>. 句意：这里的冬天，气温经常降到零摄氏度以下。<code>below zero</code>是固定用法，表示“零下”。</li><li><strong>after</strong>. 句意：几秒钟后，猫跳上桌子开始追老鼠。这里表示时间上的“在…之后”。</li><li><strong>beyond</strong>. 句意：宇宙的奥秘远远超出了人类的理解。这里的<code>beyond</code>表示“超出…范围”。</li><li><strong>before</strong>. 句意：他跪在女王面前接受爵位。这里的<code>before</code>表示空间上的“在…面前”。</li><li><strong>behind</strong>. 句意：我们的进度落后了，需要加快工作。<code>fall behind schedule</code>是固定搭配，意为“进度落后”。</li><li><strong>below</strong>. 句意：在军队中，中士的军衔低于中尉。<code>below</code>用于表示等级、地位的“低于”。</li><li><strong>after</strong>. 句意：他长得像他父亲，他们都有一样的笑容。<code>take after</code>是固定短语，意为“（外貌、性格等）与（长辈）相像”。</li></ol>]]></content>
    
    
    <summary type="html">英语介词第七讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第六讲</title>
    <link href="https://yjyrichard.github.io/posts/d2381bcd.html"/>
    <id>https://yjyrichard.github.io/posts/d2381bcd.html</id>
    <published>2025-08-25T11:59:05.840Z</published>
    <updated>2025-08-25T12:06:14.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第六讲"><a href="#介词第六讲" class="headerlink" title="介词第六讲"></a>介词第六讲</h1><h3 id="up-down-over-under"><a href="#up-down-over-under" class="headerlink" title="up, down, over, under"></a><code>up</code>, <code>down</code>, <code>over</code>, <code>under</code></h3><hr><h3 id="第一关：能量满满的-up"><a href="#第一关：能量满满的-up" class="headerlink" title="第一关：能量满满的 up"></a><strong>第一关：能量满满的 <code>up</code></strong></h3><p><code>up</code> 这个词，你一看到它，脑海里第一个蹦出来的画面是什么？没错，就是一个向上的箭头 <strong>↑</strong>！它的所有意思，都和这个“向上”的感觉有关。</p><h4 id="核心灵魂：向上、起来"><a href="#核心灵魂：向上、起来" class="headerlink" title="核心灵魂：向上、起来"></a><strong>核心灵魂：向上、起来</strong></h4><p>这是 <code>up</code> 最基本的意思，表示物理空间上的移动。</p><ul><li><code>Stand up!</code> (站起来！)</li><li><code>The balloon is going up.</code> (气球正在向上飞。)</li><li><code>Look up at the sky.</code> (抬头看天空。)</li></ul><h4 id="魔法变身1：从“向上”到“完成、彻底”"><a href="#魔法变身1：从“向上”到“完成、彻底”" class="headerlink" title="魔法变身1：从“向上”到“完成、彻底”"></a><strong>魔法变身1：从“向上”到“完成、彻底”</strong></h4><p>想象一个杯子，你往里面倒水，水面不断 <code>up</code> (上升)，直到倒满，这件事就 <strong>完成</strong> 了。所以 <code>up</code> 经常用来表示“做完、用光、吃光”，有一种“彻底干完”的感觉。</p><ul><li><code>Eat up your vegetables.</code> (把你的蔬菜 <strong>吃光</strong>。)<ul><li><em>为什么用 up？</em> -&gt; 表示吃到一点不剩，彻底完成“吃”这个动作。</li></ul></li><li><code>Drink up your milk.</code> (把牛奶 <strong>喝完</strong>。)</li><li><code>Clean up your room.</code> (把你的房间 <strong>彻底打扫干净</strong>。)</li><li><code>The time is up.</code> (时间到了。)<ul><li><em>为什么用 up？</em> -&gt; 分配给你的时间已经完全用“光”了。</li></ul></li></ul><h4 id="魔法变身2：从“向上”到“出现、发生、状态变好”"><a href="#魔法变身2：从“向上”到“出现、发生、状态变好”" class="headerlink" title="魔法变身2：从“向上”到“出现、发生、状态变好”"></a><strong>魔法变身2：从“向上”到“出现、发生、状态变好”</strong></h4><p>一个东西从看不见到看得见，是不是像从地平线“升起来”一样？一个人的情绪从低落到开心，能量是不是在“向上走”？</p><ul><li><code>show up</code> (露面；出现)<ul><li><code>He didn&#39;t show up for the party.</code> (他没在派对上 <strong>露面</strong>。)</li><li><em>为什么用 up？</em> -&gt; 像太阳升起一样，突然“冒出来”让大家看到。</li></ul></li><li><code>cheer up</code> (振作起来)<ul><li><code>Cheer up! Everything will be fine.</code> ( <strong>打起精神来</strong>！一切都会好起来的。)</li><li><em>为什么用 up？</em> -&gt; 让你的情绪和精神状态 <code>up</code> (向上走)。</li></ul></li><li><code>What&#39;s up?</code> (怎么了？/ 你好吗？)<ul><li><em>为什么用 up？</em> -&gt; 问“最近有什么新鲜事 <strong>发生(up)</strong> 吗？”</li></ul></li></ul><h4 id="魔法变身3：从“向上”到“地位高、由你决定”"><a href="#魔法变身3：从“向上”到“地位高、由你决定”" class="headerlink" title="魔法变身3：从“向上”到“地位高、由你决定”"></a><strong>魔法变身3：从“向上”到“地位高、由你决定”</strong></h4><p>在古代，地位高的人是不是都坐在“上面”？所以 <code>up</code> 也可以引申为决定权。</p><ul><li><code>It&#39;s up to you.</code> (你来决定。)<ul><li><em>为什么用 up？</em> -&gt; 决定权这个“球”被抛到了你的“上方”，由你来掌控。</li></ul></li></ul><p><strong>小结一下 <code>up</code>：</strong> 记住核心是 <strong>“向上” ↑</strong>，然后它能变身为 <strong>“完成”、“出现/变好”</strong> 和 <strong>“决定权”</strong>。</p><hr><h3 id="第二关：冷静沉稳的-down"><a href="#第二关：冷静沉稳的-down" class="headerlink" title="第二关：冷静沉稳的 down"></a><strong>第二关：冷静沉稳的 <code>down</code></strong></h3><p><code>down</code> 就是 <code>up</code> 的反义词。它的核心灵魂就是一个向下的箭头 <strong>↓</strong>。所有意思都围绕着“向下”展开。</p><h4 id="核心灵魂：向下、下坠"><a href="#核心灵魂：向下、下坠" class="headerlink" title="核心灵魂：向下、下坠"></a><strong>核心灵魂：向下、下坠</strong></h4><p>这是 <code>down</code> 最基本的意思，表示物理上的向下移动。</p><ul><li><code>Sit down, please.</code> (请坐下。)</li><li><code>The leaves are falling down.</code> (树叶正在飘落下来。)</li><li><code>He lay down on the bed.</code> (他躺在了床上。)</li></ul><h4 id="魔法变身1：从“向下”到“能量降低、变弱、变小”"><a href="#魔法变身1：从“向下”到“能量降低、变弱、变小”" class="headerlink" title="魔法变身1：从“向下”到“能量降低、变弱、变小”"></a><strong>魔法变身1：从“向下”到“能量降低、变弱、变小”</strong></h4><p>和 <code>up</code> 相反，<code>down</code> 代表着能量、速度、音量的减弱。</p><ul><li><code>slow down</code> (减速)<ul><li><code>Please slow down. You&#39;re driving too fast.</code> (请 <strong>慢下来</strong>。你开得太快了。)</li><li><em>为什么用 down？</em> -&gt; 让速度的指针“向下走”。</li></ul></li><li><code>calm down</code> (冷静下来)<ul><li><code>Calm down and tell me what happened.</code> ( <strong>冷静下来</strong>，告诉我发生了什么。)</li><li><em>为什么用 down？</em> -&gt; 让你激动的情绪（高能量）“降下来”。</li></ul></li><li><code>turn down the music</code> (把音乐调小声)<ul><li><em>为什么用 down？</em> -&gt; 把音量旋钮“向下转”。</li></ul></li></ul><h4 id="魔法变身2：从“向下”到“停止、关闭、倒下”"><a href="#魔法变身2：从“向下”到“停止、关闭、倒下”" class="headerlink" title="魔法变身2：从“向下”到“停止、关闭、倒下”"></a><strong>魔法变身2：从“向下”到“停止、关闭、倒下”</strong></h4><p>当能量降到最低点，机器会怎么样？会停止运转。公司会怎么样？会倒闭。</p><ul><li><code>shut down</code> (关机；关闭)<ul><li><code>Don&#39;t forget to shut down the computer.</code> (别忘了 <strong>关掉</strong> 电脑。)</li><li><em>为什么用 down？</em> -&gt; 彻底停止运行，能量降为零。</li></ul></li><li><code>break down</code> (发生故障；崩溃)<ul><li><code>My car broke down on the way to work.</code> (我的车在上班路上 <strong>抛锚了</strong>。)</li><li><em>为什么用 down？</em> -&gt; 车子坏了，完全“倒下”不动了。</li></ul></li><li><code>The old factory closed down last year.</code> (那家老工厂去年 <strong>倒闭了</strong>。)</li></ul><p><strong>小结一下 <code>down</code>：</strong> 记住核心是 <strong>“向下” ↓</strong>，然后它能变身为 <strong>“能量降低”</strong> 和 <strong>“停止运转”</strong>。</p><hr><h3 id="第三关：跨越一切的-over"><a href="#第三关：跨越一切的-over" class="headerlink" title="第三关：跨越一切的 over"></a><strong>第三关：跨越一切的 <code>over</code></strong></h3><p><code>over</code> 的核心画面感，是在一个东西的“上方”，并且经常带有一种“跨越”或“覆盖”的动态感。想象一座桥（bridge）<code>over</code> a river。</p><h4 id="核心灵魂：在…上方、覆盖"><a href="#核心灵魂：在…上方、覆盖" class="headerlink" title="核心灵魂：在…上方、覆盖"></a><strong>核心灵魂：在…上方、覆盖</strong></h4><ul><li><code>The cloth is over the table.</code> (那块布 <strong>盖在</strong> 桌子上。)<ul><li><em>为什么用 over？</em> -&gt; 强调的是“覆盖”在整个表面上。</li></ul></li><li><code>The plane is flying over the city.</code> (飞机正飞越城市的 <strong>上空</strong>。)</li></ul><h4 id="魔法变身1：从“跨越”到“克服、结束”"><a href="#魔法变身1：从“跨越”到“克服、结束”" class="headerlink" title="魔法变身1：从“跨越”到“克服、结束”"></a><strong>魔法变身1：从“跨越”到“克服、结束”</strong></h4><p>想象你面前有一道障碍，你 <code>jump over</code> (跳过) 它，是不是就意味着你 <strong>克服</strong> 了它？当你跑 <code>over</code> (越过) 终点线，比赛是不是就 <strong>结束</strong> 了？</p><ul><li><code>get over</code> (克服；恢复)<ul><li><code>He finally got over his illness.</code> (他终于从病中 <strong>恢复</strong> 了过来。)</li><li><em>为什么用 over？</em> -&gt; 像是“跨过”了生病这个难关。</li></ul></li><li><code>The game is over.</code> (游戏 <strong>结束</strong> 了。)</li><li><code>think over</code> (仔细考虑)<ul><li><em>为什么用 over？</em> -&gt; 把一个问题从头到尾、方方面面都“跨越”一遍，想个透彻。</li></ul></li></ul><h4 id="魔法变身2：从“上方”到“超过”"><a href="#魔法变身2：从“上方”到“超过”" class="headerlink" title="魔法变身2：从“上方”到“超过”"></a><strong>魔法变身2：从“上方”到“超过”</strong></h4><p>一个东西的位置比另一个高，那它的数量、程度是不是也可能比另一个“高”？</p><ul><li><code>Over 1,000 students are on the playground.</code> ( <strong>超过</strong> 1000名学生在操场上。)</li><li><code>He is over 40 years old.</code> (他 <strong>超过</strong> 40岁了。)</li></ul><p><strong>小结一下 <code>over</code>：</strong> 记住核心是 <strong>“上方跨越/覆盖”</strong>，然后它能变身为 <strong>“克服/结束”</strong> 和 <strong>“数量超过”</strong>。</p><hr><h3 id="第四关：深藏不露的-under"><a href="#第四关：深藏不露的-under" class="headerlink" title="第四关：深藏不露的 under"></a><strong>第四关：深藏不露的 <code>under</code></strong></h3><p><code>under</code> 是 <code>over</code> 的反义词。它的核心画面感，是在一个东西的“正下方”。</p><h4 id="核心灵魂：在…正下方"><a href="#核心灵魂：在…正下方" class="headerlink" title="核心灵魂：在…正下方"></a><strong>核心灵魂：在…正下方</strong></h4><ul><li><code>The cat is sleeping under the table.</code> (猫在桌子 <strong>下面</strong> 睡觉。)</li><li><code>He put the key under the mat.</code> (他把钥匙放在了门垫 <strong>下面</strong>。)</li></ul><h4 id="魔法变身：从“在下方”到“在…影响-控制-状态下”"><a href="#魔法变身：从“在下方”到“在…影响-控制-状态下”" class="headerlink" title="魔法变身：从“在下方”到“在…影响/控制/状态下”"></a><strong>魔法变身：从“在下方”到“在…影响/控制/状态下”</strong></h4><p>想象一下，你在一个大领导的“手下”工作，是不是就处于他的管理 <strong>之下</strong>？一个项目在建设中，是不是就处于“建设”这个状态 <strong>之下</strong>？</p><ul><li><code>under control</code> (在控制之下)<ul><li><code>The fire is now under control.</code> (火势现在得到了 <strong>控制</strong>。)</li><li><em>为什么用 under？</em> -&gt; 火被消防员的力量“压在下面”。</li></ul></li><li><code>under construction</code> (在建设中)<ul><li><code>The new library is under construction.</code> (新图书馆正 <strong>在建设中</strong>。)</li><li><em>为什么用 under？</em> -&gt; 处于“建设”这个大过程的笼罩之下。</li></ul></li><li><code>under pressure</code> (在压力之下)<ul><li><code>She works well under pressure.</code> (她在 <strong>压力下</strong> 工作得很好。)</li></ul></li><li><code>under the law</code> (依照法律)<ul><li><em>为什么用 under？</em> -&gt; 我们的所有行为都在法律的管辖“之下”。</li></ul></li><li><strong>表示数量少于：</strong><ul><li><code>All the books are under 10 yuan.</code> (所有的书都 <strong>低于</strong> 10元。)</li></ul></li></ul><p><strong>小结一下 <code>under</code>：</strong> 记住核心是 <strong>“在正下方”</strong>，然后它能变身为 <strong>“在某种状态或控制下”</strong> 和 <strong>“数量少于”</strong>。</p><hr><h3 id="总结时刻"><a href="#总结时刻" class="headerlink" title="总结时刻"></a><strong>总结时刻</strong></h3><div class="table-container"><table><thead><tr><th style="text-align:left">介词</th><th style="text-align:left">核心图像</th><th style="text-align:left">魔法变身含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>up</strong></td><td style="text-align:left"><strong>↑ 向上</strong></td><td style="text-align:left">1. <strong>完成/用光</strong> (eat up) <br> 2. <strong>出现/变好</strong> (show up, cheer up) <br> 3. <strong>决定权</strong> (up to you)</td></tr><tr><td style="text-align:left"><strong>down</strong></td><td style="text-align:left"><strong>↓ 向下</strong></td><td style="text-align:left">1. <strong>能量降低</strong> (calm down) <br> 2. <strong>停止/关闭</strong> (shut down)</td></tr><tr><td style="text-align:left"><strong>over</strong></td><td style="text-align:left"><strong>↷ 跨越/覆盖</strong></td><td style="text-align:left">1. <strong>克服/结束</strong> (get over, game is over) <br> 2. <strong>超过</strong> (over 1000)</td></tr><tr><td style="text-align:left"><strong>under</strong></td><td style="text-align:left"><strong>⤓ 在…正下方</strong></td><td style="text-align:left">1. <strong>在…状态/控制下</strong> (under control) <br> 2. <strong>少于</strong> (under 10)</td></tr></tbody></table></div><p>同学们，英语学习就像搭积木。今天我们把 <code>up</code>, <code>down</code>, <code>over</code>, <code>under</code> 这四块最基础的积木研究透了。以后再遇到包含它们的短语，试着用它们的“核心灵魂”去感受一下，你会发现，很多意思一下子就猜到了！</p><p>多观察，多体会，你就是下一个介词小高手！</p>]]></content>
    
    
    <summary type="html">英语介词第六讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第三讲</title>
    <link href="https://yjyrichard.github.io/posts/6f858c36.html"/>
    <id>https://yjyrichard.github.io/posts/6f858c36.html</id>
    <published>2025-08-25T11:59:05.789Z</published>
    <updated>2025-08-25T12:06:14.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第三讲"><a href="#介词第三讲" class="headerlink" title="介词第三讲"></a>介词第三讲</h1><h3 id="逐个击破-on-off-in-out-at！"><a href="#逐个击破-on-off-in-out-at！" class="headerlink" title="逐个击破 on, off, in, out, at！"></a><strong>逐个击破 on, off, in, out, at！</strong></h3><p>同学们好！</p><p>还在为记不住介词用法而头疼吗？看到 <code>on</code>, <code>in</code>, <code>at</code> 就开始头晕？别担心！今天我们换一种思路，不靠死记硬背，而是去理解每个介词最核心的“灵魂”，让你像玩游戏通关一样，轻松掌握它们的用法！</p><p><strong>学习秘诀：</strong> 抓住核心思想，进行图像化联想！</p><hr><h3 id="第一关：ON-万物皆可“接触”"><a href="#第一关：ON-万物皆可“接触”" class="headerlink" title="第一关：ON - 万物皆可“接触”"></a><strong>第一关：ON - 万物皆可“接触”</strong></h3><h4 id="⭐-核心思想：表面接触-Surface-Contact"><a href="#⭐-核心思想：表面接触-Surface-Contact" class="headerlink" title="⭐ 核心思想：表面接触 (Surface Contact)"></a><strong>⭐ 核心思想：表面接触 (Surface Contact)</strong></h4><p>想象一下，任何东西只要和另一个东西的<strong>表面挨着、贴着、接触着</strong>，我们就可以用 <code>on</code>！</p><h4 id="🧠-思维导图：从“接触”出发"><a href="#🧠-思维导图：从“接触”出发" class="headerlink" title="🧠 思维导图：从“接触”出发"></a><strong>🧠 思维导图：从“接触”出发</strong></h4><ol><li><strong>在…上（最常见的接触）</strong><ul><li><code>a book on the desk</code> (书在课桌上) -&gt; 书的底面<strong>接触</strong>了课桌的表面。</li><li><code>a photo on the wall</code> (墙上的一张照片) -&gt; 照片的背面<strong>接触</strong>了墙的表面。</li></ul></li><li><strong>接通 / 运行中（电路接触了）</strong><ul><li><code>turn on the light</code> (开灯) -&gt; 按下开关，电路<strong>接触</strong>并连通了。</li><li><code>The movie is on.</code> (电影正在上映) -&gt; 电影正在“播放”这个状态上<strong>接触</strong>着，表示“进行中”。</li></ul></li><li><strong>持续不断（动作接触着时间线）</strong><ul><li><code>go on</code> (继续) -&gt; 让动作<strong>接触</strong>着时间线，不要断开。</li><li><code>keep on doing sth.</code> (坚持做某事)</li></ul></li><li><strong>支撑 / 依赖（一种抽象的接触）</strong>  count on <ul><li><code>depend on sb.</code> (依靠某人) -&gt; 你的生活<strong>接触</strong>并依赖于他人的支撑。</li><li><code>feet on the scale</code> (脚踩在体重秤上) -&gt; 脚<strong>接触</strong>秤面，形成了支撑和压力。</li></ul></li><li><strong>特定日期（时间点接触日历）</strong><ul><li><code>on Sunday</code> (在周日) -&gt; 想象一下日历，你的计划正好<strong>贴在</strong>“周日”那一格上。</li><li><code>on July 1st</code> (在7月1日)</li></ul></li></ol><h4 id="💡-独家技巧：on-a-bus-vs-in-a-car"><a href="#💡-独家技巧：on-a-bus-vs-in-a-car" class="headerlink" title="💡 独家技巧：on a bus vs. in a car"></a><strong>💡 独家技巧：<code>on</code> a bus vs. <code>in</code> a car</strong></h4><ul><li><strong>用 <code>on</code></strong>：对于那些你可以在里面<strong>站起来行走</strong>的大型交通工具，比如公交车、火车、飞机、轮船。想象你<strong>站在</strong>它们的甲板或地板上，脚与表面<strong>接触</strong>。<ul><li><code>on the bus</code>, <code>on the train</code>, <code>on the plane</code></li></ul></li><li><strong>用 <code>in</code></strong>：对于那些你只能<strong>坐进去</strong>的，空间较小的交通工具，比如小汽车、出租车。你感觉自己是被“包裹”<strong>在里面</strong>的。<ul><li><code>in the car</code>, <code>in a taxi</code></li></ul></li></ul><hr><h3 id="第二关：OFF-“接触”的反义词“脱离”"><a href="#第二关：OFF-“接触”的反义词“脱离”" class="headerlink" title="第二关：OFF - “接触”的反义词“脱离”"></a><strong>第二关：OFF - “接触”的反义词“脱离”</strong></h3><h4 id="⭐-核心思想：脱离-Separation-Detachment"><a href="#⭐-核心思想：脱离-Separation-Detachment" class="headerlink" title="⭐ 核心思想：脱离 (Separation / Detachment)"></a><strong>⭐ 核心思想：脱离 (Separation / Detachment)</strong></h4><p><code>off</code> 就是 <code>on</code> 的反义词！只要是从一个表面、一个状态、一个位置<strong>分开、离开、断开</strong>，就用 <code>off</code>！</p><h4 id="🧠-思维导图：从“脱离”出发"><a href="#🧠-思维导图：从“脱离”出发" class="headerlink" title="🧠 思维导图：从“脱离”出发"></a><strong>🧠 思维导图：从“脱离”出发</strong></h4><ol><li><p><strong>离开表面（物理脱离）</strong></p><ul><li><code>take off your coat</code> (脱下你的外套) -&gt; 外套<strong>脱离</strong>你的身体表面。</li><li><code>fall off the bike</code> (从自行车上摔下来) -&gt; 你<strong>脱离</strong>了自行车。</li></ul></li><li><p><strong>断开 / 关闭（连接脱离）</strong></p><ul><li><code>turn off the light</code> (关灯) -&gt; 电路连接<strong>脱离</strong>了。</li><li><code>cut off the power</code> (切断电源) -&gt; 电源被<strong>切断脱离</strong>。</li></ul></li><li><p><strong>不工作 / 休息（从工作状态脱离）</strong></p><ul><li><code>He is off today.</code> (他今天休息。) -&gt; 他<strong>脱离</strong>了工作的状态。</li><li><code>call off the meeting</code> (取消会议) -&gt; 让会议从日程表上<strong>脱离</strong>。</li></ul></li><li><p><strong>去除 / 折扣（从整体中脱离）</strong></p><ul><li><code>20% off</code> (打八折) -&gt; 从原价中<strong>去除/脱离</strong>20%的部分。</li><li><code>clean off the dirt</code> (清除污垢) -&gt; 让污垢<strong>脱离</strong>物体表面。</li></ul></li><li><p><strong>出发 / 逃跑（从原地点脱离）</strong></p><ul><li><code>set off</code> (出发) -&gt; <strong>脱离</strong>你的出发点。</li><li><code>run off</code> (逃跑) -&gt; 快速<strong>脱离</strong>某个地方。</li></ul></li></ol><hr><h3 id="第三关：IN-在一个“空间”里"><a href="#第三关：IN-在一个“空间”里" class="headerlink" title="第三关：IN - 在一个“空间”里"></a><strong>第三关：IN - 在一个“空间”里</strong></h3><h4 id="⭐-核心思想：在…里-Inside-a-Boundary"><a href="#⭐-核心思想：在…里-Inside-a-Boundary" class="headerlink" title="⭐ 核心思想：在…里 (Inside a Boundary)"></a><strong>⭐ 核心思想：在…里 (Inside a Boundary)</strong></h4><p><code>in</code> 强调的是在一个<strong>立体空间</strong>或者一个<strong>范围</strong>的<strong>内部</strong>。这个“空间”可以是真实的，也可以是虚拟的。</p><h4 id="🧠-思维导图：从“在…里”出发"><a href="#🧠-思维导图：从“在…里”出发" class="headerlink" title="🧠 思维导图：从“在…里”出发"></a><strong>🧠 思维导图：从“在…里”出发</strong></h4><ol><li><p><strong>在真实空间里</strong></p><ul><li><code>in the box</code> (在盒子里) -&gt; 被盒子的四壁包围。</li><li><code>in the room</code> (在房间里)</li><li><code>arrive in Beijing</code> (到达北京) -&gt; 北京是一个很大的地理范围，你到达了它的<strong>内部</strong>。</li></ul></li><li><p><strong>在虚拟/抽象空间里</strong></p><ul><li><code>in danger</code> (处于危险之中) -&gt; 你被“危险”这种状态<strong>包围</strong>着。</li><li><code>fall in love</code> (坠入爱河) -&gt; 你进入了“爱”的这种情感<strong>范围</strong>里。</li><li><code>in the future</code> (在未来) -&gt; 在“未来”这段长长的时间<strong>范围</strong>里。</li></ul></li><li><p><strong>表示方式/语言（在…的方式里）</strong></p><ul><li><code>in English</code> (用英语) -&gt; 在“英语”这个语言体系<strong>里</strong>进行交流。</li><li><code>in cash</code> (用现金) -&gt; 在“现金”这种支付方式<strong>里</strong>完成交易。</li></ul></li><li><p><strong>表示一段时间后（在未来的时间段里）</strong></p><ul><li><code>in three years</code> (三年后) -&gt; 从现在开始，在未来三年的时间<strong>范围</strong>结束时。</li><li><code>in a short while</code> (一会儿以后)</li></ul></li></ol><hr><h3 id="第四关：OUT-从“空间”里出来"><a href="#第四关：OUT-从“空间”里出来" class="headerlink" title="第四关：OUT - 从“空间”里出来"></a><strong>第四关：OUT - 从“空间”里出来</strong></h3><h4 id="⭐-核心思想：在…外-出来-Outside-Emerging"><a href="#⭐-核心思想：在…外-出来-Outside-Emerging" class="headerlink" title="⭐ 核心思想：在…外 / 出来 (Outside / Emerging)"></a><strong>⭐ 核心思想：在…外 / 出来 (Outside / Emerging)</strong></h4><p><code>out</code> 正好是 <code>in</code> 的反义词。它表示从一个封闭的空间或范围<strong>向外移动</strong>，或者表示一种<strong>出现、显露、耗尽</strong>的状态。</p><h4 id="🧠-思维导图：从“在…外”出发"><a href="#🧠-思维导图：从“在…外”出发" class="headerlink" title="🧠 思维导图：从“在…外”出发"></a><strong>🧠 思维导图：从“在…外”出发</strong></h4><ol><li><p><strong>出去 / 出现（从里到外）</strong></p><ul><li><code>get out</code> (出去) -&gt; 从一个空间里<strong>出来</strong>。</li><li><code>find out the truth</code> (找出真相) -&gt; 让真相从隐藏的状态<strong>显露出来</strong>。</li><li><code>speak out</code> (大声说出来) -&gt; 让你的想法从脑子里<strong>出来</strong>。</li></ul></li><li><p><strong>在…范围之外（超出限制）</strong></p><ul><li><code>out of control</code> (失控) -&gt; 超<strong>出</strong>了控制的<strong>范围</strong>。</li><li><code>out of date</code> (过时的) -&gt; 超<strong>出</strong>了现在的日期/时代。</li><li><code>out of danger</code> (脱离危险) -&gt; 走<strong>出</strong>了危险的<strong>范围</strong>。</li></ul></li><li><p><strong>结束 / 耗尽（里面的东西没了）</strong></p><ul><li><code>put out the fire</code> (灭火) -&gt; 让火的生命力<strong>耗尽</strong>，从有到<strong>无</strong>。</li><li><code>run out of money</code> (钱用完了) -&gt; 钱包里的钱都跑<strong>出去</strong>了，<strong>耗尽</strong>了。</li><li><code>Mamba out.</code> (曼巴出局了/退场了) -&gt; 离开了赛场这个“局”。</li></ul></li></ol><hr><h3 id="第五关：AT-瞄准一个“点”"><a href="#第五关：AT-瞄准一个“点”" class="headerlink" title="第五关：AT - 瞄准一个“点”"></a><strong>第五关：AT - 瞄准一个“点”</strong></h3><h4 id="⭐-核心思想：针对某点-Targeting-a-specific-point"><a href="#⭐-核心思想：针对某点-Targeting-a-specific-point" class="headerlink" title="⭐ 核心思想：针对某点 (Targeting a specific point)"></a><strong>⭐ 核心思想：针对某点 (Targeting a specific point)</strong></h4><p><code>at</code> 是最精确的介词！它不像 <code>in</code> (在一个大范围里) 或 <code>on</code> (在一个表面上)，<code>at</code> 强调的是一个<strong>非常具体、精确的点</strong>。这个“点”可以是时间点、地点、目标或状态。</p><h4 id="🧠-思维导图：从“针对某点”出发"><a href="#🧠-思维导图：从“针对某点”出发" class="headerlink" title="🧠 思维导图：从“针对某点”出发"></a><strong>🧠 思维导图：从“针对某点”出发</strong></h4><ol><li><p><strong>在某个精确地点</strong></p><ul><li><code>at the bus stop</code> (在公交车站) -&gt; 公交站是一个<strong>精确的小地点</strong>。</li><li><code>at the door</code> (在门口)</li><li><code>at home</code> / <code>at school</code> -&gt; 把家/学校看作一个进行活动的功能<strong>点</strong>。</li></ul></li><li><p><strong>在某个精确时间点</strong></p><ul><li><code>at 9:00</code> (在9点整) -&gt; 时间轴上一个非常精确的<strong>点</strong>。</li><li><code>at noon</code> (在中午)</li><li><code>at the end of the day</code> (在一天结束时) -&gt; “结束”这个<strong>时间点</strong>。</li></ul></li><li><p><strong>针对某个目标（动作的指向点）</strong></p><ul><li><code>look at me</code> (看着我) -&gt; 你的目光<strong>瞄准</strong>我这个<strong>点</strong>。</li><li><code>shoot at sb.</code> (向某人射击) -&gt; 子弹<strong>瞄准</strong>某人这个<strong>目标点</strong>。</li><li><code>shout at sb.</code> (对某人吼叫) -&gt; 带有攻击性，把吼叫当作武器<strong>瞄准</strong>某人。</li></ul></li><li><p><strong>在某个数值/状态点上</strong></p><ul><li><code>at the age of five</code> (在5岁时) -&gt; 人生时间线上的一个<strong>点</strong>。</li><li><code>at a speed of 100 km/h</code> (以每小时100公里的速度) -&gt; 速度计上的一个<strong>精确读数点</strong>。</li><li><code>at work</code> (在工作) -&gt; 处在“工作”这个状态<strong>点</strong>上。</li></ul></li></ol><hr><h3 id="总结与挑战"><a href="#总结与挑战" class="headerlink" title="总结与挑战"></a><strong>总结与挑战</strong></h3><p>记住，学习介词的关键是理解它们的<strong>核心画面感</strong>：</p><ul><li><strong>ON</strong> -&gt; 接触在一个<strong>面</strong>上</li><li><strong>OFF</strong> -&gt; 从一个<strong>面</strong>上脱离</li><li><strong>IN</strong> -&gt; 在一个<strong>立体空间/范围</strong>里</li><li><strong>OUT</strong> -&gt; 从一个<strong>空间/范围</strong>里出来</li><li><strong>AT</strong> -&gt; 瞄准一个<strong>精确的点</strong></li></ul><h4 id="✍️-实战演练：小试牛刀！"><a href="#✍️-实战演练：小试牛刀！" class="headerlink" title="✍️ 实战演练：小试牛刀！"></a><strong>✍️ 实战演练：小试牛刀！</strong></h4><p>请用 <code>on</code>, <code>off</code>, <code>in</code>, <code>out</code>, <code>at</code> 填空。</p><ol><li>Please don’t put your feet <strong>__</strong> the table.</li><li>The train will arrive <strong>__</strong> 10:30 AM.</li><li>My birthday is <strong>__</strong> October.</li><li>It’s cold. You should turn <strong>__</strong> the heater.</li><li>We ran <strong>__</strong> of milk, so I need to go to the store.</li><li>He is angry and shouting <strong>__</strong> his brother.</li><li>I live <strong>__</strong> a small apartment <strong>__</strong> Shanghai.</li><li>Could you please turn <strong>__</strong> the music? It’s too loud.</li></ol><p>（答案在最后哦！）</p><p>希望这份讲义能帮助你和这些介词成为好朋友！加油！</p><hr><p><strong>答案：</strong></p><ol><li>on (脚接触桌面)</li><li>at (精确时间点)</li><li>in (月份是一个时间范围)</li><li>on (接通电路)</li><li>out (牛奶从有到无，耗尽了)</li><li>at (吼叫的目标点是弟弟)</li><li>in, in (公寓和上海都是一个空间/范围)</li><li>off (断开音乐)</li></ol><p>当然！承接上面的风格，我们来一场精彩的“进阶挑战赛”！</p><hr><h3 id="介词大作战：进阶挑战赛！"><a href="#介词大作战：进阶挑战赛！" class="headerlink" title="介词大作战：进阶挑战赛！"></a><strong>介词大作战：进阶挑战赛！</strong></h3><p>非常好！你已经成功闯过了五大基础关卡。现在，让我们把难度稍微提升一点，看看你是否能灵活运用这些介词的“核心灵魂”来解决更复杂的场景！准备好了吗？Let’s go!</p><h4 id="✍️-进阶挑战：思维大考验！"><a href="#✍️-进阶挑战：思维大考验！" class="headerlink" title="✍️ 进阶挑战：思维大考验！"></a><strong>✍️ 进阶挑战：思维大考验！</strong></h4><p>请用 <code>on</code>, <code>off</code>, <code>in</code>, <code>out</code>, <code>at</code> 填空。</p><ol><li>The party starts <strong>__</strong> 8 PM sharp, so don’t be late!</li><li>I think I left my keys <strong>__</strong> the car. I can’t find them in my pocket.</li><li>She is an expert <strong>__</strong> the field of artificial intelligence.</li><li>The sign on the lawn says, “Please keep <strong>__</strong> the grass.”</li><li>It turns <strong>__</strong> that the quietest person in the room had the best idea.</li><li>Are you angry? Why are you looking <strong>__</strong> me like that?</li><li>We always exchange gifts <strong>__</strong> Christmas Day.</li><li>I was so tired after work that I fell asleep <strong>__</strong> the bus on my way home.</li><li>He took a day <strong>__</strong> from work to go to the doctor.</li><li>The store is having a big sale! Everything is 50% <strong>__</strong>!</li></ol><hr><h4 id="答案与灵魂解析"><a href="#答案与灵魂解析" class="headerlink" title="答案与灵魂解析"></a><strong>答案与灵魂解析</strong></h4><p>准备好核对答案了吗？记住，重点不是对错，而是理解为什么！</p><ol><li><p><strong>at</strong></p><ul><li><strong>灵魂解析：</strong> <code>8 PM sharp</code> (8点整) 是时间轴上一个极其<strong>精确的点</strong>，所以用 <code>at</code> 来“瞄准”它。</li></ul></li><li><p><strong>in</strong></p><ul><li><strong>灵魂解析：</strong> <code>the car</code> (小汽车) 是一个你被包裹<strong>在里面</strong>的<strong>封闭空间</strong>，所以用 <code>in</code>。</li></ul></li><li><p><strong>in</strong></p><ul><li><strong>灵魂解析：</strong> <code>the field of artificial intelligence</code> (人工智能领域) 是一个广阔、抽象的知识<strong>范围</strong>或<strong>空间</strong>，她是在这个“领域里”的专家。</li></ul></li><li><p><strong>off</strong></p><ul><li><strong>灵魂解析：</strong> <code>keep off</code> 的意思是保持<strong>脱离</strong>状态。这个标志要求你的脚不要与草坪的表面<strong>接触</strong>，所以是 <code>on</code> 的反义词 <code>off</code>。</li></ul></li><li><p><strong>out</strong></p><ul><li><strong>灵魂解析：</strong> <code>turns out</code> 的意思是“结果是…”、“原来是…”。这表示真相或结果从隐藏的状态中<strong>显露出来</strong>，符合 <code>out</code> 从里到外的核心思想。</li></ul></li><li><p><strong>at</strong></p><ul><li><strong>灵魂解析：</strong> <code>look at</code> 表示目光的<strong>指向</strong>和<strong>目标</strong>。你的目光像一支箭，<strong>瞄准</strong>了我这个<strong>点</strong>。</li></ul></li><li><p><strong>on</strong></p><ul><li><strong>灵魂解析：</strong> <code>Christmas Day</code> (圣诞节当天) 是日历上一个<strong>特定的日子</strong>，我们的活动正好“贴”在了那一天的<strong>表面</strong>上。</li></ul></li><li><p><strong>on</strong></p><ul><li><strong>灵魂解析：</strong> <code>the bus</code> (公交车) 是一个你可以在里面站立行走的大型交通工具。想象你的脚<strong>接触</strong>在公交车的地板<strong>表面</strong>上。</li></ul></li><li><p><strong>off</strong></p><ul><li><strong>灵魂解析：</strong> <code>take a day off</code> (休一天假) 意味着你从工作的状态或日程表上<strong>脱离</strong>开来，所以用 <code>off</code>。</li></ul></li><li><p><strong>off</strong></p><ul><li><strong>灵魂解析：</strong> <code>50% off</code> (打五折) 表示从原价中<strong>去除/脱离</strong>50%的部分。</li></ul></li></ol><p>做得怎么样？有没有感觉对这些介词的“灵魂”理解更深了？继续保持这种图像化联想的习惯，你会发现介词真的没那么可怕！</p>]]></content>
    
    
    <summary type="html">英语介词第三讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第四讲</title>
    <link href="https://yjyrichard.github.io/posts/d8a89553.html"/>
    <id>https://yjyrichard.github.io/posts/d8a89553.html</id>
    <published>2025-08-25T11:59:05.759Z</published>
    <updated>2025-08-25T12:06:14.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第四讲"><a href="#介词第四讲" class="headerlink" title="介词第四讲"></a>介词第四讲</h1><h3 id="介词-from-to-for-of-with"><a href="#介词-from-to-for-of-with" class="headerlink" title="介词 from, to, for, of, with "></a><strong>介词 from, to, for, of, with </strong></h3><p>同学们好！</p><p>介词是英语中非常重要的小词，它们虽然短小，但却能表达丰富的意思。很多同学觉得介词难记，其实是因为没有抓住它们的核心思想。今天，我们就通过一些里的方法，来理解五个最常用的介词，你会发现，只要掌握了每个词的“核心”，所有用法就都想通了！</p><hr><h3 id="1-from-核心思想：起点-分离"><a href="#1-from-核心思想：起点-分离" class="headerlink" title="1. from - 核心思想：起点 / 分离"></a><strong>1. from - 核心思想：起点 / 分离</strong></h3><p><code>from</code> 这个词，你只要记住它的核心意思是 <strong>“起点”</strong>，就像从 A 点出发一样。所有的用法都和这个“起点”有关。</p><p><strong>用法一：表示“起点” (从…)</strong><br>这是 <code>from</code> 最基本的意思，可以指具体的地点，也可以是抽象的时间或来源。</p><ul><li><strong>具体的起点</strong><ul><li><code>from Beijing to Shanghai</code> (从北京到上海)</li><li><code>I am from Hangzhou.</code> (我来自杭州)</li></ul></li><li><strong>抽象的起点</strong><ul><li><code>from 8:00 to 10:00</code> (从8点到10点)</li><li><code>learn from sb.</code> (从某人那里学到) - 知识的起点是某人</li><li><code>hear from sb.</code> (收到某人的来信) - 信的起点是某人</li></ul></li><li><strong>表示“原因”或“原材料”</strong><ul><li><code>die from...</code> (死于…) - 疾病是死亡的起点</li><li><code>be made from...</code> (由…制造) - 看不出原材料的样子，强调来源   vs    be made of</li><li><code>result from...</code> (由…造成) - 某个原因是结果的起点</li></ul></li></ul><p><strong>用法二：表示“分离” (离开…)</strong><br>从“起点”出发，自然就有一种“离开、分离”的感觉。</p><ul><li><code>keep away from...</code> (远离…)</li><li><code>be different from...</code> (和…不同) - 思想或状态上分离开</li><li><code>prevent/stop sb. from doing sth.</code> (阻止某人做某事) - 让他离开“做这件事”的状态</li></ul><p><strong>小结：</strong> 记住 <code>from</code> 就是 <strong>“从一个点出来”</strong>，无论是地点、时间、原因还是状态。</p><hr><h3 id="2-to-核心思想：方向-目标"><a href="#2-to-核心思想：方向-目标" class="headerlink" title="2. to - 核心思想：方向 / 目标"></a><strong>2. to - 核心思想：方向 / 目标</strong></h3><p><code>to</code> 和 <code>from</code> 正好相反，它的核心意思是 <strong>“方向性”</strong>，表示从 A 到 B 的那个 <strong>“去向”</strong> 和 <strong>“目标”</strong>。</p><p><strong>用法一：表示“方向和目的地” (到…)</strong><br>这是 <code>to</code> 最直观的用法，强调一个动作的方向。</p><ul><li><code>go to school</code> (去学校)</li><li><code>from A to B</code> (从A到B)</li><li><code>give sth. to sb.</code> (把某物给某人) - 物品移动的方向是“某人”</li><li><code>send sth. to sb.</code> (把某物寄给某人)</li></ul><p><strong>用法二：表示“关联” (对于…)</strong><br>从“方向”引申出来，可以表示两个事物之间的关联，一个指向另一个。</p><ul><li><code>the key to the door</code> (门的钥匙) - 钥匙指向门</li><li><code>the answer to the question</code> (问题的答案) - 答案指向问题</li><li><code>belong to...</code> (属于…) - 归属关系，指向主人</li></ul><p><strong>用法三：表示“目标”(不定式 to do)</strong><br>这是 <code>to</code> 在语法中的一个重要用法，<code>to</code> 后面跟动词原形，表示一个要去做的 <strong>“目标”</strong> 或 <strong>“目的”</strong>。</p><ul><li><code>I want to eat it.</code> (我想吃掉它) - “吃”是我的目标</li><li><code>We need to do sth.</code> (我们需要做某事) - “做某事”是我们的目标</li><li><code>To see is to believe.</code> (眼见为实)</li></ul><p><strong>小结：</strong> 记住 <code>to</code> 就是一个 <strong>“箭头 →”</strong>，永远指向一个方向、目的地或目标。</p><hr><h3 id="3-for-核心思想：为了-目的"><a href="#3-for-核心思想：为了-目的" class="headerlink" title="3. for - 核心思想：为了 / 目的"></a><strong>3. for - 核心思想：为了 / 目的</strong></h3><p><code>for</code> 的核心意思是 <strong>“为了”</strong>，表达一个动作的 <strong>“目的”</strong> 或 <strong>“原因”</strong>。</p><p><strong>用法一：表示“为了谁” (受益人)</strong><br>这个动作是为谁而做的。</p><ul><li><code>I will buy a pen for you.</code> (我为你买支笔) - 你是受益者</li><li><code>a book for babys</code> (给宝宝们的书) - 书的目标读者是宝宝</li><li><code>This letter is for you.</code> (这封信是给你的)</li></ul><p><strong>小贴士：<code>for</code> 和 <code>to</code> 的区别</strong></p><ul><li><code>buy sth. for sb.</code> (为某人买) - 强调“为了谁”这个目的。</li><li><code>give sth. to sb.</code> (把…给某人) - 强调“给”这个动作的方向。</li></ul><p><strong>用法二：表示“目的或用途” (为了什么)</strong></p><ul><li><code>The train is for Chengdu.</code> (这趟火车是开往成都的) - 目的地是成都</li><li><code>leave for...</code> (动身去…)</li><li><code>look for...</code> (寻找…) - 为了找到它</li><li><code>wait for...</code> (等待…)</li></ul><p><strong>用法三：表示“原因”</strong></p><ul><li><code>be known for...</code> (因…而闻名)</li><li><code>Thank you for your help.</code> (为你的帮助而感谢)</li></ul><p><strong>小结：</strong> 记住 <code>for</code> 就是 <strong>“为了一个目标”</strong>，这个目标可以是一个人，也可以是一件事。</p><hr><h3 id="4-of-核心思想：所属关系"><a href="#4-of-核心思想：所属关系" class="headerlink" title="4. of - 核心思想：所属关系"></a><strong>4. of - 核心思想：所属关系</strong></h3><p><code>of</code> 最核心的意思就是 <strong>“…的”</strong>，表示一种 <strong>“所属关系”</strong>。A of B 的结构，核心词是 A，B 用来修饰 A。A of B 翻译为B的A</p><p><strong>用法一：表示“所属” (…的)</strong><br>这是 <code>of</code> 最常见的用法。</p><ul><li><code>the door of the room</code> (房间的门)</li><li><code>the name of the game</code> (游戏的名字)</li></ul><p><strong>用法二：表示“相关”</strong><br>表示动作涉及的对象，可以理解为“关于…的”。</p><ul><li><code>take care of sb.</code> (照顾某人) - 你的“照顾”是属于这个人的</li><li><code>remind sb. of sth.</code> (提醒某人某事)</li><li><code>be made of...</code> (由…制作) - 看得出原材料，强调“材料是…的”</li></ul><p><strong>用法三：表示“整体中的一部分” (量词)</strong><br>表示数量时，<code>of</code> 后面的名词是整体。</p><ul><li><code>a lot of money</code> (大量的钱)</li><li><code>a cup of tea</code> (一杯茶) - 茶是整体，杯是部分</li><li><code>each of us</code> (我们中的每一个)</li></ul><p><strong>小结：</strong> 记住 <code>of</code> 就表示 <strong>“…的”</strong>，用来连接两个有归属或相关联系的名词。</p><hr><h3 id="5-with-核心思想：伴随"><a href="#5-with-核心思想：伴随" class="headerlink" title="5. with - 核心思想：伴随"></a><strong>5. with - 核心思想：伴随</strong></h3><p><code>with</code> 的核心意思特别好记，就是 <strong>“伴随”</strong>，表示“和…在一起”或“带着…”。</p><p><strong>用法一：表示“和…一起” (伴随)</strong><br>表示人或物一起行动。</p><ul><li><code>play with sb.</code> (和某人一起玩)</li><li><code>go home with my friend</code> (和我的朋友一起回家)</li><li><code>talk with sb.</code> (和某人聊天)</li><li><code>agree with sb.</code> (同意某人) - 观点和他在一起</li></ul><p><strong>用法二：表示“拥有”或“带有”</strong><br>可以理解为某个特征“伴随”在某人或某物身上。</p><ul><li><code>the boy with big eyes</code> (有双大眼睛的男孩) - 大眼睛伴随着男孩</li><li><code>a room with a nice view</code> (一个有好风景的房间)</li></ul><p><strong>用法三：表示“使用工具” (用)</strong><br>做某个动作时，伴随的工具是什么。</p><ul><li><code>write with a pen</code> (用钢笔写字)</li><li><code>beat it with my hand</code> (用手打它)</li><li><code>be covered with snow</code> (被雪覆盖着) - 伴随着雪</li></ul><p><strong>小结：</strong> 记住 <code>with</code> 就是 <strong>“手拉手”</strong>，表示人、物、工具或特征伴随在一起。</p><hr><p><strong>最后总结一下核心思想：</strong></p><ul><li><strong>from</strong>：起点，从…出来</li><li><strong>to</strong>：方向，到一个箭头 →</li><li><strong>for</strong>：目的，为了…</li><li><strong>of</strong>：所属，…的</li><li><strong>with</strong>：伴随，和…一起</li></ul><p>希望这份讲义能帮助你更好地理解和使用这些介词！多读多练，你一定可以掌握它们！</p>]]></content>
    
    
    <summary type="html">英语介词第四讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第二讲</title>
    <link href="https://yjyrichard.github.io/posts/229b2f64.html"/>
    <id>https://yjyrichard.github.io/posts/229b2f64.html</id>
    <published>2025-08-25T11:59:05.703Z</published>
    <updated>2025-08-25T12:06:14.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第二讲"><a href="#介词第二讲" class="headerlink" title="介词第二讲"></a>介词第二讲</h1><h3 id="告别死记硬背！这样学介词才高效！"><a href="#告别死记硬背！这样学介词才高效！" class="headerlink" title="告别死记硬背！这样学介词才高效！"></a><strong>告别死记硬背！这样学介词才高效！</strong></h3><p>嗨，同学！</p><p>是不是觉得介词特别头疼？一个 <code>on</code> 一会儿是“在……上”，一会儿是“打开”，一会儿又是“继续”，到底想怎样？！</p><p>别急！今天我们就来解锁介词的终极密码。秘诀就是：<strong>抓住每个介词的“核心含义”！</strong></p><p>想象一下，每个介词都像一棵大树。它有一个最根本的<strong>树干（核心含义）</strong>，然后从这个树干上长出了很多<strong>树枝（不同的用法）</strong>。只要你抓住了树干，理解那些树枝就容易多啦！</p><p>我们的学习方法就是：<strong>从“看得见”的具象意思，到“想得到”的抽象意思。</strong></p><p>准备好了吗？我们开始吧！</p><hr><h4 id="1-on-核心：接触"><a href="#1-on-核心：接触" class="headerlink" title="1. on - 核心：接触"></a><strong>1. on - 核心：接触</strong></h4><p>想象一下，任何东西<strong>相互挨着、碰着</strong>，就是 <code>on</code> 的核心感觉。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>The book is <strong>on</strong> the desk.</em> (书在桌子上)<ul><li>【理解】书的底面和桌子的上表面<strong>接触</strong>了。</li></ul></li><li><em>My dog is <strong>on</strong> the box.</em> (我的狗在箱子上)<ul><li>【理解】狗狗和箱子表面<strong>接触</strong>了。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>Turn <strong>on</strong> the light.</em> (开灯)<ul><li>【引申】打开开关，让电路<strong>接触</strong>上了，所以灯亮了。</li></ul></li><li><em>Keep <strong>on</strong> reading.</em> / <em>Please go <strong>on</strong>.</em> (继续读 / 请继续)<ul><li>【引申】让你的行动和“阅读”这件事一直保持<strong>接触</strong>，不要断开，也就是“继续”。</li></ul></li></ul></li></ul><h4 id="2-off-核心：脱离、断开-和-on-正好相反"><a href="#2-off-核心：脱离、断开-和-on-正好相反" class="headerlink" title="2. off - 核心：脱离、断开 (和 on 正好相反)"></a><strong>2. off - 核心：脱离、断开</strong> (和 on 正好相反)</h4><p><code>off</code> 的感觉就是<strong>分开、离开、不接触</strong>了。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>Take <strong>off</strong> your shoes.</em> (脱掉你的鞋)<ul><li>【理解】让鞋子和你的脚<strong>脱离</strong>开。</li></ul></li><li><em>The apple fell <strong>off</strong> the tree.</em> (苹果从树上掉下来了)<ul><li>【理解】苹果和树枝<strong>脱离</strong>了。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>Turn <strong>off</strong> the light.</em> (关灯)<ul><li>【引申】切断开关，让电路<strong>断开</strong>了。</li></ul></li><li><em>He is <strong>off</strong> today.</em> (他今天休息/请假了)<ul><li>【引申】他从正常的工作状态中<strong>脱离</strong>出来了。</li></ul></li><li><em>This shirt is 20% <strong>off</strong>.</em> (这件衬衫打八折)<ul><li>【引申】从原价里<strong>拿掉/脱离</strong>20%的价钱。</li></ul></li></ul></li></ul><h4 id="3-at-核心：一个点-目标感"><a href="#3-at-核心：一个点-目标感" class="headerlink" title="3. at - 核心：一个点 (目标感)"></a><strong>3. at - 核心：一个点 (目标感)</strong></h4><p><code>at</code> 就像我们用手指着一个<strong>精确的点</strong>，可以是空间上的点，时间上的点，或者一个目标点。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>I am waiting <strong>at</strong> the bus stop.</em> (我在公交站等车)<ul><li>【理解】公交站是一个精确的<strong>地点</strong>。</li></ul></li><li><em>She is looking <strong>at</strong> me.</em> (她在看着我)<ul><li>【理解】她的目光聚焦在我这个<strong>点</strong>上。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>The movie starts <strong>at</strong> 8 PM.</em> (电影晚上8点开始)<ul><li>【引申】8点是时间线上的一个精确<strong>时间点</strong>。</li></ul></li><li><em>He shouted <strong>at</strong> me.</em> (他冲我大喊)<ul><li>【引申】我成了他喊叫的<strong>目标点</strong>。</li></ul></li><li><em>He is good <strong>at</strong> English.</em> (他擅长英语)<ul><li>【引申】在英语这个<strong>点</strong>（领域）上，他做得很好。</li></ul></li></ul></li></ul><h4 id="4-in-核心：在…内部-范围感"><a href="#4-in-核心：在…内部-范围感" class="headerlink" title="4. in - 核心：在…内部 (范围感)"></a><strong>4. in - 核心：在…内部 (范围感)</strong></h4><p><code>in</code> 强调在一个<strong>空间、范围或状态的里面</strong>。像被包围起来的感觉。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>My dog is <strong>in</strong> the box.</em> (我的狗在箱子里)<ul><li>【理解】在一个三维<strong>空间内部</strong>。</li></ul></li><li><em>I live <strong>in</strong> Beijing.</em> (我住在北京)<ul><li>【理解】在北京这个城市<strong>范围内部</strong>。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>My birthday is <strong>in</strong> May.</em> (我的生日在五月)<ul><li>【引申】在五月这个时间<strong>范围内部</strong>。</li></ul></li><li><em>He is <strong>in</strong> danger.</em> (他身处危险之中)<ul><li>【引申】他在“危险”这个<strong>状态内部</strong>。</li></ul></li><li><em>I am interested <strong>in</strong> music.</em> (我对音乐感兴趣)<ul><li>【引申】我的兴趣沉浸在音乐这个<strong>领域内部</strong>。</li></ul></li></ul></li></ul><h4 id="5-to-核心：方向和终点-去向"><a href="#5-to-核心：方向和终点-去向" class="headerlink" title="5. to - 核心：方向和终点 (去向)"></a><strong>5. to - 核心：方向和终点 (去向)</strong></h4><p><code>to</code> 就像一个箭头，明确地<strong>指向一个方向或目的地</strong>。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>I walk <strong>to</strong> school every day.</em> (我每天走着去学校)<ul><li>【理解】方向是学校，终点也是学校。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>Give it <strong>to</strong> me.</em> (把它给我)<ul><li>【引申】这个东西移动的<strong>终点</strong>是我。</li></ul></li><li><em>She is good <strong>to</strong> you.</em> (她对你很好)<ul><li>【引申】她的“好”这个行为，是<strong>朝向</strong>你的。</li></ul></li><li><em>From Monday <strong>to</strong> Friday.</em> (从周一到周五)<ul><li>【引申】时间范围的<strong>终点</strong>是周五。</li></ul></li></ul></li></ul><h4 id="6-from-核心：起点-来源-和-to-相对"><a href="#6-from-核心：起点-来源-和-to-相对" class="headerlink" title="6. from - 核心：起点 (来源) (和 to 相对)"></a><strong>6. from - 核心：起点 (来源)</strong> (和 to 相对)</h4><p><code>from</code> 也是一个箭头，但它表示<strong>从哪里出发，来源是哪里</strong>。</p><ul><li><p><strong>具象（看得见）：</strong></p><ul><li><em>He is <strong>from</strong> Russia.</em> (他来自俄罗斯)<ul><li>【理解】他的<strong>来源地</strong>是俄罗斯。</li></ul></li></ul></li><li><p><strong>抽象（想得到）：</strong></p><ul><li><em>I work <strong>from</strong> 9 a.m.</em> (我从早上9点开始工作)<ul><li>【引申】9点是工作的<strong>时间起点</strong>。</li></ul></li><li><em>I received a letter <strong>from</strong> my friend.</em> (我收到了朋友的来信)<ul><li>【引申】信件的<strong>来源</strong>是我的朋友。</li></ul></li></ul></li></ul><h4 id="7-for-核心：为了-目标-原因"><a href="#7-for-核心：为了-目标-原因" class="headerlink" title="7. for - 核心：为了 (目标/原因)"></a><strong>7. for - 核心：为了 (目标/原因)</strong></h4><p><code>for</code> 强调一个<strong>目的、目标或原因</strong>，可以翻译成“为了”、“给”。</p><ul><li><em>This gift is <strong>for</strong> you.</em> (这个礼物是给你的)<ul><li>【理解】你的<strong>目标</strong>是这个礼物。</li></ul></li><li><em>I bought it <strong>for</strong> my mom.</em> (我为我妈妈买了它)<ul><li>【理解】购买的<strong>目的</strong>是为了妈妈。</li></ul></li><li><em>Thanks <strong>for</strong> your help.</em> (谢谢你的帮助)<ul><li>【理解】感谢的<strong>原因</strong>是你的帮助。</li></ul></li><li><em>We are leaving <strong>for</strong> Shanghai.</em> (我们即将出发去上海)<ul><li>【理解】我们的<strong>目的地</strong>是上海。</li></ul></li></ul><h4 id="8-of-核心：属于-从属关系"><a href="#8-of-核心：属于-从属关系" class="headerlink" title="8. of - 核心：属于 (从属关系)"></a><strong>8. of - 核心：属于 (从属关系)</strong></h4><p><code>of</code> 最核心的意思就是<strong>“…的”</strong>，表示一部分与整体、所有者与物品之间的<strong>从属关系</strong>。</p><ul><li><em>the leg <strong>of</strong> the table</em> (桌子的一条腿)<ul><li>【理解】腿<strong>属于</strong>桌子。</li></ul></li><li><em>a friend <strong>of</strong> mine</em> (我的一个朋友)<ul><li>【理解】这个朋友<strong>属于</strong>“我的朋友们”这个圈子。</li></ul></li><li><em>It was kind <strong>of</strong> you to help me.</em> (你真好，帮助了我)<ul><li>【理解】“善良”这个品质是<strong>属于</strong>你的。</li></ul></li></ul><h4 id="9-with-核心：伴随-在一起"><a href="#9-with-核心：伴随-在一起" class="headerlink" title="9. with - 核心：伴随 (在一起)"></a><strong>9. with - 核心：伴随 (在一起)</strong></h4><p><code>with</code> 的感觉就是<strong>“和…一起”</strong>，可以是人、物或状态。</p><ul><li><em>I will go <strong>with</strong> you.</em> (我会和你一起去)<ul><li>【理解】人与人<strong>伴随</strong>。</li></ul></li><li><em>Write <strong>with</strong> a pen.</em> (用钢笔写字)<ul><li>【理解】写字这个动作有钢笔<strong>伴随</strong>，也就是“用”笔。</li></ul></li><li><em>a girl <strong>with</strong> big eyes</em> (一个大眼睛的女孩)<ul><li>【理解】“大眼睛”这个特征<strong>伴随</strong>着这个女孩。</li></ul></li></ul><h3 id="揭秘-about：不止是“关于”那么简单！"><a href="#揭秘-about：不止是“关于”那么简单！" class="headerlink" title="揭秘 about：不止是“关于”那么简单！"></a><strong>揭秘 about：不止是“关于”那么简单！</strong></h3><p>同学们好！我们来单独聊聊 <code>about</code> 这个词。你可能最熟悉它的意思是“关于”，但它其实还有“大约”、“到处”等意思，是不是有点晕？</p><p>别怕，<code>about</code> 也有一个核心含义，抓住它，一切都迎刃而解！</p><h4 id="about-核心：围绕着-around"><a href="#about-核心：围绕着-around" class="headerlink" title="about - 核心：围绕着 (around)"></a><strong>about - 核心：围绕着 (around)</strong></h4><p>你可以把 <code>about</code> 想象成<strong>一个中心点和它周围的一圈东西</strong>。所有的意思都是从这个“围绕感”引申出来的。</p><p><em>(可以想象成太阳和围绕它转的行星)</em></p><hr><p><strong>1. 引申义：“关于” (主题)</strong></p><p>这是最常见的用法，也是最经典的“围绕”引申。</p><ul><li><em>This is a book <strong>about</strong> China.</em> (这是一本关于中国的书。)<ul><li>【理解】想象“中国”是中心点，这本书里所有的内容，比如历史、文化、美食，都<strong>围绕着</strong>“中国”这个主题来写。</li></ul></li><li><em>Let’s talk <strong>about</strong> the movie.</em> (我们来聊聊这部电影吧。)<ul><li>【理解】我们的谈话将<strong>围绕着</strong>“电影”这个中心话题展开。</li></ul></li></ul><p><strong>2. 引申义：“大约” (近似)</strong></p><p>数字也可以有“中心点”！</p><ul><li><em>It’s <strong>about</strong> 9 o’clock.</em> (现在大约9点。)<ul><li>【理解】准确的时间就在9点这个时间点的<strong>周围</strong>，可能是8:58，也可能是9:02，总之就在附近。</li></ul></li><li><em>There are <strong>about</strong> 30 people here.</em> (这里大约有30人。)<ul><li>【理解】实际人数在30这个数字的<strong>周围</strong>徘徊。</li></ul></li></ul><p><strong>3. 引申义：“到处，四处” (空间)</strong></p><p>这是 <code>about</code> 最接近它兄弟 <code>around</code> 的一个意思。</p><ul><li><em>The kids are running <strong>about</strong> in the park.</em> (孩子们在公园里到处跑。)<ul><li>【理解】他们的活动范围<strong>围绕着</strong>公园这个大区域，没有固定的方向，四处乱窜。</li></ul></li><li><em>He looked <strong>about</strong> the room.</em> (他环顾了一下房间。)<ul><li>【理解】他的目光在房间里<strong>绕了一圈</strong>，到处看了看。</li></ul></li></ul><p><strong>4. 固定搭配：“即将” (be about to)</strong></p><p>这是一个非常常用的词组，也可以用“围绕”的感觉来理解。</p><ul><li><em>Hurry up! The bus is <strong>about to</strong> leave.</em> (快点！公交车马上就要开了。)<ul><li>【理解】我们已经无限接近“开车”这个时间点了，就在这个时间点的<strong>周围</strong>，一触即发。表示“即将、正要”。</li></ul></li></ul><hr><p><strong>小结一下：</strong></p><p>下次看到 <code>about</code>，脑海里先浮现出“<strong>围绕着</strong>”这个画面。</p><ul><li>围绕一个<strong>话题</strong>说事，就是“<strong>关于</strong>”。</li><li>围绕一个<strong>数字</strong>上下浮动，就是“<strong>大约</strong>”。</li><li>围绕一个<strong>空间</strong>四处活动，就是“<strong>到处</strong>”。</li><li>围绕一个<strong>时间点</strong>即将发生，就是“<strong>即将</strong>”。</li></ul><p>这样一来，是不是感觉 <code>about</code> 的所有意思都被你串起来了？</p><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>同学们，下次再遇到一个“脸熟但意生”的介词时，别急着去翻字典查它有多少种中文意思。</p><p>试着问自己：</p><ol><li><strong>它的核心含义是什么？</strong> (on-接触, at-点, in-内部…)</li><li><strong>这句话里，它是看得见的具体用法，还是想得到的抽象用法？</strong></li><li><strong>我能从核心含义把它推导出来吗？</strong></li></ol><p>多这样练习，你就会发现，介词的学习不再是死记硬背，而是一个有趣的逻辑推理游戏！加油！</p>]]></content>
    
    
    <summary type="html">英语介词第二讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第一讲</title>
    <link href="https://yjyrichard.github.io/posts/128dc3bc.html"/>
    <id>https://yjyrichard.github.io/posts/128dc3bc.html</id>
    <published>2025-08-25T11:59:05.570Z</published>
    <updated>2025-08-25T12:06:14.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第一讲"><a href="#介词第一讲" class="headerlink" title="介词第一讲"></a>介词第一讲</h1><h3 id="介词到底是干啥的？——-你的语法小帮手！"><a href="#介词到底是干啥的？——-你的语法小帮手！" class="headerlink" title="介词到底是干啥的？—— 你的语法小帮手！"></a><strong>介词到底是干啥的？—— 你的语法小帮手！</strong></h3><p>嗨，同学们！今天我们来认识一个英语语法里非常重要的小伙伴——<strong>介词 (Preposition)</strong>。</p><p>你可能会觉得它很小，不起眼，但没有它，很多句子都会变得“奇奇怪怪”，甚至完全看不懂。不信你看：</p><blockquote><p>I walk <strong><em> the mountains </em></strong> my friends <em>_</em> summer.</p></blockquote><p>这句话是不是缺了点什么？感觉信息都断开了。现在我们把一些小词填进去：</p><blockquote><p>I walk <strong>in</strong> the mountains <strong>with</strong> my friends <strong>in</strong> summer.<br>(夏天，我和朋友们在山里散步。)</p></blockquote><p>哇，意思一下子就完整清晰了！这些像 <strong>in, with</strong> 一样的小词，就是我们今天的主角——介词。</p><h4 id="一、-介词的核心工作：当“红娘”，介绍关系！"><a href="#一、-介词的核心工作：当“红娘”，介绍关系！" class="headerlink" title="一、 介词的核心工作：当“红娘”，介绍关系！"></a><strong>一、 介词的核心工作：当“红娘”，介绍关系！</strong></h4><p>你可以把介词想象成一个“关系介绍人”或者“胶水”。它的主要工作就是：</p><p><strong>把一个名词（或代词等）“介绍”给前面的另一个词，说明它们之间是什么关系。</strong></p><p>这个关系可以是关于 <strong>时间、地点、方式</strong> 等等。</p><ul><li><strong>study in the morning</strong> (在早上学习)<ul><li>介词 <code>in</code> 把 <code>the morning</code> (名词) 介绍给了 <code>study</code> (动词)，说明了学习的【<strong>时间</strong>】。</li></ul></li><li><strong>the boy in the room</strong> (在房间里的男孩)<ul><li>介词 <code>in</code> 把 <code>the room</code> (名词) 介绍给了 <code>the boy</code> (名词)，说明了男孩的【<strong>地点</strong>】。</li></ul></li><li><strong>a gift for you</strong> (一份给你的礼物)<ul><li>介词 <code>for</code> 把 <code>you</code> (代词) 介绍给了 <code>a gift</code> (名词)，说明了礼物的【<strong>对象/目的</strong>】。</li></ul></li></ul><p>看，介词就像一个桥梁，把词语们紧密地连接在了一起！</p><h4 id="二、-介词的三大“朋友圈”"><a href="#二、-介词的三大“朋友圈”" class="headerlink" title="二、 介词的三大“朋友圈”"></a><strong>二、 介词的三大“朋友圈”</strong></h4><p>介词非常喜欢交朋友，它最常和这三类词一起玩耍：<strong>动词、名词、形容词</strong>。</p><h5 id="朋友圈1：动词-Verb-介词-名词"><a href="#朋友圈1：动词-Verb-介词-名词" class="headerlink" title="朋友圈1：动词 (Verb) + 介词 + 名词"></a><strong>朋友圈1：动词 (Verb) + 介词 + 名词</strong></h5><p>这是最常见的一种组合。介词在这里，是用来<strong>补充说明“动作”的细节</strong>。</p><p>同一个动词，搭配不同的介词，意思会大不相同哦！</p><p>想象一下你家门口有座房子(the house)，你要“走”(walk)：</p><ul><li><strong>walk into the house</strong> (走进房子里) -&gt; <code>into</code> 表示进入内部</li><li><strong>walk towards the house</strong> (朝着房子走去) -&gt; <code>towards</code> 表示方向，不一定进去</li><li><strong>walk from the house</strong> (从房子里走出来) -&gt; <code>from</code> 表示起点</li><li><strong>walk around the house</strong> (绕着房子走) -&gt; <code>around</code> 表示环绕</li><li><strong>walk past the house</strong> (走过房子) -&gt; <code>past</code> 表示经过</li></ul><p><strong>更多例子：</strong></p><ul><li>Please <strong>look at</strong> the blackboard. (请看黑板。)</li><li>I <strong>listen to</strong> music every day. (我每天听音乐。)</li><li>He <strong>put</strong> the book <strong>on</strong> the desk. (他把书放在桌子上。)</li></ul><h5 id="朋友圈2：名词-Noun-介词-名词"><a href="#朋友圈2：名词-Noun-介词-名词" class="headerlink" title="朋友圈2：名词 (Noun) + 介词 + 名词"></a><strong>朋友圈2：名词 (Noun) + 介词 + 名词</strong></h5><p>当介词夹在两个名词中间时，它用来<strong>说明这两个名词之间的关系</strong>。</p><p>比如，我们都想听听关于北京(Beijing)的故事(stories)：</p><ul><li><strong>stories of Beijing</strong> (北京的故事) -&gt; <code>of</code> 表示“……的”，内容就是北京本身。</li><li><strong>stories from Beijing</strong> (来自北京的故事) -&gt; <code>from</code> 表示来源，故事是从北京传来的。</li><li><strong>stories about Beijing</strong> (关于北京的故事) -&gt; <code>about</code> 表示主题，故事是围绕北京展开的。</li></ul><p><strong>更多例子：</strong></p><ul><li>This is <strong>the key to</strong> the door. (这是这扇门的钥匙。)</li><li>I want <strong>a cup of</strong> tea. (我想要一杯茶。)</li><li>The <strong>book on</strong> the table is mine. (桌上的那本书是我的。)</li></ul><h5 id="朋友圈3：形容词-Adjective-介词-名词"><a href="#朋友圈3：形容词-Adjective-介词-名词" class="headerlink" title="朋友圈3：形容词 (Adjective) + 介词 + 名词"></a><strong>朋友圈3：形容词 (Adjective) + 介词 + 名词</strong></h5><p>有时候，一个形容词意思不够完整，需要介词来帮忙，<strong>连接它所描述的对象</strong>。</p><p>比如，我们都说 <code>good</code> (好)，但是怎么个好法呢？</p><ul><li>He is <strong>good at</strong> learning. (他擅长学习。) -&gt; <code>good at</code> 表示“擅长于……”</li><li>It is <strong>good for</strong> learning. (这对学习有好处。) -&gt; <code>good for</code> 表示“对……有益”</li><li>She is <strong>good to</strong> you. (她对你很好。) -&gt; <code>good to</code> 表示“对……友好”</li></ul><p><strong>更多例子：</strong></p><ul><li>I’m <strong>afraid of</strong> spiders. (我害怕蜘蛛。)</li><li>She is <strong>interested in</strong> history. (她对历史感兴趣。)</li><li>My hometown is <strong>famous for</strong> its food. (我的家乡因美食而闻名。)</li></ul><h4 id="三、-如何掌握介词？两大秘诀！"><a href="#三、-如何掌握介词？两大秘诀！" class="headerlink" title="三、 如何掌握介词？两大秘诀！"></a><strong>三、 如何掌握介词？两大秘诀！</strong></h4><p>看到这里，你是不是觉得介词既重要又有点复杂？别担心，掌握它有两个秘诀：</p><p><strong>1. 理解核心含义</strong><br>很多介词都有一个基本的空间或时间意义。比如：</p><ul><li><code>in</code>：在……内部 (in the box, in May)</li><li><code>on</code>：在……表面 (on the table, on Monday)</li><li><code>under</code>：在……下方 (under the bed)<br>先理解这些基本意思，再慢慢体会它们的引申用法。</li></ul><p><strong>2. 记住“好朋友组合”（习惯搭配）</strong><br>有些介词和特定动词、名词、形容词是“铁哥们”，总是打包出现，我们称之为“固定搭配”。比如 <code>listen to</code>, <code>good at</code>, <code>be interested in</code>。<br>对于这些组合，最好的办法就是——<strong>把它们当作一个词组来记！</strong> 多读、多背、多用，自然就熟悉啦。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a><strong>总结一下</strong></h4><p><strong>介词的本质，就是“介绍”一个名词给前面的词（动、名、形），来表示它们之间的关系。</strong></p><p>它就像句子里的“万能胶水”，让语言变得精确、生动、有逻辑。</p><p>现在，再回头看看这个句子，你是不是彻底明白了每个小词的作用？</p><blockquote><p>I walk <strong>in</strong> (地点) the mountains <strong>with</strong> (方式/陪伴) my friends <strong>in</strong> (时间) summer.</p></blockquote>]]></content>
    
    
    <summary type="html">英语介词第一讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第八讲</title>
    <link href="https://yjyrichard.github.io/posts/f7534411.html"/>
    <id>https://yjyrichard.github.io/posts/f7534411.html</id>
    <published>2025-08-25T11:59:05.456Z</published>
    <updated>2025-08-25T12:06:14.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第八讲"><a href="#介词第八讲" class="headerlink" title="介词第八讲"></a>介词第八讲</h1><h3 id="between-among-across-along-through"><a href="#between-among-across-along-through" class="headerlink" title="between, among, across, along, through"></a><code>between</code>, <code>among</code>, <code>across</code>, <code>along</code>, <code>through</code></h3><p>我们来学习第六组介词：<code>between</code>, <code>among</code>, <code>across</code>, <code>along</code>, <code>through</code>。这组词主要描述物体之间的<strong>位置关系</strong>和<strong>动态移动</strong>，理解它们的核心画面感非常重要。</p><hr><h3 id="词义深度解析"><a href="#词义深度解析" class="headerlink" title="词义深度解析"></a>词义深度解析</h3><h4 id="1-between"><a href="#1-between" class="headerlink" title="1. between"></a>1. <strong>between</strong></h4><ul><li><strong>词源解析</strong>: <code>be</code> (处于) + <code>tween</code> (源自古英语 <code>twain</code>，意为“二”)。字面意思就是“<strong>处于二者之中</strong>”。</li><li><p><strong>核心含义</strong>: <strong>在两者之间</strong>。它强调的是明确、独立的个体之间的关系。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示空间、时间、范围</strong>: 在两个明确的点之间。</p><ul><li><em>The baby is sleeping <strong>between</strong> his parents.</em><br>宝宝睡在他父母的中间。</li><li><em>The shop is open <strong>between</strong> 9 a.m. and 5 p.m.</em><br>这家商店的营业时间是上午9点到下午5点。</li><li><em>She weighs <strong>between</strong> 55 and 60 kilograms.</em><br>她的体重在55到60公斤之间。</li></ul></li><li><p><strong>表示关系、联系、选择</strong>:</p><ul><li><em>This is a secret <strong>between</strong> you and me.</em><br>这是你我之间的秘密。</li><li><em>You have to choose <strong>between</strong> going to college and finding a job.</em><br>你必须在读大学和找工作之间做出选择。</li></ul></li><li><p><strong>特殊用法（三者或以上）</strong>: 当这三个或以上的个体是<strong>各自独立、关系明确</strong>时，也可以用 <code>between</code>。</p><ul><li><em>The treaty was signed <strong>between</strong> the three countries.</em><br>该条约是在这三个国家之间签订的。（强调每个国家之间的双边关系）</li><li><em>There are regular flights <strong>between</strong> London, Paris, and New York.</em><br>在伦敦、巴黎和纽约之间有固定航班。（强调任意两点间的航线）</li></ul></li></ol></li></ul><hr><h4 id="2-among"><a href="#2-among" class="headerlink" title="2. among"></a>2. <strong>among</strong></h4><ul><li><strong>词源解析</strong>: <code>among</code> 来自古英语，意为“在一群人中”。可以谐音记忆为“茫”，想象“<strong>在茫茫人海中</strong>”。</li><li><p><strong>核心含义</strong>: <strong>在三者或三者以上的人或物之中</strong>。它强调的是被一个群体所<strong>包围</strong>，个体身份不那么突出。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示位置</strong>: 在…（群体）中间</p><ul><li><em>I saw a familiar face <strong>among</strong> the crowd.</em><br>我在人群中看到了一个熟悉的面孔。</li><li><em>The small cottage is hidden <strong>among</strong> the trees.</em><br>那座小木屋隐藏在树林中。</li></ul></li><li><p><strong>表示分配</strong>: 在…（群体）中分配</p><ul><li><em>He divided the cake <strong>among</strong> the kids.</em><br>他把蛋糕分给了孩子们。</li></ul></li><li><p><strong>表示“其中之一”或“作为…的一员”</strong>:</p><ul><li><em>He is <strong>among</strong> the greatest writers of his generation.</em><br>他是他那一代人中最伟大的作家之一。</li><li><em>Don’t worry, you are <strong>among</strong> friends now.</em><br>别担心，你现在和朋友们在一起（你是我们中的一员）。</li></ul></li></ol></li></ul><hr><h4 id="3-across"><a href="#3-across" class="headerlink" title="3. across"></a>3. <strong>across</strong></h4><ul><li><strong>词源解析</strong>: <code>a</code> + <code>cross</code> (十字)。想象画一个十字，有一条线<strong>横穿</strong>另一条线。</li><li><p><strong>核心含义</strong>: <strong>横过，穿过（一个平面或表面）</strong>；在…的对面。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示动态的“横穿”</strong>: 从一侧到另一侧（在表面上移动）。</p><ul><li><em>Be careful when you walk <strong>across</strong> the road.</em><br>过马路时要小心。</li><li><em>He swam <strong>across</strong> the river.</em><br>他游过了河。</li></ul></li><li><p><strong>表示静态的“在对面”</strong>:</p><ul><li><em>The library is just <strong>across</strong> the road from the post office.</em><br>图书馆就在邮局的对面。</li></ul></li><li><p><strong>表示“遍及”</strong>: 覆盖整个区域。</p><ul><li><em>His fame has spread <strong>across</strong> the whole country.</em><br>他的名声传遍了全国。</li></ul></li><li><p><strong>表示身体动作</strong>:</p><ul><li><em>She folded her arms <strong>across</strong> her chest.</em><br>她双臂交叉抱在胸前。</li></ul></li></ol></li></ul><hr><h4 id="4-along"><a href="#4-along" class="headerlink" title="4. along"></a>4. <strong>along</strong></h4><ul><li><strong>词源解析</strong>: <code>a</code> + <code>long</code> (长的)。可以想象“<strong>沿着一条长长的东西</strong>”。</li><li><p><strong>核心含义</strong>: <strong>沿着…，顺着…</strong>。它强调的是与某个线条（如道路、河流、海岸线）平行的移动或排列。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示移动方向</strong>: 沿着…走</p><ul><li><em>We had a romantic walk <strong>along</strong> the beach at sunset.</em><br>我们在日落时分沿着海滩浪漫地散步。</li><li><em>Go <strong>along</strong> this road and you’ll find the station.</em><br>沿着这条路走，你就能找到车站。</li></ul></li><li><p><strong>表示位置</strong>: 沿着…分布</p><ul><li><em>There are beautiful trees planted <strong>along</strong> the river.</em><br>沿河种着美丽的树。</li></ul></li><li><p><strong>常用短语</strong>:</p><ul><li><strong>along with</strong>: 和…一起（= together with）<ul><li><em>You can take him <strong>along with</strong> you.</em> 你可以把他一起带上。</li></ul></li><li><strong>come along</strong>: 过来；进展<ul><li><em>Come <strong>along</strong>, we’re late!</em> 快点，我们迟到了！</li></ul></li></ul></li></ol></li></ul><hr><h4 id="5-through"><a href="#5-through" class="headerlink" title="5. through"></a>5. <strong>through</strong></h4><ul><li><strong>词源解析</strong>: 核心是“穿透”。想象一个隧道，从一端<strong>进入</strong>，从另一端<strong>出来</strong>。</li><li><p><strong>核心含义</strong>: <strong>穿过（一个三维空间或物体）；贯穿（时间）；通过（某种方式）</strong>。</p></li><li><p><strong>详细用法与例句</strong>:</p><ol><li><p><strong>表示空间上的“穿过”</strong>: 从内部穿过一个立体空间。</p><ul><li><em>The train went <strong>through</strong> a long tunnel.</em><br>火车穿过了一条长长的隧道。</li><li><em>We walked <strong>through</strong> the dense forest.</em><br>我们徒步穿过了茂密的森林。</li></ul></li><li><p><strong>表示时间的“贯穿始终”</strong>: 从头到尾</p><ul><li><em>It rained all <strong>through</strong> June and July.</em><br>整个六月和七月都在下雨。</li><li><em>He worked <strong>through</strong> the night to finish the report.</em><br>他通宵工作以完成报告。</li></ul></li><li><p><strong>表示方式、媒介、原因</strong>: 通过…</p><ul><li><em>We sold the bike <strong>through</strong> the internet.</em><br>我们通过互联网卖掉了自行车。</li><li><em>I got this job <strong>through</strong> a friend.</em><br>我通过一个朋友得到了这份工作。</li></ul></li><li><p><strong>表示完成或经历</strong>:</p><ul><li><em>Are you <strong>through</strong> with that book yet?</em><br>那本书你看完了吗？</li><li><em>She has been <strong>through</strong> a lot this year.</em><br>她今年经历了很多。</li></ul></li></ol></li></ul><hr><h3 id="巩固练习-Consolidation-Exercises"><a href="#巩固练习-Consolidation-Exercises" class="headerlink" title="巩固练习 (Consolidation Exercises)"></a>巩固练习 (Consolidation Exercises)</h3><p>请用 <code>between</code>, <code>among</code>, <code>across</code>, <code>along</code>, <code>through</code> 填空。</p><ol><li>The children were happy to find a secret path <strong><strong>_</strong></strong> the tall trees in the forest.</li><li>I love to ride my bike <strong><strong>_</strong></strong> the quiet country lanes on weekends.</li><li>The negotiations <strong><strong>_</strong></strong> the two companies finally reached an agreement.</li><li>She could see her reflection in the shop window as she walked <strong><strong>_</strong></strong> the street.</li><li>He managed to get the job <strong><strong>_</strong></strong> his excellent interview performance.</li><li>There is a beautiful old bridge <strong><strong>_</strong></strong> the river.</li><li>She is considered one of the best singers <strong><strong>_</strong></strong> her contemporaries.</li><li>We drove <strong><strong>_</strong></strong> the city center without stopping.</li><li>This secret must remain strictly <strong><strong>_</strong></strong> the three of us.</li><li>The teacher distributed the sweets <strong><strong>_</strong></strong> all the students in the class.</li></ol><hr><h3 id="答案与解析-Answers-and-Explanations"><a href="#答案与解析-Answers-and-Explanations" class="headerlink" title="答案与解析 (Answers and Explanations)"></a>答案与解析 (Answers and Explanations)</h3><ol><li><strong>through</strong>. 句意：孩子们很高兴在森林的高树中找到一条秘密小径。树林是三维空间，从中间穿过，所以用 <code>through</code>。</li><li><strong>along</strong>. 句意：我喜欢在周末沿着宁静的乡间小路骑自行车。<code>along the lanes</code> 指的是沿着小路这条线移动。</li><li><strong>between</strong>. 句意：两家公司之间的谈判最终达成了一项协议。<code>two companies</code> 是两个明确的个体，所以用 <code>between</code>。</li><li><strong>along/across</strong>. 都可以，但含义略有不同。<code>along the street</code> (沿着街道走) 更侧重于与街道平行的移动。<code>across the street</code> (穿过街道) 侧重于从一侧到另一侧。根据语境“看到橱窗里的倒影”，<code>along</code> 更为贴切。</li><li><strong>through</strong>. 句意：他凭借出色的面试表现成功得到了这份工作。这里 <code>through</code> 表示“通过…方式或手段”。</li><li><strong>across</strong>. 句意：河上有一座美丽的古桥。桥是“横跨”在河上的，连接两岸，用 <code>across</code>。</li><li><strong>among</strong>. 句意：她被认为是同时代人中最好的歌手之一。<code>contemporaries</code> (同时代人) 是一个群体，她是其中一员，用 <code>among</code>。</li><li><strong>through</strong>. 句意：我们开车径直穿过了市中心。市中心是一个区域（可以看作三维空间），从中间穿过，用 <code>through</code>。</li><li><strong>between</strong>. 句意：这个秘密必须严格地在我们三个人之间保守。虽然是三个人，但强调的是三者之间各自独立明确的关系，这是 <code>between</code> 的一个特殊用法。用 <code>among</code> 也可以，但 <code>between</code> 更强调这种小团体内部的保密性。</li><li><strong>among</strong>. 句意：老师把糖果分给了班上所有的学生。<code>all the students</code> 是一个群体，在他们中间分配，用 <code>among</code>。</li></ol>]]></content>
    
    
    <summary type="html">英语介词第八讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>英语介词第九讲</title>
    <link href="https://yjyrichard.github.io/posts/8d9e654e.html"/>
    <id>https://yjyrichard.github.io/posts/8d9e654e.html</id>
    <published>2025-08-25T11:59:05.440Z</published>
    <updated>2025-08-25T12:06:14.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介词第九讲"><a href="#介词第九讲" class="headerlink" title="介词第九讲"></a>介词第九讲</h1><h3 id="during-since-until-past-as-like-despite"><a href="#during-since-until-past-as-like-despite" class="headerlink" title="during ,since ,until,past ,as,like,despite"></a>during ,since ,until,past ,as,like,despite</h3><p>大家好！</p><p>介词 (Preposition) 是英语中连接名词、代名词或短语到句子其他部分的小词，它们虽然短小，却是表达精确意思的关键。这份讲义将带领大家深入学习几个非常实用但又容易混淆的介词，帮助你更自信地使用它们。</p><hr><h3 id="第一部分：表示“时间”的介词"><a href="#第一部分：表示“时间”的介词" class="headerlink" title="第一部分：表示“时间”的介词"></a><strong>第一部分：表示“时间”的介词</strong></h3><h4 id="1-during-在…期间"><a href="#1-during-在…期间" class="headerlink" title="1. during (在…期间)"></a><strong>1. during (在…期间)</strong></h4><ul><li><strong>核心含义</strong>：表示某事发生在<strong>某个特定的时间段之内</strong>。它强调的是“过程”，但不一定占满整个过程。</li><li><p><strong>用法</strong>：<code>during + 表示一段时间的名词</code> (如 the night, the exam, the meeting)</p></li><li><p><strong>例句解析</strong>：</p><ul><li><code>They work **during the night** and sleep by day.</code><ul><li>他们在<strong>夜晚这段时间内</strong>工作，在白天睡觉。</li></ul></li><li><code>You&#39;re not allowed to talk **during the exam**.</code><ul><li>在<strong>考试的整个过程期间</strong>，你是不允许聊天的。</li></ul></li><li><code>I woke up several times **during the night**.</code><ul><li>在<strong>夜里这段时间</strong>，我醒了好几次。（不是一直醒着，而是在这个时间段内发生了几次）</li></ul></li></ul></li></ul><h4 id="2-since-自从…-vs-until-直到…为止"><a href="#2-since-自从…-vs-until-直到…为止" class="headerlink" title="2. since (自从…) vs. until (直到…为止)"></a><strong>2. since (自从…) vs. until (直到…为止)</strong></h4><p>这是一对在时间概念上相对的词，都涉及一段时间，但方向相反。</p><ul><li><p><strong>since (自从…)</strong></p><ul><li><strong>核心含义</strong>：表示动作或状态从<strong>过去某个时间点开始，并一直持续到现在</strong>。它是一个“起点”。</li><li><strong>用法</strong>：常与现在完成时 (have/has + Vpp) 一起使用。</li><li><strong>例句解析</strong>：<ul><li><code>I have never seen you **since last month**.</code><ul><li><strong>自从上个月</strong>这个时间点开始，一直到现在，我都没见过你。</li></ul></li><li><code>Tom has been in Hangzhou **since 2018**.</code><ul><li><strong>自从2018年</strong>开始，汤姆就一直在杭州了（这个状态持续至今）。</li></ul></li></ul></li></ul></li><li><p><strong>until / till (直到…为止)</strong></p><ul><li><strong>核心含义</strong>：表示一个动作或状态<strong>持续到某个时间点为止，然后发生变化</strong>。它是一个“终点”。</li><li><strong>用法</strong>：<code>till</code> 与 <code>until</code> 意思一样，但 <code>until</code> 更正式。特别注意 <code>not...until</code> 的结构，意为“直到…才…”。</li><li><strong>例句解析</strong>：<ul><li><code>Jerry ate a lot of cheese **until Tom came back**.</code><ul><li>杰瑞吃奶酪的动作一直持续，<strong>终点是“汤姆回来”</strong>。汤姆回来后，他可能就不吃了。</li></ul></li><li><code>They didn&#39;t sleep **until their mother turned off the light**.</code><ul><li>他们“不睡觉”的状态一直持续，<strong>直到妈妈关灯才结束</strong>。换句话说，他们<strong>直到妈妈关灯后才开始睡觉</strong>。</li></ul></li></ul></li></ul></li></ul><h4 id="3-past-超过，晚于"><a href="#3-past-超过，晚于" class="headerlink" title="3. past (超过，晚于)"></a><strong>3. past (超过，晚于)</strong></h4><ul><li><strong>核心含义</strong>：表示在时间、空间或程度上“经过、超过、晚于”某个点。它的同根词是 <code>pass</code> (经过)。</li><li><strong>用法</strong>：<ol><li><strong>表示时间（钟点）</strong>：意为“…点过…分”。<ul><li><code>half **past** 10</code> → 10点<strong>过</strong>了半小时 → 10:30</li><li><code>20 **past** 9</code> → 9点<strong>过</strong>了20分钟 → 9:20</li></ul></li><li><strong>表示一段时期</strong>：常用于 <code>in the past ... years/days</code> 结构中，意为“在过去的…”。<ul><li><code>The temperature worldwide has risen **in the past 100 years**.</code><ul><li>在<strong>过去的100年里</strong>，全球气温已经升高了。</li></ul></li></ul></li><li><strong>表示程度</strong>：意为“超出了…的阶段”，表示不再关心或受影响。<ul><li><code>Do what you want, I&#39;m **past caring**.</code><ul><li>你想干嘛就干嘛吧，我已经<strong>过了会在意的那个阶段了</strong>（我巳经不在乎了）。</li></ul></li></ul></li></ol></li></ul><hr><h3 id="第二部分：表示“比较”与“身份”的介词"><a href="#第二部分：表示“比较”与“身份”的介词" class="headerlink" title="第二部分：表示“比较”与“身份”的介词"></a><strong>第二部分：表示“比较”与“身份”的介词</strong></h3><h4 id="4-as-如同；作为"><a href="#4-as-如同；作为" class="headerlink" title="4. as (如同；作为)"></a><strong>4. as (如同；作为)</strong></h4><p><code>as</code> 的用法非常丰富，主要分为两大类：</p><ul><li><p><strong>用法一：表示比较（和…一样；如同）</strong></p><ul><li><strong>核心含“像…一样”的意味，用于比较两者在某方面是相同的。</strong></li><li><strong>常见结构</strong>：<ul><li><code>as ... as ...</code>：像…一样…</li><li><code>as soon as</code>：一…就… (像…一样快)</li><li><code>as long as</code>：只要 (像…一样长的时间)</li><li><code>such as</code>：例如</li></ul></li><li><strong>例句解析</strong>：<ul><li><code>She is **as tall as** her mother.</code><ul><li>她和她妈妈<strong>一样高</strong>。</li></ul></li><li><code>Her skin is **as soft as** a baby&#39;s.</code><ul><li>她的皮肤<strong>像</strong>婴儿的皮肤<strong>一样</strong>柔软。</li></ul></li></ul></li></ul></li><li><p><strong>用法二：表示身份或功能（作为；以…的身份）</strong></p><ul><li><strong>核心含义</strong>：指某人或某物所<strong>扮演的角色、具备的身份或发挥的功能</strong>。这是一个客观事实。</li><li><strong>常见结构</strong>：<ul><li><code>as a father/teacher</code>：作为一个父亲/老师</li><li><code>as a result</code>：结果是</li><li><code>be famous as ...</code>：作为…而闻名</li></ul></li><li><strong>例句解析</strong>：<ul><li><code>**As a father**, he must protect his family.</code><ul><li><strong>以父亲这个身份</strong>，他必须保护他的家人。（他就是父亲）</li></ul></li><li><code>She works **as a waitress**.</code><ul><li>她的工作<strong>是服务员</strong>。（她的职业身份是服务员）</li></ul></li><li><code>Michael Tyson was famous **as a boxer**.</code><ul><li>泰森<strong>作为一名拳击手</strong>而闻名。（他的闻名身份是拳击手）</li></ul></li></ul></li></ul></li></ul><h4 id="5-like-像，貌似"><a href="#5-like-像，貌似" class="headerlink" title="5. like (像，貌似)"></a><strong>5. like (像，貌似)</strong></h4><ul><li><strong>核心含义</strong>：表示两者<strong>外表、行为或特征上的“相似”</strong>，但它们本质上不是同一样事物。强调的是“看起来像”。</li><li><strong>用法</strong>：<code>like + 名词/代名词</code></li><li><strong>例句解析</strong>：<ul><li><code>He looks **like** his father.</code><ul><li>他看<strong>上去像</strong>他爸爸。（只是长得像，他不是他爸爸）</li></ul></li></ul></li></ul><h4 id="⭐-核心区分：Like-vs-As-重点！"><a href="#⭐-核心区分：Like-vs-As-重点！" class="headerlink" title="⭐ 核心区分：Like vs. As (重点！)"></a><strong>⭐ 核心区分：Like vs. As (重点！)</strong></h4><p>这是最容易混淆的一点，请看下面的例子：</p><ul><li><p><code>He teaches us **like** a teacher.</code></p><ul><li>他教我们的时候<strong>像一位老师一样</strong>。（说明他的教学方式、态度很专业，但他<strong>可能不是</strong>一名真正的老师，也许是个学长或朋友。）</li><li><code>like</code> 在这里表示<strong>方式上的相似</strong>。</li></ul></li><li><p><code>He teaches us **as** a teacher.</code></p><ul><li>他<strong>作为一名老师</strong>教我们。（说明他的<strong>真实身份就是</strong>老师，这是他的职业。）</li><li><code>as</code> 在这里表示<strong>身份和职能</strong>。</li></ul></li></ul><hr><h3 id="第三部分：表示“转折”关系的介词"><a href="#第三部分：表示“转折”关系的介词" class="headerlink" title="第三部分：表示“转折”关系的介词"></a><strong>第三部分：表示“转折”关系的介词</strong></h3><h4 id="6-despite-尽管，虽然"><a href="#6-despite-尽管，虽然" class="headerlink" title="6. despite (尽管，虽然)"></a><strong>6. despite (尽管，虽然)</strong></h4><ul><li><strong>核心含义</strong>：引出一个<strong>预期之外</strong>或<strong>与主句情况相反</strong>的条件。意思是“虽然有这件事，但另一件事仍然发生了”。</li><li><strong>用法</strong>：<code>despite + 名词 / 动名词 (-ing)</code>。它和 <code>in spite of</code> 意思完全相同。</li><li><strong>注意</strong>：<code>despite</code> 后面不能直接跟一个完整的句子（主语+动词）。</li><li><strong>例句解析</strong>：<ul><li><code>I still enjoyed the week **despite the bad weather**.</code><ul><li><strong>尽管天气不好</strong>（这是一个负面条件），我这一周仍然过得很愉快（这是一个正面的结果）。</li></ul></li><li><code>**Despite saying sorry** to her friends, most of them still don&#39;t want to forgive her.</code><ul><li><strong>尽管她说了对不起</strong>，但她的朋友们大部分还是不想原谅她。</li></ul></li><li><code>He laughed **despite himself**.</code><ul><li>这是一个固定用法，意为“情不自禁地”。<strong>尽管他自己可能想控制住（不笑）</strong>，但他还是笑了。</li></ul></li></ul></li></ul><hr><p><strong>总结</strong></p><p>希望这份讲义能帮助你更好地理解和运用这些介词。学习语言的最好方法就是不断地在阅读和口语中观察和练习。祝你学习进步！</p><hr><h3 id="介词用法专项练习题"><a href="#介词用法专项练习题" class="headerlink" title="介词用法专项练习题"></a><strong>介词用法专项练习题</strong></h3><p><strong>请从 A, B, C, D 四个选项中选择最合适的一个填入空白处。</strong></p><ol><li><p>Please don’t use your phone <strong>__</strong> the concert. It’s distracting to the performers.<br>A. since<br>B. during<br>C. until<br>D. past</p></li><li><p><strong>__</strong> the difficulty of the task, he managed to complete it ahead of schedule.<br>A. Despite<br>B. As<br>C. Like<br>D. Until</p></li><li><p>She has been working <strong>__</strong> a manager at this company for five years.<br>A. like<br>B. past<br>C. as<br>D. since</p></li><li><p>My little sister sometimes acts <strong>__</strong> a grown-up, telling everyone what to do.<br>A. as<br>B. like<br>C. since<br>D. during</p></li><li><p>I haven’t heard from him <strong>__</strong> he moved to Canada last year.<br>A. until<br>B. during<br>C. despite<br>D. since</p></li><li><p>The children were not allowed to watch TV <strong>__</strong> they finished their homework.<br>A. past<br>B. until<br>C. since<br>D. like</p></li><li><p>It’s already half <strong>__</strong> ten; we are going to be late for the meeting!<br>A. since<br>B. despite<br>C. past<br>D. as</p></li><li><p>He is famous <strong>__</strong> an actor, but his true passion is painting.<br>A. like<br>B. as<br>C. past<br>D. during</p></li><li><p><strong>__</strong> having a headache, I still went to work to finish the important report.<br>A. Since<br>B. Despite<br>C. Until<br>D. As</p></li><li><p>Don’t try to argue with him. He is <strong>__</strong> the point of listening to anyone’s advice.<br>A. during<br>B. like<br>C. past<br>D. as</p></li></ol><hr><h3 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a><strong>答案与解析</strong></h3><ol><li><p><strong>B. during</strong></p><ul><li><strong>解析</strong>：这里表示“在音乐会期间”，<code>during</code> 用于指在某个特定的时间段之内。</li></ul></li><li><p><strong>A. Despite</strong></p><ul><li><strong>解析</strong>：这句话的意思是“尽管任务很难，他还是设法提前完成了”。<code>Despite</code> 用于引出与主句相反的条件，表示转折关系，后接名词（the difficulty）。</li></ul></li><li><p><strong>C. as</strong></p><ul><li><strong>解析</strong>：这里表示她的“身份”或“职位”是经理。<code>as</code> 用来指代某人或某物的真实身份或功能。</li></ul></li><li><p><strong>B. like</strong></p><ul><li><strong>解析</strong>：这里的意思是我的妹妹有时行为举止“像”一个大人，但她并不是真正的大人。<code>like</code> 用于表示两者在行为或外表上的“相似”。</li></ul></li><li><p><strong>D. since</strong></p><ul><li><strong>解析</strong>：句中使用的是现在完成时（haven’t heard），表示一个从过去持续到现在的状态。“他去年搬去加拿大”是这个状态的起点，所以用 <code>since</code>，表示“自从”。</li></ul></li><li><p><strong>B. until</strong></p><ul><li><strong>解析</strong>：这是一个典型的 <code>not...until</code> 结构，意为“直到…才…”。整句话的意思是“直到他们完成作业，他们才被允许看电视”。</li></ul></li><li><p><strong>C. past</strong></p><ul><li><strong>解析</strong>：<code>half past ten</code> 是表示时间“十点半”的固定用法，意为“十点过去了半小时”。</li></ul></li><li><p><strong>B. as</strong></p><ul><li><strong>解析</strong>：<code>be famous as...</code> 表示“作为…而闻名”，强调的是他闻名的“身份”是演员。他就是一个演员。</li></ul></li><li><p><strong>B. Despite</strong></p><ul><li><strong>解析</strong>：“头痛”和“仍然去工作”是转折关系。<code>Despite</code> 后面可以跟动名词（having a headache），表示“尽管”。</li></ul></li><li><p><strong>C. past</strong></p><ul><li><strong>解析</strong>：<code>be past the point of doing something</code> 是一个固定搭配，表示“已经过了会做某事的阶段了”，引申为“不再…”。这里的意思是他已经过了会听取任何人建议的阶段了。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">英语介词第九讲</summary>
    
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://yjyrichard.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL</title>
    <link href="https://yjyrichard.github.io/posts/cb97b83b.html"/>
    <id>https://yjyrichard.github.io/posts/cb97b83b.html</id>
    <published>2025-08-20T00:30:25.908Z</published>
    <updated>2025-08-25T11:28:04.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：PostgreSQL介绍"><a href="#一：PostgreSQL介绍" class="headerlink" title="一：PostgreSQL介绍"></a>一：PostgreSQL介绍</h3><p>PostgreSQL是一个功能强大的<strong>开源</strong>的关系型数据库。底层基于C实现。</p><p>PostgreSQL的开源协议和Linux内核版本的开源协议是一样的。BSD协议，这个协议基本和MIT开源协议一样，说人话，就是你可以对PostgreSQL进行一些封装，然后商业化并进行收费。</p><p>PostgreSQL的名字咋来的。之前叫Ingres,后面为了解决一些ingres中的一些问题，作为后面的ingres，就起名叫postgre。</p><p>PostgreSQL版本迭代的速度比较快，现在最新的正式的发布版本，已经到了15.RELEASE。</p><p>PGSQL的版本选择一般有两种：</p><ul><li>如果为了稳定的运行，推荐使用12.x版本。</li><li>如果想体验新特性，推荐使用14.x版本。</li></ul><p>PGSQL允许跨版本升级，而且没有什么大问题。</p><p>PGSQL社区特别活跃，基本是三个月一发版。意味着很多常见的BUG都可以得到及时的修复。</p><p>PGSQL其实在国外使用的比较多，国内暂时还是以MySQL为主。</p><p>但是国内很多国产数据库都是基于PGSQL做的二次封装：比如华为GaussDB,还有腾讯的Tbase等等。甚至很多公司原来的Oracle，直接平转到PGSQL。同时国内的很多云产品都支持PGSQL了。</p><p>PGSQL因为开源，有很多做数据迁移的工具，可以让你快速的MySQL,SQLServer,Oracle直接平转到PGSQL内部，比如pgloader这样的数据迁移工具。</p><p>PGSQL的官方地址：<a href="https://www.postgresql.org/">PostgreSQL: The world’s most advanced open source database</a></p><p>PGSQL的中文社区：<a href="http://www.postgres.cn/v2/document">文档目录/Document Index: 世界上功能最强大的开源数据库…</a></p><h3 id="二：PostgreSQL和MySQL的区别"><a href="#二：PostgreSQL和MySQL的区别" class="headerlink" title="二：PostgreSQL和MySQL的区别"></a>二：PostgreSQL和MySQL的区别</h3><p>技术没有好坏之分，只是看一下是否符合你的业务，能否解决你的业务需求。其次也要查看社区的活跃度以及更新的频次。比如：MQ,Rabbit,Rocket,Kafka,Pular….</p><p>MySQL不支持的几点内容：</p><ul><li>MySQL不支持序列概念，Squence。</li><li>MySQL的数据类型不够丰富。</li><li>使用MySQL时，网上比较好用的插件比较少。</li><li>MySQL的性能优化监控工具不是很多，定位问题的成本比较高。</li><li>MySQL的主从复制没有一个官方的同步策略，同步问题难以解决。</li><li>MySQL虽然开源，但是不够彻底，GPL开源策略（如果你使用mysql做点东西你也得开源）</li></ul><p>PostgreSQL相对MySQL上述问题的特点：</p><ul><li>PostgreSQL的数据类型嘎嘎丰富。</li><li>PostgreSQL是有序列的概念的。</li><li>PostgreSQL的插件特别丰富。</li><li>PostgreSQL支持主从复制的同步操作，可以实现数据的0丢失。</li><li>PostgreSQL的MVCC实现和MySQL不太一样。PostgreSQL一行数据会存储多个版本。最多可以存储40亿个事务版本。</li></ul><h3 id="三：PostgreSQL的安装"><a href="#三：PostgreSQL的安装" class="headerlink" title="三：PostgreSQL的安装"></a>三：PostgreSQL的安装</h3><p>咱们只在Linux中安装，不推荐在Windows下安装。</p><p>Linux的版本尽量使用7.xb版本，最好是7.6或者7.8版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"><span class="built_in">sudo</span> yum install -y postgresql14-server</span><br><span class="line"><span class="built_in">sudo</span> /usr/pgsql-14/bin/postgresql-14-setup initdb</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> postgresql-14</span><br><span class="line"><span class="built_in">sudo</span> systemctl start postgresql-14</span><br></pre></td></tr></table></figure><p>如果出错，可能是那些问题：</p><ul><li>安装Linux的时候，一定要选择最小安装</li><li>你的Linux不能连接外网</li><li>Linux中5432端口，可能被占用了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status postgresql-14</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeedzgfcteisfxy4e6vZ ~]# systemctl status postgresql-14</span><br><span class="line">● postgresql-14.service - PostgreSQL 14 database server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/postgresql-14.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2025-08-18 20:26:00 CST; 3min 18s ago</span><br><span class="line">     Docs: https://www.postgresql.org/docs/14/static/</span><br><span class="line"> Main PID: 1470 (postmaster)</span><br><span class="line">   CGroup: /system.slice/postgresql-14.service</span><br><span class="line">           ├─1470 /usr/pgsql-14/bin/postmaster -D /var/lib/pgsql/14/data/</span><br><span class="line">           ├─1473 postgres: logger</span><br><span class="line">           ├─1475 postgres: checkpointer</span><br><span class="line">           ├─1476 postgres: background writer</span><br><span class="line">           ├─1477 postgres: walwriter</span><br><span class="line">           ├─1478 postgres: autovacuum launcher</span><br><span class="line">           ├─1479 postgres: stats collector</span><br><span class="line">           └─1480 postgres: logical replication launcher</span><br><span class="line"></span><br><span class="line">Aug 18 20:26:00 iZ2zeedzgfcteisfxy4e6vZ systemd[1]: Starting PostgreSQL 14 database server...</span><br><span class="line">Aug 18 20:26:00 iZ2zeedzgfcteisfxy4e6vZ postmaster[1470]: 2025-08-18 20:26:00.485 CST [1470] LOG:  redirecting <span class="built_in">log</span> output...ocess</span><br><span class="line">Aug 18 20:26:00 iZ2zeedzgfcteisfxy4e6vZ postmaster[1470]: 2025-08-18 20:26:00.485 CST [1470] HINT:  Future <span class="built_in">log</span> output wil...log<span class="string">&quot;.</span></span><br><span class="line"><span class="string">Aug 18 20:26:00 iZ2zeedzgfcteisfxy4e6vZ systemd[1]: Started PostgreSQL 14 database server.</span></span><br><span class="line"><span class="string">Hint: Some lines were ellipsized, use -l to show in full.</span></span><br><span class="line"><span class="string">[root@iZ2zeedzgfcteisfxy4e6vZ ~]#</span></span><br></pre></td></tr></table></figure><p>PostgreSQL 不推荐使用root管理，在安装成功postgreSQL后，他默认会给你创建一个用户：postgres </p><p>玩PGSQL前，先切换到postgres </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su postgres</span><br></pre></td></tr></table></figure><p>切换到postgres用户后，直接输入psql即可进入到postgreSQL提供的的客户端</p><p>查看有那些库，如果是新安装的，有三个库</p><p><code>\l</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeedzgfcteisfxy4e6vZ ~]# su postgres</span><br><span class="line">bash-4.2$ <span class="built_in">who</span> am i</span><br><span class="line">root     pts/0        2025-08-18 20:17 (120.235.181.139)</span><br><span class="line">bash-4.2$ psql</span><br><span class="line">could not change directory to <span class="string">&quot;/root&quot;</span>: Permission denied</span><br><span class="line">psql (14.19)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure><h3 id="四：PostgreSQL的配置"><a href="#四：PostgreSQL的配置" class="headerlink" title="四：PostgreSQL的配置"></a>四：PostgreSQL的配置</h3><p>要搞两个配置信息，一个关于postgreSQL的远程连接配置以及postgreSQL的日志配置。</p><p>PostgreSQL的主要配置放在数据目录下的，postgresql.conf以及pg_hba.conf配置文件</p><p><code>\q</code> 退出</p><p>这些配置文件都放在了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/var/</span>lib<span class="regexp">/pgsql/</span><span class="number">14</span>/data</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bash-4.2$ <span class="built_in">ls</span> -l</span><br><span class="line">total 136</span><br><span class="line">drwx------ 5 postgres postgres  4096 Aug 18 20:25 base</span><br><span class="line">-rw------- 1 postgres postgres    30 Aug 18 20:26 current_logfiles</span><br><span class="line">drwx------ 2 postgres postgres  4096 Aug 18 20:37 global</span><br><span class="line">drwx------ 2 postgres postgres  4096 Aug 18 20:26 <span class="built_in">log</span></span><br><span class="line">drwx------ 2 postgres postgres  4096 Aug 18 20:25 pg_commit_ts</span><br><span class="line">drwx------ 2 postgres postgres  4096 Aug 18 20:25 pg_dynshmem</span><br><span class="line">-rw------- 1 postgres postgres  4577 Aug 18 20:25 pg_hba.conf</span><br><span class="line">-rw------- 1 postgres postgres  1636 Aug 18 20:25 pg_ident.conf</span><br><span class="line">drwx------ 4 postgres postgres  4096 Aug 18 20:31 pg_logical</span><br><span class="line">drwx------ 4 postgres postgres  4096 Aug 18 20:25 pg_multixact</span><br><span class="line">drwx------ 2 postgres postgres  4096 Aug 18 20:25 pg_notify</span><br></pre></td></tr></table></figure><p>上图可以看到，postgreSQL的核心文件，都属于postgres用户，操作的时候，尽可能的别用root用户，容易玩出坑，尽可能先切换到postgres用户去玩。</p><p>PostgreSQL默认情况下不支持远程连接的，这个跟MySQL几乎一样</p><ul><li>MySQL给mysql.user追加用户，一般是采用grant的命令去玩。</li><li>PostgreSQL要基于配置文件修改，才能指定用户是否可以远程连接。</li></ul><p>直接去修改pg_hba.conf 配置文件</p><p>用户以及对应数据库和连接方式的编写模板</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># databases they can access.  Records take <span class="keyword">one</span> <span class="keyword">of</span> these forms:</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">local</span>         DATABASE  <span class="keyword">USER</span>  <span class="keyword">METHOD</span>  [OPTIONS]</span><br><span class="line"># host          DATABASE  <span class="keyword">USER</span>  ADDRESS  <span class="keyword">METHOD</span>  [OPTIONS]</span><br><span class="line"># hostssl       DATABASE  <span class="keyword">USER</span>  ADDRESS  <span class="keyword">METHOD</span>  [OPTIONS]</span><br><span class="line"># hostnossl     DATABASE  <span class="keyword">USER</span>  ADDRESS  <span class="keyword">METHOD</span>  [OPTIONS]</span><br><span class="line"># hostgssenc    DATABASE  <span class="keyword">USER</span>  ADDRESS  <span class="keyword">METHOD</span>  [OPTIONS]</span><br><span class="line"># hostnogssenc  DATABASE  <span class="keyword">USER</span>  ADDRESS  <span class="keyword">METHOD</span>  [OPTIONS]</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一块</span></span><br><span class="line"><span class="attribute">local</span>代表本地连接，host代表可以指定连接的ADDRESS</span><br><span class="line"><span class="comment"># 第二块</span></span><br><span class="line"><span class="attribute">database</span> 编写数据库名，如果写<span class="literal">all</span>,代表所有库都可以连接</span><br><span class="line"><span class="comment"># 第三块</span></span><br><span class="line"><span class="attribute">user</span>编写连接的用户，可以写<span class="literal">all</span>，代表所有用户</span><br><span class="line"><span class="comment"># 第四块</span></span><br><span class="line"><span class="attribute">address</span> 代表那些IP地址可以连接</span><br><span class="line"><span class="comment"># 第五块</span></span><br><span class="line"><span class="attribute">method</span>加密方式，这块不用过多关注，直接md5</span><br><span class="line"><span class="comment"># 修改：允许任意地址的所有用户连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">host</span>    <span class="literal">all</span>             <span class="literal">all</span>             <span class="number">0.0.0.0</span>/<span class="number">0</span>               md5</span><br><span class="line"><span class="comment"># 我配置的是set nu 86行</span></span><br></pre></td></tr></table></figure><p>为了实现远程连接，除了用户级别的这种配置，还要针对服务级别修改一个配置</p><p>服务级别的配置在postgresql.conf</p><p>：set nu 看见需要大概在60行左右</p><p>发现默认情况下PGSQL只允许localhost连接，直接配置*即可解决问题。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">60 listen_addresses = &#x27;*&#x27;         <span class="comment"># what IP address(es) to listen on;</span></span><br><span class="line">    <span class="number"> 61 </span>                                        <span class="comment"># comma-separated list of addresses;</span></span><br><span class="line">    <span class="number"> 62 </span>                                        <span class="comment"># defaults to &#x27;localhost&#x27;; use &#x27;*&#x27; for all</span></span><br><span class="line">    <span class="number"> 63 </span>                                        <span class="comment"># (change requires restart)</span></span><br><span class="line">    <span class="number"> 64 </span><span class="comment">#port = 5432                            # (change requires restart)</span></span><br><span class="line">    <span class="number"> 65 </span>max_connections =<span class="number"> 100 </span>                  <span class="comment"># (change requires restart)</span></span><br><span class="line">    <span class="number"> 66 </span><span class="comment">#superuser_reserved_connections = 3     # (change requires restart)</span></span><br><span class="line">    <span class="number"> 67 </span><span class="comment">#unix_socket_directories = &#x27;/run/postgresql, /tmp&#x27;      # comma-separated list of directories</span></span><br><span class="line">    <span class="number"> 68 </span>                                        <span class="comment"># (change requires restart)</span></span><br><span class="line">    <span class="number"> 69 </span><span class="comment">#unix_socket_group = &#x27;&#x27;                 # (change requires restart)</span></span><br><span class="line">    <span class="number"> 70 </span><span class="comment">#unix_socket_permissions = 0777         # begin with 0 to use octal notat</span></span><br></pre></td></tr></table></figure><p>记得为了生效，一定要重启</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># postgres 密码不管 直接切换roor</span></span><br><span class="line"><span class="attribute">sudo</span> systemctl restart postgresql-<span class="number">14</span></span><br></pre></td></tr></table></figure><p>配置数据库的日志</p><p>修改配置大概428行这样样子</p><p>postgreSQL默认情况下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表日志是开启的</span></span><br><span class="line"><span class="attr">logging_collector</span> = <span class="literal">on</span></span><br><span class="line"><span class="comment"># 日志存放的路径，默认放到当前目录下的log里</span></span><br><span class="line"><span class="attr">log_directory</span> = <span class="string">&#x27;log&#x27;</span></span><br><span class="line"><span class="comment"># 日志的文件名，默认是postgresql为前缀，星期作为后缀</span></span><br><span class="line"><span class="attr">log_filename</span> = <span class="string">&#x27;postgresql-%a.log&#x27;</span></span><br><span class="line"><span class="comment"># 默认一周过后，日志文件会被覆盖</span></span><br><span class="line"><span class="attr">log_truncate_on_rotation</span> = <span class="literal">on</span></span><br><span class="line"><span class="comment"># 一天一个日志文件</span></span><br><span class="line"><span class="attr">log_rotation_age</span> = <span class="number">1</span>d</span><br><span class="line"><span class="comment"># 一个日志文件 没有大小限制</span></span><br><span class="line"><span class="attr">log_rotation_size</span> = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五：PostgreSQL的基操"><a href="#五：PostgreSQL的基操" class="headerlink" title="五：PostgreSQL的基操"></a>五：PostgreSQL的基操</h3><p>只在psql命令行（客户端）下，执行了一次<code>\l</code> ，查看了所有的库信息</p><p>可以直接基于psql查看一些信息，也可以基于psql进入到命令行后再做操作</p><p>psql —help</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以直接进入命令行的原因，是psql默认情况下，就是以postgres用户去连接本地的pgsql，所以可以直接进入下面的图是默认的连接方式</span><br></pre></td></tr></table></figure><p>后面都基于psql的命令行（客户端）去进行操作</p><h4 id="5-1-构建用户"><a href="#5-1-构建用户" class="headerlink" title="5.1 构建用户"></a>5.1 构建用户</h4><p>命令绝对不要去背，需要使用去找帮助文档\help</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 区别就是<span class="keyword">create</span> <span class="keyword">user</span>默认有连接权限，<span class="keyword">create</span> role没有，不过可以基于选项去设置</span><br><span class="line">CREARE <span class="keyword">USER</span> 名称 [ [<span class="keyword">WITH</span>] 选项 [...] ]</span><br><span class="line">CREARE role 名称 [ [<span class="keyword">WITH</span>] 选项 [...] ]</span><br></pre></td></tr></table></figure><p>构建一个超级管理员用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> root <span class="keyword">with</span> SUPERUSER PASSWORD <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>成功：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">postgres=# <span class="keyword">create</span> <span class="keyword">user</span> root <span class="keyword">with</span> <span class="keyword">SUPERUSER</span> <span class="keyword">PASSWORD</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span></span><br></pre></td></tr></table></figure><p><code>\help</code>  即可查看到数据库级别的一些命令</p><p><code>\?</code>  可以查看到服务级别的一些命令</p><p>退出psql命令行 <code>\q</code></p><p>编写psql命令尝试去用root用户登录</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">psql</span> -h <span class="number">182.92.135.91</span> -p <span class="number">5432</span> -U root -W -d postgres</span><br></pre></td></tr></table></figure><p>但是没有对应的数据库所以报错</p><p>光有用户不给登录 比如要有数据库  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> root;</span><br></pre></td></tr></table></figure><p>可以再不退出psql的情况下切换用户 \c root </p><p>也可以退出psql，重新基于psql命令去切换用户以及数据库</p><p>查看当前的全部用户信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\du</span><br></pre></td></tr></table></figure><h4 id="5-2-权限操作"><a href="#5-2-权限操作" class="headerlink" title="5.2 权限操作"></a>5.2 权限操作</h4><p>权限操作前，要先掌握以下PGSQL的逻辑结构</p><p>PostgreSQL 的逻辑架构可以按“<strong>从大到小、层层嵌套</strong>”来理解。下面用一句话概括后再拆开讲：</p><blockquote><p>“一个 PostgreSQL <strong>Server</strong> 里只有一个 <strong>Cluster</strong>；Cluster 里可以有很多 <strong>Database</strong>；每个 Database 里可以有很多 <strong>Schema</strong>；Schema 里再存放真正的 <strong>对象</strong>（表、视图、索引、函数、触发器、序列 …）。”</p></blockquote><hr><ol><li>Server（服务器实例）<br>指正在运行的 postmaster 进程 + 共享内存 + 后台进程。<br>一个操作系统上可以同时跑多个 Server，只要它们监听不同的端口、数据目录分开即可。</li><li>Cluster（实例 / 数据目录）<br>• 每个 Server 对应 <strong>一个</strong> Cluster（由 <code>initdb</code> 创建）。<br>• 物理上就是 <code>$PGDATA</code> 目录；逻辑上是“一组共享系统目录 (<code>pg_catalog</code>) 的数据库集合”。<br>• Cluster 内的所有数据库共享：<br>– 同一个配置文件 (<code>postgresql.conf</code>)<br>– 同一个 WAL 流<br>– 同一个用户/角色体系 (<code>pg_authid</code>)<br>– 同一个表空间列表 (<code>pg_tablespace</code>)</li><li>Database（数据库）<br>• Cluster 下面可以创建多个独立的数据库 (<code>CREATE DATABASE</code>)。<br>• 每个数据库彼此隔离：<br>– 独立的系统表副本 (<code>pg_class</code>, <code>pg_attribute</code>, …)<br>– 独立的 <code>search_path</code>、<code>public</code> schema 等。<br>• 注意：跨数据库不能直接访问表，要用 <strong>dblink / FDW</strong> 或逻辑复制。</li><li>Schema（模式）<br>• 每个数据库里可以建多个 schema（<code>CREATE SCHEMA</code>）。<br>• 用于“逻辑分组”和“权限隔离”。<br>• 默认有 <code>public</code>；<code>search_path</code> 决定对象查找顺序。</li><li>对象（Objects）<br>位于 schema 之下，包括：<br>• 表、视图、物化视图、外部表<br>• 索引（B-tree、GIN、GIST …）<br>• 序列、复合类型、域<br>• 函数、存储过程、触发器、事件触发器<br>• 行级安全策略、规则、约束、注释 …</li><li>Tablespace（表空间）<br>• 与上面“垂直层级”不同，它是 <strong>横向的存储映射</strong>。<br>• 逻辑上属于 Cluster；物理上是任意的目录路径。<br>• 创建对象时可通过 <code>TABLESPACE xxx</code> 把表/索引放到指定目录，实现“冷热数据分离”。</li></ol><hr><p>一张脑图式速记：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│                   <span class="keyword">Server</span> (postmaster)                  │</span><br><span class="line">│  <span class="comment">----------------------------------------------------  │</span></span><br><span class="line">│  <span class="keyword">Cluster</span> ($PGDATA)                                     │</span><br><span class="line">│  ├─ <span class="keyword">Database</span> A                                         │</span><br><span class="line">│  │   ├─ <span class="keyword">Schema</span> s1 ── 表/视图/索引/函数/触发器          │</span><br><span class="line">│  │   └─ <span class="keyword">Schema</span> s2 ── …                                 │</span><br><span class="line">│  ├─ <span class="keyword">Database</span> B                                         │</span><br><span class="line">│  │   └─ <span class="built_in">public</span> ── …                                    │</span><br><span class="line">│  └─ shared objects: roles, tablespaces, …             │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>这样看，就能快速定位：<br>“我连接的是哪个 Server → 哪个 Cluster → 哪个 Database → 哪个 Schema → 哪个对象”。</p><blockquote><p>server,cluster,tablespace 级别 这个级别一般是基于pg_hba.conf去配置</p><p>database级别：通过命令级别操作，grant</p><p>namespace，schema级别：玩的不多,不去了解</p><p>对象级别：通过grant命令去设置</p></blockquote><p><strong>小任务</strong></p><p>构建一个用户（你自己的名字）</p><p>比如构建一个数据库，在这个数据库下构建一个schema（数据库默认有一个public的schema）</p><p>再这个schema下构建一个表</p><p>给用户赋予select，update,insert权限赋值给用户</p><ol><li>以超级用户（如 <code>postgres</code>）登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 182.92.135.91 -U postgres -W</span><br></pre></td></tr></table></figure><ol><li>在 psql 里依次执行</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1) 建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> yjy <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;yjy123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2) 建数据库，并把 owner 设成 yjy</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE yjy_db OWNER yjy;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3) 切到新建的数据库</span></span><br><span class="line">\c yjy_db</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4) 建一个业务 schema（除了 public 之外）</span></span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA yjy_schema <span class="keyword">AUTHORIZATION</span> yjy;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5) 在该 schema 下建一张示例表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> yjy_schema.demo (</span><br><span class="line">    id   serial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    info text</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6) 把 yjy_schema.demo 的常用权限一次性赋给 yjy</span></span><br><span class="line"><span class="comment">--    也可以写 GRANT SELECT, INSERT, UPDATE ... 但更简单的写法：</span></span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA yjy_schema <span class="keyword">TO</span> yjy;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA yjy_schema <span class="keyword">TO</span> yjy;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可选：让 yjy 今后自己新建的表也自动带这些权限</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA yjy_schema</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> yjy;</span><br></pre></td></tr></table></figure><ol><li>验证</li></ol><p>退出超级用户会话，用新建用户登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 182.92.135.91 -U yjy -d yjy_db -W</span><br></pre></td></tr></table></figure><p>在 <code>yjy_db=&gt;</code> 提示符下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 应该能成功</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> yjy_schema.demo(info) <span class="keyword">VALUES</span> (<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> yjy_schema.demo;</span><br><span class="line"><span class="keyword">UPDATE</span> yjy_schema.demo <span class="keyword">SET</span> info<span class="operator">=</span><span class="string">&#x27;hi&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>到此，任务完成。</p><h3 id="六：图形化界面安装"><a href="#六：图形化界面安装" class="headerlink" title="六：图形化界面安装"></a>六：图形化界面安装</h3><p>我使用navicat了</p><p>直接在public下建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> hello (</span><br><span class="line">    id   serial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    msg  text</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> hello(msg) <span class="keyword">VALUES</span> (<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hello;</span><br></pre></td></tr></table></figure><h3 id="七、数据类型"><a href="#七、数据类型" class="headerlink" title="七、数据类型"></a>七、数据类型</h3><p>PGSQL支持的类型特别丰富，大度哟书的类型MySQL都有对应的关系</p><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th><th>对比MySQL</th></tr></thead><tbody><tr><td>布尔类型</td><td>boolean，标准的布尔类型</td><td>MySQL中虽然没有对应的boolean，但是有替换的类型，数值的tinyint类型和PGSQL的boolean都是占一个字节。</td></tr><tr><td>整型</td><td>smallint(2字节），integer(4字节)，bigint(8字节)</td><td>跟MySQL没啥区别</td></tr><tr><td>浮点型</td><td>decimal,numeric (和decimal一样，精准浮点型)，real(float),double precision(double) money(货币类型)</td><td>和MySQL基本也没有啥区别，MySQL支持float,double,decimal.MySQL没有这个货币类型。</td></tr><tr><td>字符串类型</td><td>varchar(n)(character varying),  char(n) (character),text</td><td>和MySQL基本没区别。PGSQL存储的varchar类型，可以存储一个G，MySQL好像存储64kb</td></tr><tr><td>日期类型</td><td>data(年月日),time(时分秒),timestamp(年月日时分秒)</td><td>和MySQL基本一致。mysql有个datetime</td></tr><tr><td>二进制类型</td><td>bytea-存储二进制类型</td><td>MySQL也支持，MySQL是blog</td></tr><tr><td>位置类型</td><td>bit（n）-定长位图，bit varying(n)</td><td>存储0或者1.MySQL也有但是用的不多。</td></tr><tr><td>枚举类型</td><td>enum,跟java的enum一样</td><td>MySQL也一样</td></tr><tr><td>集合类型</td><td>点直线线段。。。。</td><td>MySQL没有但是一般也用不到</td></tr><tr><td>数组类型</td><td>在类型后面，追加[] 代表存储数组</td><td>MySQL没有</td></tr><tr><td>JSON类型</td><td>json(存储JSON数据的文本)，JSONB（存储JSON二进制）【JSONB 是 PostgreSQL 的<strong>高性能 JSON</strong> 类型，除非你有特殊理由要保留原始文本，否则<strong>默认选 JSONB</strong>】</td><td>MySQL8.x也支持</td></tr><tr><td>ip类型</td><td>cidr(存储ip地址)</td><td>MySQL不支持</td></tr><tr><td>。。。</td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="八、PostgreSQL基本操作"><a href="#八、PostgreSQL基本操作" class="headerlink" title="八、PostgreSQL基本操作"></a>八、PostgreSQL基本操作</h3><h4 id="8-1-单引号和双引号"><a href="#8-1-单引号和双引号" class="headerlink" title="8.1 单引号和双引号"></a>8.1 单引号和双引号</h4><p>在PGSQL中，与SQL语句时，单引号用来标识实际的值。双引号用来标识一个关键字，比如表名，字段名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单引号写具体的值，双引号类似MySQL的``标记，用来填充关键字</span></span><br><span class="line"><span class="comment">-- 下面的葡萄牙会报错，因为葡萄牙不是关键字</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1.14</span> <span class="string">&#x27;卡特尔&#x27;</span>,&quot;卡塔尔&quot;;</span><br></pre></td></tr></table></figure><h4 id="8-2-数据类型转换"><a href="#8-2-数据类型转换" class="headerlink" title="8.2 数据类型转换"></a>8.2 数据类型转换</h4><p>第一种方式：只需要在值的面前，添加上具体的数据类型即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将字符串转成位图类型</span></span><br><span class="line"><span class="keyword">select</span> bit <span class="string">&#x27;010010010100101&#x27;</span>;</span><br></pre></td></tr></table></figure><p>第二种方式：也可以在具体值的后面，添加上：：类型，来指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据类型</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;2011-11-11&#x27;</span>::<span class="type">date</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;0101010101010&#x27;</span>::bit(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;13&#x27;</span>::<span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>第三种方式：使用CAST函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类型转换的完整写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CAST</span>(<span class="type">varchar</span> <span class="string">&#x27;100&#x27;</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br></pre></td></tr></table></figure><h4 id="8-3-布尔类型"><a href="#8-3-布尔类型" class="headerlink" title="8.3 布尔类型"></a>8.3 布尔类型</h4><p>可以存储三个值：true,false,null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 布尔类型的约束没有那么强 true,false 大小写随意 他会给你转；同时yes,on他也认识</span></span><br><span class="line"><span class="keyword">select</span> <span class="literal">true</span>,<span class="literal">false</span>,<span class="string">&#x27;yes&#x27;</span>::<span class="type">boolean</span>,<span class="type">boolean</span> <span class="string">&#x27;no&#x27;</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="keyword">Null</span>::<span class="type">boolean</span>;</span><br></pre></td></tr></table></figure><h4 id="8-4-数值类型"><a href="#8-4-数值类型" class="headerlink" title="8.4 数值类型"></a>8.4 数值类型</h4><h5 id="8-4-1-整型"><a href="#8-4-1-整型" class="headerlink" title="8.4.1 整型"></a>8.4.1 整型</h5><p>整型比较简单，主要就是三个：</p><ul><li>smallint,int2: 2字节</li><li>integer,int ,int4：4字节</li><li>bigint,int8 : 8字节</li></ul><p>正常没啥事就integer,如果要存主键，比如雪花算法，那就bigint,空间要节约，根据情况smallint</p><h4 id="8-4-2-浮点型"><a href="#8-4-2-浮点型" class="headerlink" title="8.4.2 浮点型"></a>8.4.2 浮点型</h4><p>浮点类型就2个（其实是一个）</p><ul><li>decimal(n,m)：本质就是numeric,PGSQLh会帮你转换</li><li>numeric(n.m): PGSQL本质的浮点类型</li></ul><p>针对浮点类型的数据，就使用numeric</p><h4 id="8-4-3-序列"><a href="#8-4-3-序列" class="headerlink" title="8.4.3 序列"></a>8.4.3 序列</h4><p>MySQL中的主键自增，是基于auto_increment 去实现，MySQL里没有序列的对象。</p><p>PGSQL和Oracle十分相似，支持序列：sequence</p><p>PGSQL可没有auto_increment.</p><p>序列的正常构建方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence yjy.table_id_seq;</span><br><span class="line"><span class="comment">-- 查询下一个值</span></span><br><span class="line"><span class="keyword">select</span> nextval(<span class="string">&#x27;yjy.table_id_seq&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询当前值</span></span><br><span class="line"><span class="keyword">select</span> currval(<span class="string">&#x27;yjy.table_id_seq&#x27;</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，sequence的起始值都是0，每次nextval递增1，最大值9223372036854775807</p><p>告诉缓存，插入的数据比较多，可以指定告诉缓存，一次性计算出20个后续的值，nextval时就可以不去计算，直接去高速缓存拿值，效率会有一点点提升。</p><p>序列大多数的应用，是作表的主键自增效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表自增</span></span><br><span class="line"><span class="keyword">create table</span> yjy.xxx(</span><br><span class="line">id int8 <span class="keyword">default</span> nextval(<span class="string">&#x27;yjy.table_id_seq&#x27;</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert into</span> yjy.xxx (name) <span class="keyword">values</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> yjy.xxx;</span><br></pre></td></tr></table></figure><p>这一种写法没有问题 但是比较麻烦</p><p>PGSQL提供了序列的数据结构，可以在声明表结果时，直接指定序列的类型即可。</p><ul><li>smallserial</li><li>serial</li><li>bigserial</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表自增</span></span><br><span class="line"><span class="keyword">create table</span> yjy.yyy(</span><br><span class="line">id bigserial,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert into</span> yjy.yyy (name) <span class="keyword">value</span> (<span class="string">&#x27;yyy&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在drop表之后，序列不会删除，但是序列会变为不可用的状态。</p><p>因为序列在使用serial去构建时，会绑定在指定表的指定列上。</p><h4 id="8-5-字符串类型"><a href="#8-5-字符串类型" class="headerlink" title="8.5 字符串类型"></a>8.5 字符串类型</h4><p>字符串类型用的时最多的一种，在PGSQL里，主要支持三种：</p><ul><li>character(就是MySQL的char类型)，定长字符串。（最大可用存储1G）</li><li>character varying(varchar)</li><li>text</li></ul><p>操作没什么说的，但是字符串的常见函数特别多</p><p>字符串的拼接一定要使用||来拼接</p><h4 id="8-6-日期类型"><a href="#8-6-日期类型" class="headerlink" title="8.6 日期类型"></a>8.6 日期类型</h4><p>在PGSQL中，核心的时间类型，就三个。</p><ul><li>timestamp (时间戳，覆盖 年月日时分秒)</li><li>data(年月日)</li><li>time（时分秒）</li></ul><p>在PGSQL中，声明时间的方式。</p><p>之需要使用字符串的正常编写yyyy-MM-dd HH:mm:ss 就可以转换为时间类型</p><p>直接在字符串位置使用之前讲道德数据类型转换就可以了。</p><p>当前系统时间：</p><ul><li><p>可以使用now作为当前系统时间（没有时区的概念）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">TIMESTAMP</span> <span class="string">&#x27;now&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接查询now 没有时区的概念</span></span><br><span class="line"><span class="keyword">select</span> <span class="type">time</span> <span class="keyword">with</span> tinme zone <span class="string">&#x27;now&#x27;</span> <span class="keyword">at</span> <span class="type">time</span> zone <span class="string">&#x27;08:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可以使用current_timestamp的方式获取（推荐，默认东八区）</p></li></ul><p>日期类型的运算</p><ul><li>正常对date类型做 + - 运算，默认单位就是天</li></ul><p>也可以用interval的方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">timestamp</span> <span class="string">&#x27;2011-11-11 12:12:12&#x27;</span> <span class="operator">+</span> <span class="type">interval</span> <span class="string">&#x27;1day&#x27;</span> <span class="operator">+</span> <span class="type">interval</span> <span class="string">&#x27;1minute&#x27;</span> <span class="operator">+</span> <span class="type">interval</span> <span class="string">&#x27;1month&#x27;</span>; </span><br></pre></td></tr></table></figure><h4 id="8-7-枚举类型"><a href="#8-7-枚举类型" class="headerlink" title="8.7 枚举类型"></a>8.7 枚举类型</h4><p>枚举类型MySQL也支持，只是没什么用。</p><p>可以声明枚举类型作为表中的字段类型，这样可以无形的给表追加规范</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明一个星期的枚举</span></span><br><span class="line"><span class="keyword">create</span> type week <span class="keyword">as</span> enum (<span class="string">&#x27;Mon&#x27;</span>,<span class="string">&#x27;Tues&#x27;</span>,<span class="string">&#x27;Sun&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id bigserial,</span><br><span class="line">weekday week</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert into</span> test (weekday) <span class="keyword">values</span> (<span class="string">&#x27;Mon&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="8-8-IP类型"><a href="#8-8-IP类型" class="headerlink" title="8.8 IP类型"></a>8.8 IP类型</h4><p>PGSQL支持IP类型的存储，支持IPv4,IPv6这种，甚至Mac内的类型也支持</p><p>这种IP类，可以在存储IP时，帮助做校验,也支持范围查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;192.168.101.200&#x27;</span>::cidr;</span><br></pre></td></tr></table></figure><h4 id="8-9-JSON-amp-JSONB类型"><a href="#8-9-JSON-amp-JSONB类型" class="headerlink" title="8.9 JSON&amp;JSONB类型"></a>8.9 JSON&amp;JSONB类型</h4><p>JSON在MySQL8.x也做了支持，但是MySQK支持的不好，因为JSON类型做查询时，基本无法给JSON字段做索引。</p><p>PGSQL支持JSON类型以及JSONB类型</p><p>JSON和JSONB的使用基本没有区别</p><p>撇去JSON类型，本质上JSON格式就一个字符串，比如MySQL5.7不支持JSON的情况下，使用text也可以，但是字符串类型无法校验JSON的格式，其次单独的字符串没有办法只获取JSON中某个key对应的value.</p><p>JSON和JSONB的区别：</p><ul><li>JSON类型无法构建索引，JSONB类型可以创建索引</li><li>JSON类型的数据中多余的空格会被存储下来，JSONB会自动取消多余的空格。</li><li>JSON类型甚至可以存储重复的key,以最后一个为准，JSONB不会保留多余的重复key.</li><li>JSON会保留存储时key的顺序，JSONB不会保存原有顺序。</li></ul><p>JSON中key对应的value数据类型</p><div class="table-container"><table><thead><tr><th>JSON</th><th>PGSQL</th></tr></thead><tbody><tr><td>String</td><td>text</td></tr><tr><td>number</td><td>numeric</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>null</td><td>(none)</td></tr><tr><td>操作JSON</td></tr></tbody></table></div><ul><li>上述的四种JSON存储的类型</li><li>JSON数组</li><li>JSON对象</li><li>构建表存储JSON</li></ul><h4 id="8-10-复合类型"><a href="#8-10-复合类型" class="headerlink" title="8.10 复合类型"></a>8.10 复合类型</h4><p>复合类型就好像Java中的一个对象，Java中有一个User,User和表做了一个映射，User中有个人信息对象。可以基于复合类型对映射上个人信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Info info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 构建复合类型 映射上Info</span></span><br><span class="line"><span class="keyword">create</span> type info_type <span class="keyword">as</span> (name <span class="type">varchar</span>(<span class="number">32</span>),age <span class="type">int</span>);</span><br><span class="line"><span class="comment">-- 构建表 映射user</span></span><br><span class="line"><span class="keyword">create table</span> <span class="keyword">user</span>(</span><br><span class="line">    id serial;</span><br><span class="line">    info info_type;</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert into</span> tb_user (info) <span class="keyword">values</span> ((<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>));</span><br><span class="line"><span class="keyword">insert into</span> tb_user (info) <span class="keyword">values</span> ((<span class="string">&#x27;Lucy&#x27;</span>,<span class="number">223</span>));</span><br><span class="line"><span class="keyword">insert into</span> tb_user (info) <span class="keyword">values</span> ((<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>));</span><br><span class="line"><span class="keyword">insert into</span> tb_user (info) <span class="keyword">values</span> ((<span class="string">&#x27;张三&#x27;</span>,<span class="number">23</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><h4 id="8-11-数组类型"><a href="#8-11-数组类型" class="headerlink" title="8.11 数组类型"></a>8.11 数组类型</h4><p>数组还是要依赖其他类型，比如在设置住址，住址可能有多个住址，看采用数组类型去修饰字符串。</p><p>PGSQL中，指定数组的方式就是[]，可以指定一维数组，也支持二维甚至更多维数组。</p><p>构建数组的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test;</span><br><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id serial,</span><br><span class="line">col1 <span class="type">int</span>[],</span><br><span class="line">col2 <span class="type">int</span>[<span class="number">2</span>],</span><br><span class="line">col3 <span class="type">int</span>[][]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 构建表指定数组长度后，并不是说数组内容只有2的长度，可以插入更多数据</span></span><br><span class="line"><span class="comment">-- 甚至在你插入数据，如果将二维数组的结构扔到一维数组上，也可以存储。</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&#123;how,are,you&#125;&#x27;</span>::<span class="type">VARCHAR</span>[];</span><br></pre></td></tr></table></figure><p>数据类型 - 数组（比较方式）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 包含</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>[<span class="number">1</span>,<span class="number">2</span>] @<span class="operator">&gt;</span> <span class="keyword">array</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 被包含</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>[<span class="number">1</span>,<span class="number">2</span>] <span class="operator">&lt;</span>@ <span class="keyword">array</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">-- 是否有相同元素</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>[<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">1</span>] <span class="operator">&amp;&amp;</span> <span class="keyword">array</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="九-表"><a href="#九-表" class="headerlink" title="九:表"></a>九:表</h3><p>表的构建语句，基本都会。</p><p>核心在于构建表时，要指定上一些约束。</p><h4 id="9-1-约束"><a href="#9-1-约束" class="headerlink" title="9.1 约束"></a>9.1 约束</h4><h5 id="9-1-1-主键"><a href="#9-1-1-主键" class="headerlink" title="9.1.1 主键"></a>9.1.1 主键</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id bigserial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="9-1-2-非空"><a href="#9-1-2-非空" class="headerlink" title="9.1.2 非空"></a>9.1.2 非空</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id bigserial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">not NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="9-1-3-唯一"><a href="#9-1-3-唯一" class="headerlink" title="9.1.3 唯一"></a>9.1.3 唯一</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id bigserial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">not NULL</span>,</span><br><span class="line">id_card <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="9-1-4-检查"><a href="#9-1-4-检查" class="headerlink" title="9.1.4 检查"></a>9.1.4 检查</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查约束</span></span><br><span class="line"><span class="comment">-- 价格的表 price,discount_price</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test;</span><br><span class="line"><span class="keyword">create table</span> test(</span><br><span class="line">id bigserial <span class="keyword">primary KEY</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">not null</span>,</span><br><span class="line">price <span class="type">numeric</span> <span class="keyword">check</span>(price <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">discount_price <span class="type">numeric</span> <span class="keyword">check</span>(discount_price <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line"><span class="keyword">check</span>(price <span class="operator">&gt;=</span> discount_price)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="9-1-5-外键（了解）"><a href="#9-1-5-外键（了解）" class="headerlink" title="9.1.5 外键（了解）"></a>9.1.5 外键（了解）</h5><h5 id="9-1-6-默认值"><a href="#9-1-6-默认值" class="headerlink" title="9.1.6 默认值"></a>9.1.6 默认值</h5><p>一般公司内，要求表中除了主键和业务字段之外，必须要有5个字段</p><p>created，create_id, updated, updated_id, is_delete</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span>;</span><br></pre></td></tr></table></figure><h4 id="9-2-触发器"><a href="#9-2-触发器" class="headerlink" title="9.2 触发器"></a>9.2 触发器</h4><p>触发器trigger,是由事件触发的一种存储过程</p><p>当对表进行insert,update,delete,truncate操作时，会触发表的Trigger(看触发器的创建时指定的事件)</p><p>构建两张表，学生信息表，学生分数表。</p><p>在删除学生信息的同时，自动删除学生的分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> score(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">student_id <span class="type">int</span>,</span><br><span class="line">math_score <span class="type">numeric</span>,</span><br><span class="line">english_score <span class="type">numeric</span>,</span><br><span class="line">chinese_score <span class="type">numeric</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> student (id,name) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> student (id,name) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">&#x27;lisi1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> </span><br><span class="line">score</span><br><span class="line">(id,student_id,math_score,english_score,chinese_score) </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">66</span>,<span class="number">66</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> </span><br><span class="line">score</span><br><span class="line">(id,student_id,math_score,english_score,chinese_score) </span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">77</span>,<span class="number">77</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了完成级联删除，需要编写pl/sql</p><p>先查看一下PGSQL支持plsql,查看PGSQL的plsql语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个名为 test() 的无参函数，返回一个整数</span></span><br><span class="line"><span class="comment">-- $$ 可以理解为时一种特殊的单引号</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> test()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">int</span>                       <span class="comment">-- 正确关键字是 RETURNS（有 &#x27;s&#x27;）</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    money <span class="type">int</span> :<span class="operator">=</span> <span class="number">10</span>;             <span class="comment">-- 声明局部变量并初始化为 10</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> money;                <span class="comment">-- 将变量 money 作为结果返回</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><p>在简单了解了一下plpgsql的语法后，编写一个触发器函数。</p><p>触发器函数允许使用一些特殊变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 构建一个删除学生分数的触发器函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">FUNCTION</span> trigger_function_delete_student_score() <span class="keyword">returns</span> <span class="keyword">trigger</span> <span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> score <span class="keyword">where</span> student_id <span class="operator">=</span> OLD.id;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">old</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><p>开始构建触发器，在学生信息表删除时，执行前面声明的触发器函数</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_student </span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> student </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">execute</span> <span class="keyword">function</span> trigger_function_delete_student_score();</span><br></pre></td></tr></table></figure><h4 id="9-3-表空间"><a href="#9-3-表空间" class="headerlink" title="9.3 表空间"></a>9.3 表空间</h4><p>在存储数据时，数据肯定要落到磁盘上，基于构建的tablespace,指定数据存放在磁盘上的物理地址。</p><p>如果没有字节设计tablespace，PGSQL会自动指定一个位置作为默认的存储点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询表存储的物理地址</span></span><br><span class="line"><span class="keyword">select</span> pg_relation_filepath(<span class="string">&#x27;student&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这个位置是在$PG_DATA后的存放地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$PG_DATA <span class="operator">=</span><span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>pgsql<span class="operator">/</span><span class="number">14</span><span class="operator">/</span>data<span class="operator">/</span></span><br></pre></td></tr></table></figure><p>410000 起始就是存储数据的物理文件</p><p>构建表空间，指定数据存放位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 构建表空间，构建表空间需要用户权限是超级管理员，起始需要指定的目录已经存在</span></span><br><span class="line"><span class="keyword">create</span> tablespace tp_test location <span class="string">&#x27;/var/lib/pgsql/14/data/tp_data&#x27;</span>;</span><br></pre></td></tr></table></figure><p>构建数据库，以及表，指定到这个表空间中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db_test tablespace tp_test;</span><br></pre></td></tr></table></figure><p>其实指定表空间的存储位置后，PGSQL会在$PG_DATA目录下存储一份，同时在咱们构建tablespace时，指定的路径下也存储一份。</p><p>进一步发现，其实在PGSQL目录下，存储的是一个link,链接文件，类似一个快捷方式</p><h4 id="9-4-视图"><a href="#9-4-视图" class="headerlink" title="9.4 视图"></a>9.4 视图</h4><p>跟MySQL没什么区别，把一些复杂的操作封装起来，还可以隐藏一些敏感数据。</p><p>视图对于用户来说，就是一张真实的表，可以直接基于视图查询一张或者多张表的信息。</p><p>视图对于开发来说，就是一条SQL语句。</p><p>在PGSQL中，简单（单表）的视图时允许写操作的</p><p>但是强烈不推荐对视图进行写操作,虽然PGSQL默认允许（简单的视图）</p><p>写入的时候，其实修改的是表本身</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vw_Socre <span class="keyword">as</span> </span><br><span class="line">(<span class="keyword">select</span> id,math_score <span class="keyword">from</span> score);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vw_score;</span><br><span class="line"><span class="keyword">update</span> vw_score <span class="keyword">set</span> math_score <span class="operator">=</span> <span class="number">99</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 复杂视图(两张表关联) 默认不允许修改</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vw_student_score <span class="keyword">as</span> </span><br><span class="line">(<span class="keyword">select</span> stu.name,score.math_score <span class="keyword">from</span> student stu,score score <span class="keyword">where</span> stu.id <span class="operator">=</span> score.student_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-5-索引"><a href="#9-5-索引" class="headerlink" title="9.5 索引"></a>9.5 索引</h4><h5 id="9-5-1-索引的基本概念"><a href="#9-5-1-索引的基本概念" class="headerlink" title="9.5.1 索引的基本概念"></a>9.5.1 索引的基本概念</h5><p>先了解概念和使用</p><p>索引是数据库中快速查询数据的方法.</p><p>索引能提升查询效率的同时，也会带来一些问题</p><ul><li>增加了存储空间</li><li>写操作时，花费的事件比较多</li></ul><p>索引可以提升效率，甚至还可以给字段做一些约束</p><h5 id="9-5-2-索引的分类"><a href="#9-5-2-索引的分类" class="headerlink" title="9.5.2 索引的分类"></a>9.5.2 索引的分类</h5><p>BTree索引：最常用的索引。</p><p>Hash索引：跟Mysql类似，做等值判断</p><p>GIN索引：针对字段的多个值的类型，比如数组类型</p><h5 id="9-5-3-创建索引看效果"><a href="#9-5-3-创建索引看效果" class="headerlink" title="9.5.3 创建索引看效果"></a>9.5.3 创建索引看效果</h5><p>准备大量数据，测试索引效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试索引效果</span></span><br><span class="line"><span class="keyword">create table</span> tb_index(</span><br><span class="line">id bigserial <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">36</span>),  <span class="comment">-- 修正为足够容纳 UUID</span></span><br><span class="line">phone <span class="type">VARCHAR</span>(<span class="number">64</span>)[]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加30w条数据测试效果（300w太慢，建议先测试30w）</span></span><br><span class="line">DO $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">i <span class="type">int</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">WHILE i <span class="operator">&lt;</span> <span class="number">300000</span> LOOP</span><br><span class="line">i :<span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> tb_index(name, phone)</span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">md5(random()::text <span class="operator">||</span> clock_timestamp()::text)::uuid,</span><br><span class="line"><span class="keyword">array</span>[random()::<span class="type">varchar</span>(<span class="number">64</span>)]</span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_index <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">22222</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_index <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;c6278y29178192192&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_index <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;c6278y29178192192&#x27;</span>;</span><br><span class="line"><span class="comment">-- Seq Scan 代表全表扫描</span></span><br></pre></td></tr></table></figure><p>这个时候我们创建一个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name 字段构建索引（默认是b-tree）</span></span><br><span class="line"><span class="keyword">create</span> index index_tb_index_name <span class="keyword">on</span> tb_index(name);</span><br><span class="line"><span class="comment">-- Index Scan (使用索引)</span></span><br></pre></td></tr></table></figure><p>包含查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_index <span class="keyword">where</span> phone @<span class="operator">&gt;</span> arrary[<span class="string">&#x27;12121212121&#x27;</span>::<span class="type">varchar</span>(<span class="number">63</span>)];</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_index <span class="keyword">where</span> phone @<span class="operator">&gt;</span> <span class="keyword">array</span>[<span class="string">&#x27;12121212121&#x27;</span>::<span class="type">varchar</span>(<span class="number">64</span>)];</span><br><span class="line"><span class="comment">-- Seq Scan 全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给phone字符串数组类型字段构建一个GIN索引</span></span><br><span class="line"><span class="keyword">create</span> index index_tb_index_phone_gin <span class="keyword">on</span> tb_index <span class="keyword">using</span> gin(phone);</span><br><span class="line"><span class="comment">-- Bitmap Index 位图扫描 </span></span><br></pre></td></tr></table></figure><h4 id="9-6-物化视图"><a href="#9-6-物化视图" class="headerlink" title="9.6 物化视图"></a>9.6 物化视图</h4><p>前面说过普通视图，本质就是一个SQL语句，普通的视图并不会本地磁盘存储任何物理。</p><p>每次查询视图都是执行这个SQL。效率有点低</p><p>物化视图从名字上就可以看出来，必然是要持久化一份数据的。使用套路和视图基本一致。这样一来查询物化视图，就想打关于查询一张单独的表，相比之前的普通视图，物化视图就不需要每次都查询复杂SQL，每次查询的都是真实的物理存储地址中的一份数据（表）。</p><p>物化视图因为会持久化到本地，完全脱离原来的表结构。</p><p>而且物化视图是可以单独设置索引等信息来提升物化视图的查询效率。</p><p>但是有好处也有坏处，更新时间不太好把握。如果更新频频繁，对数据库压力也不小。如果更新不频繁，会造成数据存在延迟问题，实时性就不好了。</p><p>如果要更新物化视图，可以采用触发器的形式，当原表中的数据被写后，可以通过触发器执行同步物化视图的操作，或者就基于定时任务去完成数据同步。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建物化视图</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> mv_test <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, price <span class="keyword">FROM</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mv_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 原表插入新数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;月饼&#x27;</span>, <span class="number">5.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时物化视图不会自动更新</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mv_test; <span class="comment">-- 看不到“月饼”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动刷新</span></span><br><span class="line">REFRESH MATERIALIZED <span class="keyword">VIEW</span> mv_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 现在可以看到“月饼”了</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mv_test;</span><br></pre></td></tr></table></figure><blockquote><p><strong>物化视图不会自动同步原表数据，必须手动 <code>REFRESH MATERIALIZED VIEW</code>。</strong></p></blockquote><p>如果你需要<strong>实时同步</strong>，应该用<strong>普通视图（VIEW）\</strong>或*<em>触发器+表*</em>的方案，而不是物化视图。</p><p>全量更新和增量更新</p><h3 id="十、事务"><a href="#十、事务" class="headerlink" title="十、事务"></a>十、事务</h3><p>什么是ACID</p><p>在日常操作中，对于一组相关操作，通常要求要么都成功，要么都失败。在关系型数据库中，称这一组操作为事务。为了保证整体事务的安全性，有ACID这一说：</p><ul><li>原子性A：事务是一个最小的执行单元，一次事务中的操作要么都成功，要么都失败</li><li>一致性C：在事务完成时，所有数据必须保持在一致的状态。（事务完成后，最终结果和预期结果一致）</li><li>隔离性：一次事务操作，要么时其他事务操作前的状态，要么其他事务操作后的状态，不存在中间状态。</li><li>持久性：事务提交后，数据会落到本地磁盘，修改是永久性的。</li></ul><p>PostgreSQL中，在事务的并发问题里，也是基于MVCC，多版本并发控制区维护数据的一致性。相比于传统的锁操作，MVCC最大的优点可以让读写互相不冲突。</p><p>当然PostgreSQL也支持表锁和行锁，可以解决写写的冲突。</p><p>PostgreSQL相比于其他数据，有一个比较大的优化，DDL也可以包含在一个事务中。比如集群中的操作，一个事务可以保证多个节点都构建出一个表，才算成功。</p><p><strong>事务的基本使用</strong></p><p>首先基于前面的各种操作，应该以及自动体会到了，PostgreSQL是自动提交事务。跟MySQL一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">set</span> AUTOCOMMIT off</span><br></pre></td></tr></table></figure><p>三个命令：</p><ul><li>begin</li><li>commit</li><li>rollback</li></ul><h5 id="10-3-保存点（了解）"><a href="#10-3-保存点（了解）" class="headerlink" title="10.3 保存点（了解）"></a>10.3 保存点（了解）</h5><p>比如项目中有一个大事务操作，不好控制，超时有影响，回滚会造成一切重来，成本太高。</p><p>我针对大事务，拆分成几个部分。第一部分完成后，构建一个保存点。如果后面操作失败了，需要回滚，不需要全盘回滚，回滚到之前的保存点，继续重试。</p><p>有人会发现，破坏了整体事务的原子性。</p><p>但是，只要操作合理，可以在保存点做充实，只要重试不成功，依然可以回滚；</p><h3 id="十一、并发问题"><a href="#十一、并发问题" class="headerlink" title="十一、并发问题"></a>十一、并发问题</h3><h5 id="11-1-事务的隔离级别"><a href="#11-1-事务的隔离级别" class="headerlink" title="11.1 事务的隔离级别"></a>11.1 事务的隔离级别</h5><p>在不考虑隔离性的前提下，事务的并发可能会出现的问题：</p><ul><li>脏读：读到了其他食物未提交的数据（必须避免这种情况）</li><li>不可重复读：同一事务中，多次查询同一数据，结果不一致，因为其他事务修改造成的。（一些业务中这种不可重复读不是问题）</li><li>幻读：同一事务中，多次查询同一数据，因为其他事务对数据进行了增删，导致出现了一些问题（一些业务中这种幻读不是问题）</li></ul><p>针对这些并发问题，关系型数据库有一些事务的隔离级别，一般用4种。</p><ul><li>READ UNCOMMITTED：读未提交（啥用没有，并且PGSQL没有，提供了只是为了完整性）</li><li>READ COMMITTED：读已提交，可以解决脏读（PGSQL默认隔离级别）</li><li>REPEATABLE READ：可重复读，可以解决脏读和不可重复读（MySQL默认是这个隔离级别，PGSQL也提供了，但是设置为可重复读，效果还是串行化）</li><li>SERIALIZABLE：串行化，啥都能解决（锁，效率慢）</li></ul><p>PGSQL在老版本种，只有两个隔离级别，读已提交和串行化。在PGSQL中不存在脏读问题。</p><h5 id="11-2-MVCC"><a href="#11-2-MVCC" class="headerlink" title="11.2 MVCC"></a>11.2 MVCC</h5><p>首先要搞清楚，为啥要有MVCC。</p><p>如果一个数据库，频繁的进行读写操作，为了保证安全，采用锁的机制。但是如果采用锁机制，如果一些事务在写数据，另外一个事务就无法读数据，会造成读写之间相互阻塞。大多的数据库都会采用一个机制多版本并发控制MVCC来解决这个问题。</p><p>比如你要查询一行数据，但是这行数据正在被修改，事务还没提交，如果此时对这行数据加锁，会导致其他的读操作阻塞，需要等待，如果采用PostgreSQL,他的内部会针对这一行保存多个版本，如果数正在被写入，让读操作区查询之前的版本，就不会阻塞。等写操作的事务提交了，读操作才能查看到最新的数据。这机制可以确保<strong>读写操作</strong>没有冲突，这就是MVCC的主要特点。</p><p><strong>写写操作，和MVCC没关系，哪个就是加锁！</strong></p><p>在操作之前，先了解一下PGSQL中，每张表都会自带两个字段</p><ul><li>xmin:给当前事务分配的数据版本。如果有其他事务做了写操作，并且提交事务了，就给xmin分配新的版本。</li><li>xmax：当前事务没有存在新版本，xmax就是0.如果有其他事务做了写操作，未提交事务，将写操作的版本放到xmax中</li></ul><p>把 PostgreSQL 的每一行数据想像成一张「小纸条」，纸条上除了记录真正的字段值（id、name …）外，还偷偷写了两个隐藏字段：</p><ul><li><strong>xmin</strong>：这行诞生的「出生证号」（创建它的事务号）</li><li><strong>xmax</strong>：这行注销的「死亡证号」（删除它的事务号，0 表示还没死）</li></ul><p>借助这两个号码，加上当前自己事务所拿到的「快照号」（snapshot），就能判断：</p><ol><li><strong>我能不能看到这一行？</strong></li><li><strong>这一行对别人来说是不是已经死了？</strong></li></ol><p>用纸条的故事串一遍图片里的 6 个瞬间</p><div class="table-container"><table><thead><tr><th style="text-align:left">时刻</th><th style="text-align:left">事务号</th><th style="text-align:left">纸条内容（id=1）</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Tx 100 刚开启</td><td style="text-align:left"><code>xmin=100, xmax=0, name=&#39;张三&#39;</code></td><td style="text-align:left">张三这张纸条是事务 100 刚生成的，目前没人删除。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Tx 100 再次看</td><td style="text-align:left">同上</td><td style="text-align:left">事务 100 用<strong>自己的快照</strong>看：xmin=100 ≤ 100 且 xmax=0，<strong>可见</strong>。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Tx 101 修改</td><td style="text-align:left">把 name 改成 “李四”，并<strong>生成新版本</strong></td><td style="text-align:left">旧纸条：xmin=100, xmax=101（被 101 删除）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">Tx 100 第三次看</td><td style="text-align:left">旧纸条：xmin=100, xmax=101</td><td style="text-align:left">100 的快照只认 ≤100 的出生证和未死亡的行。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Tx 101 提交</td><td style="text-align:left">删除与新增都<strong>正式生效</strong></td><td style="text-align:left">数据库里现在只有新纸条有效。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Tx 100 结束后再看</td><td style="text-align:left">新纸条：xmin=101, xmax=0</td><td style="text-align:left">此时 Tx 100 已经结束，拿的是新的快照。发现 xmin=101 大于旧快照号 100，<strong>看不到</strong>这条新生命，于是只能看到已提交的新版本，name 变成 “李四”。</td></tr></tbody></table></div><p>一句话总结</p><ul><li><strong>xmin ≤ 快照号 且 xmax = 0</strong> → 这行对我来说<strong>活着并且可见</strong>。</li><li><strong>xmax ≤ 快照号</strong> → 这行对我来说<strong>已经被删除</strong>。</li><li><strong>xmin &gt; 快照号</strong> → 这行在我出生之后才被创建，<strong>现在我还看不到</strong>。</li></ul><p>借助这一对隐藏字段，PostgreSQL 实现了 <strong>MVCC（多版本并发控制）</strong>：读写互不阻塞，每个事务看到的都是「属于自己的那一刻的世界」。</p><p>PostgreSQL中也提供了页锁，咨询所，但是这个不需要要关注，这个是为了锁的完整性。</p><h5 id="12-1-表锁"><a href="#12-1-表锁" class="headerlink" title="12.1 表锁"></a>12.1 表锁</h5><p>表锁显而易见，就是锁住整一张表。表锁也分很多种模式。</p><p>表锁的模式很多，其中最核心的两个：</p><ul><li>ACCESS SHARE ： 共享锁（读锁），读读操作不阻塞，但是不允许写操作并行</li><li>ACCESS EXCLUSIVE：互斥锁（写锁），无论什么操作进来都阻塞</li></ul><p>详细查看官网</p><p>ACCESS SHARE 让“大家一起读”；ACCESS EXCLUSIVE 让“谁也别动”。通过 <code>LOCK TABLE</code> 手动获取或在执行 SQL 时隐式获取，再用 <code>pg_locks</code> 一目了然地观察锁冲突即可。</p><h5 id="12-2-行锁"><a href="#12-2-行锁" class="headerlink" title="12.2 行锁"></a>12.2 行锁</h5><p>PostgreSQL的行锁和MySQL的基本一模一样的，基于select for update就可以指定行锁。</p><p>MySQL中有一个概念，for update时，如果select 的查询没有命中所以可能会锁表。</p><p>PostgreSQL有个特点，一般情况，在select的查询没有命中索引时，他不一定会锁表，然后会实现行锁。</p><p>PostgreSQL 行锁就两种：</p><ol><li><code>FOR UPDATE</code></li><li><code>FOR SHARE</code></li></ol><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于 FOR UPDATE 锁住 id = 3 的行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新该行</span></span><br><span class="line"><span class="keyword">UPDATE</span> test <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;vi&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，锁释放</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>其他会话若要锁同一行，会被阻塞。</p><h3 id="十三、备份-amp-恢复"><a href="#十三、备份-amp-恢复" class="headerlink" title="十三、备份&amp;恢复"></a>十三、备份&amp;恢复</h3><p>防止数据丢失的第一道防线就是备份。数据丢失有的是硬件损坏，还有人为的误删之类的，也有BUG的原因导致误删数据。</p><p>正常备份和恢复，如果公司有DBA，一般咱们不用参与，BUT,学的java，啥都得会点</p><p>在PostgreSQL中，有三种备份方式：</p><p><strong>SQL备份（逻辑备份）</strong>：其实就是利用数据库自带的类型dump的命令，或者时你用图形化界面执行导入导出时，底层就是基于这个dump命令实现的。备份出来一份sql文件，谁需要就复制给谁。</p><p>优点：简单，方便操作，有手就行，还挺可靠。</p><p>缺点：数据量如果比较大，这种方式巨慢。</p><p><strong>文件下同备份</strong>（物理备份）：其实就是找到当前数据优酷，数据文件在磁盘存储的位置，将数据文件直接复制一份或者多份，存储在不同的物理机上，即使物理机爆炸一个，还有其他物理机。</p><p>优点：相比逻辑备份，恢复的速度快。</p><p>缺点：在备份数据时，可能数据还在写入，一定程度上会丢失数据。在恢复数据时，也需要注意数据库的版本和环境必须保持高度的一致。如果是线上正在运行的数据库，这种复制的方式无法在生成环境实现。</p><p>如果说要做数据的迁移，这种方式还不错滴。</p><p><strong>归档备份：（也属于物理备份）</strong></p><p>先了解几个概念，在PostgreSQL有多个子进程来辅助一些操作</p><ul><li>BgWrite 进程：BgWrite是将内存中的数据写到磁盘中的一个辅助进程。当向数据库中执行写操作后，数据不会马上持久化到磁盘里。这个主要是为了提升性能。BgWriter会周期性的将内存中的数据写入到磁盘。但是这个周期时间，长了也不行，慢了也不行。<ul><li>如果快了，IO操作频繁，效率慢。</li><li>如果慢了，有查询操作需要内存中的数据时，需要BgWriter现把数据从内存写道磁盘中，再提供查询操作作为返回结果，会导致查询操作效率变低。</li><li>考虑一个问题：事务提交了 数据没有落磁盘，这时，服务器宕机了怎么办？</li></ul></li><li>WalWriter进程：WAL就是write ahead log的缩写，说人话就是预写日志（redo log）.其实数据还在内存中时，其实已经写入了WAL日志一份。这样依赖，即使BgWriter进程没写入到磁盘中时，数据也不好存在丢失的问题。<ul><li>WAL能单独做备份么？单独</li></ul></li></ul><p>待完成…</p><h3 id="十四、数据迁移、集群"><a href="#十四、数据迁移、集群" class="headerlink" title="十四、数据迁移、集群"></a>十四、数据迁移、集群</h3><p>待完成…</p><h2 id="SpringBoot-postgresql-mybatis"><a href="#SpringBoot-postgresql-mybatis" class="headerlink" title="SpringBoot+postgresql+mybatis"></a>SpringBoot+postgresql+mybatis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/PostgreSQL</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:postgresql://192.168.11.12:5432/1912</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.yangjiayu.bean</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/select&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapper.getUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapper.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapper.updateUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapper.deleteUser(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.yangjiayu.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from user_test</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">insert into</span><br><span class="line">user_test(name,age) values(#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">update user_test set</span><br><span class="line">age=#&#123;age&#125; where name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">delete from user_test</span><br><span class="line">where name=#&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-postgresql-mybatisplus"><a href="#SpringBoot-postgresql-mybatisplus" class="headerlink" title="SpringBoot+postgresql+mybatisplus"></a>SpringBoot+postgresql+mybatisplus</h2><p>我们创建一个 product 表，包含ID、名称、价格、库存和创建时间等字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接到你的数据库，然后执行以下 DDL 语句</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> product (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>, <span class="comment">-- 使用 BIGINT 和 IDENTITY 实现自增主键，这是 PostgreSQL 推荐的方式</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    stock <span class="type">INT</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    create_time <span class="type">TIMESTAMP</span> <span class="keyword">WITHOUT</span> <span class="type">TIME</span> ZONE <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="comment">-- 创建时间，默认为当前时间</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加一些注释，方便理解</span></span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">TABLE</span> product <span class="keyword">IS</span> <span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> product.id <span class="keyword">IS</span> <span class="string">&#x27;主键ID (自增)&#x27;</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> product.name <span class="keyword">IS</span> <span class="string">&#x27;商品名称&#x27;</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> product.price <span class="keyword">IS</span> <span class="string">&#x27;商品价格&#x27;</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> product.stock <span class="keyword">IS</span> <span class="string">&#x27;库存数量&#x27;</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> product.create_time <span class="keyword">IS</span> <span class="string">&#x27;创建时间&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为了测试，可以插入一些初始数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> product (name, price, stock) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;高性能笔记本电脑&#x27;</span>, <span class="number">7999.00</span>, <span class="number">50</span>),</span><br><span class="line">(<span class="string">&#x27;机械键盘&#x27;</span>, <span class="number">499.50</span>, <span class="number">200</span>),</span><br><span class="line">(<span class="string">&#x27;4K显示器&#x27;</span>, <span class="number">2599.00</span>, <span class="number">100</span>),</span><br><span class="line">(<span class="string">&#x27;无线鼠标&#x27;</span>, <span class="number">199.00</span>, <span class="number">300</span>),</span><br><span class="line">(<span class="string">&#x27;降噪耳机&#x27;</span>, <span class="number">1299.00</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>你可以通过 <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fstart.spring.io%2F">Spring Initializr</a> 快速创建一个项目。</p><p><strong>选择以下依赖：</strong></p><ul><li>Spring Web</li><li>MyBatis-Plus</li><li>PostgreSQL Driver</li><li>Lombok (强烈推荐，可以简化代码)</li></ul><p><strong>Maven 的 pom.xml 文件核心依赖如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot Web Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis-Plus Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用较新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- PostgreSQL JDBC Driver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Lombok for code simplification --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot Test Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 src/main/resources/ 目录下创建或修改 application.yml 文件，配置数据库连接和 MyBatis-Plus。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:postgresql:<span class="comment">//localhost:5432/your_database_name # 替换为你的数据库地址和名称</span></span><br><span class="line">    username: your_username # 替换为你的数据库用户名</span><br><span class="line">    password: your_password # 替换为你的数据库密码</span><br><span class="line">    driver-class-name: org.postgresql.Driver</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  # 如果你的 Mapper XML 文件放在特定位置，可以指定。对于纯注解和MP自带方法，此项可不配</span><br><span class="line">  mapper-locations: classpath:/mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">  # 配置驼峰命名转换</span></span><br><span class="line"><span class="comment">  configuration:</span></span><br><span class="line"><span class="comment">    map-underscore-to-camel-case: true</span></span><br><span class="line"><span class="comment">  global-config:</span></span><br><span class="line"><span class="comment">    db-config:</span></span><br><span class="line"><span class="comment">      # 配置主键策略为数据库自增</span></span><br><span class="line"><span class="comment">      id-type: auto</span></span><br></pre></td></tr></table></figure><h4 id="Entity-实体类"><a href="#Entity-实体类" class="headerlink" title=". Entity (实体类)"></a>. Entity (实体类)</h4><p>创建 com.example.demo.entity.Product 类。</p><ul><li>@TableName(“product”): 将类与数据库中的 product 表对应。</li><li>@TableId(type = IdType.AUTO): 声明 id 是主键，并且类型是数据库自增。</li><li>@Data: Lombok 注解，自动生成 Getter, Setter, toString() 等方法。</li><li>@TableField(“create_time”): 将 createTime 属性映射到 create_time 数据库列（如果开启了驼峰转换，此注解可省略）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库是 create_time，这里是 createTime，MP 会自动做驼峰转换</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 com.example.demo.mapper.ProductMapper 接口。</p><ul><li><strong>核心：</strong> 只需要继承 BaseMapper<Product>。</li><li>继承后，ProductMapper 就自动拥有了大量的 CRUD 方法，如 insert, selectById, updateById, deleteById, selectList, selectPage 等。你无需再写任何 XML 或 SQL！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.Product;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span> <span class="comment">// 或者在主启动类上使用 @MapperScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;</span><br><span class="line">    <span class="comment">// 无需编写任何方法，即可拥有强大的CRUD功能！</span></span><br><span class="line">    <span class="comment">// 如果有复杂的多表查询，可以在这里自定义方法，并使用 XML 或注解编写 SQL。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的 Spring Boot 主启动类上，添加 @MapperScan 注解来扫描 Mapper 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.demo.mapper&quot;)</span> <span class="comment">// 扫描 Mapper 接口所在的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 com.example.demo.controller.ProductController 类，提供 API 接口。</p><p>这里我们将重点展示 <strong>分页和排序</strong> 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.Product;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.mapper.ProductMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 新增商品</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span> &#123;</span><br><span class="line">        productMapper.insert(product);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据ID查询商品</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查询所有商品</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productMapper.selectList(<span class="literal">null</span>); <span class="comment">// 传入 null 表示无条件查询</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 更新商品</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123;</span><br><span class="line">        product.setId(id); <span class="comment">// 确保ID正确</span></span><br><span class="line">        productMapper.updateById(product);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 根据ID删除商品</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功&quot;</span> : <span class="string">&quot;删除失败，商品不存在&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 【重点】分页和排序查询</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Product&gt; <span class="title function_">getProductPage</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">long</span> current, // 当前页码，默认为<span class="number">1</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">long</span> size,   // 每页数量，默认为<span class="number">10</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String sortField, // 排序字段，如 <span class="string">&quot;price&quot;</span>, <span class="string">&quot;stock&quot;</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false, defaultValue = &quot;true&quot;)</span> <span class="type">boolean</span> isAsc // 是否升序，默认为是</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建分页对象</span></span><br><span class="line">        Page&lt;Product&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建查询条件构造器</span></span><br><span class="line">        QueryWrapper&lt;Product&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 处理排序</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(sortField)) &#123;</span><br><span class="line">            <span class="comment">// isAsc 为 true 则升序，false 则降序</span></span><br><span class="line">            queryWrapper.orderBy(<span class="literal">true</span>, isAsc, sortField);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 默认按创建时间降序</span></span><br><span class="line">            queryWrapper.orderByDesc(<span class="string">&quot;create_time&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行分页查询</span></span><br><span class="line">        <span class="comment">// selectPage 方法会自动完成分页逻辑和 COUNT 查询</span></span><br><span class="line">        <span class="keyword">return</span> productMapper.selectPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 要使 MyBatis-Plus 的分页功能生效，你需要配置一个分页插件。在 Spring Boot 中，这通常是自动配置的，但如果遇到问题，可以手动添加一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件，并指定数据库类型为 PostgreSQL</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.POSTGRE_SQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以启动 Spring Boot 应用程序了。启动后，使用 Postman 或 curl 等工具测试你的 API。</p><p><strong>1. 新增商品</strong><br>POST <a href="http://localhost:8080/products">http://localhost:8080/products</a><br>Body (JSON):</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;智能手表&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">899.00</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">150</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 分页查询（不带排序，默认按创建时间降序）</strong><br>GET <a href="http://localhost:8080/products/page?current=1&amp;size=3">http://localhost:8080/products/page?current=1&amp;size=3</a><br>你会得到第一页的3条数据。</p><p><strong>3. 分页并按价格升序排序</strong><br>GET <a href="http://localhost:8080/products/page?current=1&amp;size=3&amp;sortField=price&amp;isAsc=true">http://localhost:8080/products/page?current=1&amp;size=3&amp;sortField=price&amp;isAsc=true</a><br>返回的结果将是价格最低的3个商品。</p><p><strong>4. 分页并按库存降序排序</strong><br>GET <a href="http://localhost:8080/products/page?current=1&amp;size=3&amp;sortField=stock&amp;isAsc=false">http://localhost:8080/products/page?current=1&amp;size=3&amp;sortField=stock&amp;isAsc=false</a><br>返回的结果将是库存最高的3个商品。</p><p><strong>5. 查询 ID 为 2 的商品</strong><br>GET <a href="http://localhost:8080/products/2">http://localhost:8080/products/2</a></p><p><strong>6. 删除 ID 为 1 的商品</strong><br>DELETE <a href="http://localhost:8080/products/1">http://localhost:8080/products/1</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比你之前提供的 XML 方式，你会发现 MyBatis-Plus 的巨大优势：</p><ul><li></li><li><strong>代码极简</strong>：Mapper 接口继承 BaseMapper 后，无需编写任何 SQL 就能完成单表的 CRUD。</li><li><strong>功能强大</strong>：内置了分页、逻辑删除、乐观锁等高级功能，只需简单配置即可使用。</li><li><strong>条件构造器 (QueryWrapper)</strong>：可以非常灵活、安全地构建复杂的查询条件，避免了手动拼接 SQL 的风险和繁琐。</li><li><strong>无缝集成</strong>：与 Spring Boot 完美集成，配置简单，开箱即用。</li></ul><p>这个 Demo 完整地展示了如何使用 Spring Boot 和 MyBatis-Plus 操作 PostgreSQL 数据库，并实现了核心的分页和排序功能，希望能帮助你快速上手</p><p>\</p>]]></content>
    
    
    <summary type="html">PostgreSQL</summary>
    
    
    
    <category term="PostgreSQL" scheme="https://yjyrichard.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://yjyrichard.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yjyrichard.github.io/posts/0.html"/>
    <id>https://yjyrichard.github.io/posts/0.html</id>
    <published>2025-08-07T10:42:27.353Z</published>
    <updated>2025-08-11T22:35:35.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic-Programming"></a>Dynamic-Programming</h1><p>前言 </p><blockquote><p>The quote “Those who forget history are condemned to repeat it” is attributed to the American philosopher George Santayana and it can be accurately quoted as “Those who cannot remember the past are condemned to repeat it” as stated in his work, The Life of Reason: Reason in Common Sense.</p><p>“那些忘记历史的人注定重蹈覆辙”这句话出自美国哲学家乔治·桑塔亚那之手，准确地说，这句话可以被引用为他在《理性的生活:常识中的理性》一书中所说的“那些不记得过去的人注定重蹈覆辙”。  “Those who cannot remember the past are condemned to repeat it”  这句话忘记是在哪里看到的了,但是我觉得用在动态规划这个章节,真的很合适!</p></blockquote><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><blockquote><p> 我们可以先来看一个简单的例子,我们之前用递归的方法来求解斐波那契的第n项</p></blockquote><h4 id="1-Fibonacci"><a href="#1-Fibonacci" class="headerlink" title="1) Fibonacci"></a>1) Fibonacci</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> fibonacci(n-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./Dynamic-Programming.assets/image-20250807184526767.png" alt="image-20250807184526767"></p><p>重复计算了非常多的数据.</p><p>后来我们想要用记忆法来优化: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;使用 Memoization(记忆法, 也称备忘录) 改进&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第 n 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第 n 项的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>); <span class="comment">// [-1,-1,-1,-1,-1,-1]</span></span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// [0,1,-1,-1,-1,-1]</span></span><br><span class="line">        <span class="keyword">return</span> f(n, cache);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// f(3) =&gt; 5</span></span><br><span class="line">    <span class="comment">// f(4) =&gt; 9</span></span><br><span class="line">    <span class="comment">// f(5) =&gt; 15</span></span><br><span class="line">    <span class="comment">//         2*f(n+1) - 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cache)</span> &#123;</span><br><span class="line">        <span class="comment">/*if (n == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (n == 1) &#123;</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">if</span> (cache[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> f(n - <span class="number">1</span>, cache);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> f(n - <span class="number">2</span>, cache);</span><br><span class="line">        cache[n] = x + y; <span class="comment">// // [0,1,?,-1,-1,-1] 存入数组</span></span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划也是对递归过程进行改进,只是它是从另外一种方向进行改进,避免重复计算</p><p><img src="./Dynamic-Programming.assets/image-20250807184758795.png" alt="image-20250807184758795"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求斐波那契数列的第n项（动态规划）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fibonacci2(<span class="number">13</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要点1：</span></span><br><span class="line"><span class="comment">            从已知子问题的解，推导出当前问题的解</span></span><br><span class="line"><span class="comment">            推导过程可以表达为一个数学公式</span></span><br><span class="line"><span class="comment">        要点2：</span></span><br><span class="line"><span class="comment">            用一维或二维数组来保存之前的计算结果（可以进一步优化）</span></span><br><span class="line"><span class="comment">        Dynamic-Programming - 由 Bellman 提出</span></span><br><span class="line"><span class="comment">        动态     编程</span></span><br><span class="line"><span class="comment">            Programming - 在这里指用数学方法来根据子问题求解当前问题（通俗理解就是找到递推公式）</span></span><br><span class="line"><span class="comment">            Dynamic     - 指缓存上一步结果，根据上一步结果计算当前结果（多阶段进行）</span></span><br><span class="line"><span class="comment">        合在一起：</span></span><br><span class="line"><span class="comment">            找出递归公式，将当前问题分解成子问题，分阶段进行求解。</span></span><br><span class="line"><span class="comment">            求解过程中缓存子问题的解，避免重复计算。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// 用来缓存结果</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最短路径-Bellman-Ford"><a href="#2-最短路径-Bellman-Ford" class="headerlink" title="2) [最短路径] - Bellman-Ford"></a>2) [最短路径] - Bellman-Ford</h4><p><img src="./Dynamic-Programming.assets/image-20250808065626366.png" alt="image-20250808065626366"></p><p>假设要求v1—&gt;v4的最短距离是多少?</p><p><img src="./Dynamic-Programming.assets/image-20250808065654429.png" alt="image-20250808065654429"></p><blockquote><p>分析:</p><p> /*<br>            f(v) 用来表示从起点出发，到达 v 这个顶点的最短距离<br>            初始时<br>            f(v) = 0   当 v==起点 时<br>            f(v) = ∞   当 v!=起点 时</p><pre><code>        之后        新           旧     所有from        f(to) = min(f(to), f(from) + from.weight)        from 从哪来        to   到哪去        f(v4) = min( ∞, f(v3) + 11 ) = 20        f(v4) = min( 20, f(v2) + 15 ) = 20        v1  v2  v3  v4  v5  v6        0   ∞   ∞   ∞   ∞   ∞        0   7   9   ∞   ∞   14  第一轮        0   7   9   20  23  11  第二轮        0   7   9   20  20  11  第三轮        0   7   9   20  20  11  第四轮        0   7   9   20  20  11  第五轮 */</code></pre></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dynamic-Programming&quot;&gt;&lt;a href=&quot;#Dynamic-Programming&quot; class=&quot;headerlink&quot; title=&quot;Dynamic-Programming&quot;&gt;&lt;/a&gt;Dynamic-Programming&lt;/h1&gt;&lt;p&gt;前言</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>回溯Backtracking Algorithm</title>
    <link href="https://yjyrichard.github.io/posts/f31f0cc3.html"/>
    <id>https://yjyrichard.github.io/posts/f31f0cc3.html</id>
    <published>2025-08-06T13:10:35.517Z</published>
    <updated>2025-08-11T22:35:35.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯Backtracking-Algorithm"><a href="#回溯Backtracking-Algorithm" class="headerlink" title="回溯Backtracking Algorithm"></a>回溯Backtracking Algorithm</h1><h4 id="1-入门例子"><a href="#1-入门例子" class="headerlink" title="1) 入门例子"></a>1) 入门例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 程序在运行过程中分成了多个阶段</span></span><br><span class="line"><span class="comment"> * 通过某些手段,将数据恢复到之前某一阶段,这就称之为回溯</span></span><br><span class="line"><span class="comment"> * 手段包括</span></span><br><span class="line"><span class="comment"> *      方法栈</span></span><br><span class="line"><span class="comment"> *      自定义栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backtracking</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        rec(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        rec(n+<span class="number">1</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是集合又有什么样的效果呢?</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果用的是可变的集合或者数组必须手动的恢复集合状态</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backtracking</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        rec(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;before:&quot;</span> + list);</span><br><span class="line">        list.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        rec(n + <span class="number">1</span>, list);</span><br><span class="line">        list.pop();</span><br><span class="line">        System.out.println(<span class="string">&quot;after:&quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rec</span><span class="params">(<span class="number">1</span>, [])</span></span></span><br><span class="line">├── before: <span class="selector-attr">[]</span></span><br><span class="line">├── push <span class="string">&quot;a&quot;</span> → <span class="built_in">rec</span>(<span class="number">2</span>, <span class="selector-attr">[<span class="string">&quot;a&quot;</span>]</span>)</span><br><span class="line">│   ├── before: <span class="selector-attr">[a]</span></span><br><span class="line">│   ├── push <span class="string">&quot;a&quot;</span> → <span class="built_in">rec</span>(<span class="number">3</span>, <span class="selector-attr">[a, a]</span>)</span><br><span class="line">│   │   └── n == <span class="number">3</span> → return</span><br><span class="line">│   ├── pop → <span class="selector-attr">[a]</span></span><br><span class="line">│   └── after: <span class="selector-attr">[a]</span></span><br><span class="line">├── pop → <span class="selector-attr">[]</span></span><br><span class="line">└── after: <span class="selector-attr">[]</span></span><br></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before:<span class="comment">[]</span></span><br><span class="line">before:<span class="comment">[a]</span></span><br><span class="line">after:<span class="comment">[a]</span></span><br><span class="line">after:<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>这段代码虽然简单，但<strong>完整地展示了回溯的三步</strong>：</p><blockquote><p><strong>选择 → 递归 → 撤销</strong>，最终输出是：</p></blockquote><h4 id="2-全排列-Leetcode-46"><a href="#2-全排列-Leetcode-46" class="headerlink" title="2) 全排列-Leetcode 46"></a>2) 全排列-<a href="https://leetcode.cn/">Leetcode</a> 46</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[0,1],[1,0]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[]</span></span><br><span class="line">├── <span class="number">1</span></span><br><span class="line">│   ├── <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">│   │   └── <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">│   └── <span class="number">1</span>,<span class="number">3</span></span><br><span class="line">│       └── <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line">├── <span class="number">2</span></span><br><span class="line">│   ├── <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">│   │   └── <span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">│   └── <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">│       └── <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span></span><br><span class="line">└── <span class="number">3</span></span><br><span class="line">    ├── <span class="number">3</span>,<span class="number">1</span></span><br><span class="line">    │   └── <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    └── <span class="number">3</span>,<span class="number">2</span></span><br><span class="line">        └── <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode46</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        rec(nums, visited, stack, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) &#123;</span><br><span class="line">            r.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            rec(nums, visited, stack, r);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permute(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; s : permute) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-全排列II-Leetcode-47"><a href="#3-全排列II-Leetcode-47" class="headerlink" title="3) 全排列II-Leetcode 47"></a>3) 全排列II-Leetcode 47</h4><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[<span class="comment">[1,1,2]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[1,2,1]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[2,1,1]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        []</span><br><span class="line">       / <span class="string">\</span></span><br><span class="line">      <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">   /    <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">  <span class="number">11</span><span class="string">&#x27;    13  31</span></span><br><span class="line"><span class="string"> / \     |    \</span></span><br><span class="line"><span class="string">11&#x27;</span><span class="number">3</span>   <span class="number">131</span><span class="string">&#x27;   311&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>根节点</strong>：<code>[]</code> 表示空排列，即还没有选择任何数字。</li><li><strong>第一层</strong>：从根节点开始，我们有两个选择：<code>1</code> 和 <code>3</code>。这是因为数组中有两个不同的数字。</li><li><strong>第二层</strong>：<ul><li>选择 <code>1</code> 后，我们再次面临选择：<code>1&#39;</code>（表示另一个 <code>1</code>）和 <code>3</code>。</li><li>选择 <code>3</code> 后，我们只有选择 <code>1</code> 和 <code>1&#39;</code>。</li></ul></li><li><strong>第三层</strong>：<ul><li>从 <code>1</code> 和 <code>1&#39;</code>，我们可以得到排列 <code>11&#39;3</code> 和 <code>131&#39;</code>。</li><li>从 <code>3</code> 和 <code>1</code>，我们可以得到排列 <code>31</code> 和 <code>311&#39;</code>。</li></ul></li><li><strong>叶节点</strong>：这些叶节点表示完整的排列，如 <code>11&#39;3</code>，<code>131&#39;</code>，<code>31</code>，<code>311&#39;</code>。</li></ol><h3 id="避免重复排列："><a href="#避免重复排列：" class="headerlink" title="避免重复排列："></a>避免重复排列：</h3><ul><li>在选择下一个数字时，我们使用了一个技巧来避免重复。例如，当我们已经选择了 <code>1</code>，我们不会再次选择 <code>1</code>，直到我们已经选择了 <code>3</code>。这样可以确保每个排列都是唯一的。</li><li>在代码实现中，这通常通过在递归调用前检查当前数字是否已经被选择来实现。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode47</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) &#123; <span class="comment">// 找出重复数字</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, visited, stack, result);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permuteUnique(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : permute) &#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排好序，这样重复的数字会相邻</p><p>定好规则：必须 1 固定之后才能固定 1’，即 1 的 visited = true 才能继续处理 1’</p><p>在遍历时，遇到了 nums[i] == nums[i - 1]（即 1 和 1‘ 这种情况），进一步检查 i-1 位置的数字有没有 visited，没有，则不处理（剪枝）<br>也可以看我CSDN博客</p><p>原文链接：<a href="https://blog.csdn.net/2301_79602614/article/details/138347128">https://blog.csdn.net/2301_79602614/article/details/138347128</a></p><h4 id="4-组合-Leetcode-77"><a href="#4-组合-Leetcode-77" class="headerlink" title="4) 组合-Leetcode 77"></a>4) 组合-Leetcode 77</h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,4]</span>,</span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt;stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>,n,k,stack,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> n,<span class="type">int</span> k,LinkedList&lt;Integer&gt;stack,List&lt;List&lt;Integer&gt;&gt;result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.size()==k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=n;i++)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(i+<span class="number">1</span>,n,k,stack,result);</span><br><span class="line">            stack.pop();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs(i+1,n,k,stack,result); 如果改为：dfs(1,n,k,stack,result);</p><p>改为：dfs(i,n,k,stack,result); 情况都不同 可以自行体悟一下</p><p>减枝</p><p>如果缺的数字大于备用数字 那么就要剪枝剪掉</p><p>k- stack.length 还差几个能凑满</p><p>n - i +1 还剩下几个备用数字  if(k-stack.length &gt;n-i+1) continue;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt;stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>,n,k,stack,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> n,<span class="type">int</span> k,LinkedList&lt;Integer&gt;stack,List&lt;List&lt;Integer&gt;&gt;result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.size()==k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k - stack.size() &gt; n-i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(i+<span class="number">1</span>,n,k,stack,result);</span><br><span class="line">            stack.pop();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode77</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      if (k &gt; n - start + 1) &#123; return; &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">//            System.out.printf(&quot;k-1=%d n=%d i=%d %n&quot;, k - 1, n, i);</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; n - i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        for (List&lt;Integer&gt; list : lists) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(list);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>k 代表剩余要组合的个数</p><p>n - i + 1 代表剩余可用数字</p><p>剪枝条件是：剩余可用数字要大于剩余组合数</p><p>为啥放在外面不行？即这行代码：if (k &gt; n - start + 1) { return; }</p><p>因为它只考虑了 start 一种情况，而实际在循环内要处理的是 start，start+1 … n 这多种情况</p><p>似乎 ArrayList 作为 stack 性能高一些，见下面代码，但是这道题在 leetcode 上执行时间不稳定，相同代码都会有较大时间差异（15ms vs 9ms）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n &lt; k) <span class="keyword">return</span> result;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, ArrayList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k-<span class="number">1</span> &gt; n - i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.add(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-组合总和-Leetcode-39"><a href="#5-组合总和-Leetcode-39" class="headerlink" title="5) 组合总和-Leetcode 39"></a>5) 组合总和-Leetcode 39</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; stack= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,candidates,target,stack,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] candidates,<span class="type">int</span> target,LinkedList&lt;Integer&gt;stack,List&lt;List&lt;Integer&gt;&gt;result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(i,candidates,target-candidate,stack,result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的零钱兑换问题其实是一样的，只是</p><ul><li>本题求的是：所有组合的具体信息</li><li>零钱兑换问题求的是：所有组合中数字最少的、所有组合个数… [动态规划]</li></ul><h4 id="6-组合总和-II-Leetcode-40"><a href="#6-组合总和-II-Leetcode-40" class="headerlink" title="6) 组合总和 II-Leetcode 40"></a>6) 组合总和 II-Leetcode 40</h4><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,1,6]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,5]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,7]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[2,6]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,5,2,1,2]</span>, target = 5,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode40</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(target, <span class="number">0</span>, candidates, <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidate) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidate == candidates[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(target - candidate, i + <span class="number">1</span>, candidates, visited, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candidates = &#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(candidates, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) &#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-组合总和-III-Leetcode-216"><a href="#7-组合总和-III-Leetcode-216" class="headerlink" title="7) 组合总和 III-Leetcode 216"></a>7) 组合总和 III-Leetcode 216</h4><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong> </li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: <span class="string">[[1,2,4]]</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 +<span class="number"> 2 </span>+<span class="number"> 6 </span>= 9</span><br><span class="line">1 +<span class="number"> 3 </span>+<span class="number"> 5 </span>= 9</span><br><span class="line">2 +<span class="number"> 3 </span>+<span class="number"> 4 </span>= 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: k = 4, n = 1</span></span><br><span class="line"><span class="section">输出: []</span></span><br><span class="line"><span class="section">解释: 不存在有效的组合。</span></span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> target )</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>,target,k,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static int count = 0;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> target,<span class="type">int</span> k,ArrayList&lt;Integer&gt;stack,List&lt;List&lt;Integer&gt;&gt;result)</span>&#123;</span><br><span class="line">       <span class="comment">// count++;</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;stack.size()==k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 还差几个数字       剩余可用数字</span></span><br><span class="line">          <span class="comment">//  if(k-stack.size() &gt; 9-i+1)&#123;</span></span><br><span class="line">            <span class="comment">//    continue;</span></span><br><span class="line">            <span class="comment">//&#125; 这个减枝效率较低 设置一个count变量即可查看</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.size()==k)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">            dfs(i+<span class="number">1</span>,target-i,k,stack,result);</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-N-皇后Leetcode-51"><a href="#8-N-皇后Leetcode-51" class="headerlink" title="8) N 皇后Leetcode 51"></a>8) N 皇后Leetcode 51</h4><p>Eight queens 高斯认为有76种方案。实际上解有92种。</p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：[[<span class="string">&quot;.Q..&quot;</span>,<span class="string">&quot;...Q&quot;</span>,<span class="string">&quot;Q...&quot;</span>,<span class="string">&quot;..Q.&quot;</span>],[<span class="string">&quot;..Q.&quot;</span>,<span class="string">&quot;Q...&quot;</span>,<span class="string">&quot;...Q&quot;</span>,<span class="string">&quot;.Q..&quot;</span>]]</span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[&quot;Q&quot;]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><p>左斜线处理i+j </p><p>右斜线i-j  = n-1-（i-j）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];<span class="comment">//&#x27;.&#x27; &#x27;Q&#x27;</span></span><br><span class="line">        <span class="type">boolean</span>[] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//列冲突</span></span><br><span class="line">        <span class="type">boolean</span>[] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];<span class="comment">//左斜线冲突</span></span><br><span class="line">        <span class="type">boolean</span>[] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];<span class="comment">//右斜线冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(table[i], <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result, va, vb, vc);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result, <span class="type">boolean</span>[] va, <span class="type">boolean</span>[] vb, <span class="type">boolean</span>[] vc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) &#123;</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (va[j] || vb[i + j] || vc[n - <span class="number">1</span>-(i-j)]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            va[j] = <span class="literal">true</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">true</span>;</span><br><span class="line">            vc[n-<span class="number">1</span>-(i-j)] = <span class="literal">true</span>;</span><br><span class="line">            table[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result, va, vb, vc);</span><br><span class="line">            table[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            va[j] = <span class="literal">false</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">false</span>;</span><br><span class="line">            vc[i - j + n - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">4</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String row : table) &#123;</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------- &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(table[i], <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) &#123;</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notValid(table, i, j)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            table[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result);</span><br><span class="line">            table[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   ?   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">notValid</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123; <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">8</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String row : table) &#123;</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------- &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-解数独-Leetcode37"><a href="#9-解数独-Leetcode37" class="headerlink" title="9) 解数独-Leetcode37"></a>9) 解数独-Leetcode37</h4><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],[<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>],[<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>],[<span class="string">&quot;4&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>],[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>],[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;5&quot;</span>],[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>]]</span><br><span class="line">输出：[[<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>],[<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;8&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>],[<span class="string">&quot;8&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>],[<span class="string">&quot;4&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;7&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>],[<span class="string">&quot;9&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;4&quot;</span>],[<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;5&quot;</span>],[<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><p>判断在那个九宫格 ==&gt; i/3*3+j/3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1.不断遍历每个未填的空格</span></span><br><span class="line"><span class="comment">           逐一尝试1~9 若行,列,九宫格内没有冲突,则填入</span></span><br><span class="line"><span class="comment">       2.一旦1~9 都尝试失败,回溯到上一次状态,换数字填入</span></span><br><span class="line"><span class="comment">       3.关键还是要记录冲突状态</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 行冲突状态</span></span><br><span class="line">       <span class="type">boolean</span>[][] ca =<span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">       <span class="comment">// ca[i] = &#123;false,false,true,true,true,true...&#125;</span></span><br><span class="line">       <span class="comment">// 列冲突状态</span></span><br><span class="line">       <span class="type">boolean</span>[][] cb = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">       <span class="comment">// cb[j] = &#123;false,true,true....&#125;</span></span><br><span class="line">       <span class="comment">// 九宫格冲突状态</span></span><br><span class="line">       <span class="comment">//i/3*3+j/3 = ..在几号九宫格</span></span><br><span class="line">       <span class="type">boolean</span>[][] cc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">       <span class="comment">//cc[i/3*3+j/3] = &#123;...&#125;</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">               <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> table[i][j];</span><br><span class="line">               <span class="keyword">if</span>(ch!=<span class="string">&#x27;.&#x27;</span>)&#123;<span class="comment">//初始化冲突状态</span></span><br><span class="line">                   ca[i][ch-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;     <span class="comment">//&#x27;5&#x27;- &#x27;1&#x27; --&gt; 4</span></span><br><span class="line">                   cb[j][ch-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                   cc[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][ch-<span class="string">&#x27;1&#x27;</span>] =<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(<span class="number">0</span>,<span class="number">0</span>,table,ca,cb,cc);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span>[][] table,<span class="type">boolean</span>[][] ca,<span class="type">boolean</span>[][] cb,<span class="type">boolean</span>[][] cc)</span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(table[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">//查找下一个空格</span></span><br><span class="line">           <span class="keyword">if</span>(++j&gt;=<span class="number">9</span>)&#123;</span><br><span class="line">               j=<span class="number">0</span>;</span><br><span class="line">               i++;<span class="comment">//到下一行</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;=<span class="number">9</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//找到解了</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//填空</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">           <span class="comment">//检查冲突</span></span><br><span class="line">           <span class="keyword">if</span>(ca[i][x-<span class="number">1</span>]||cb[j][x-<span class="number">1</span>]||cc[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           table[i][j] =(<span class="type">char</span>)x+<span class="string">&#x27;0&#x27;</span>;   <span class="comment">//1 -&gt; &#x27;1&#x27;</span></span><br><span class="line">           <span class="comment">//ca[0][0] = true;  第0行不能存储&#x27;1&#x27;</span></span><br><span class="line">           <span class="comment">//cb[2][0] = true;  第2列不能存储&#x27;1&#x27;</span></span><br><span class="line">           <span class="comment">//cc[0][0] = true;  第0个九宫格不能存储&#x27;1&#x27;</span></span><br><span class="line">           ca[i][x-<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">           cb[j][x-<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">           cc[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x-<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">if</span>(dfs(i,j,table,ca,cb,cc))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           table[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">           ca[i][x-<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">           cb[j][x-<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">           cc[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x-<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];<span class="comment">//行冲突</span></span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];<span class="comment">//列冲突</span></span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];<span class="comment">//九宫格冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(table, va, vb, vc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (table[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++j &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (va[i][d] || vb[j][d] || vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">            table[i][j] = ch;</span><br><span class="line">            va[i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(table, va, vb, vc, i, j);</span><br><span class="line">            <span class="keyword">if</span> (dfs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            table[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            va[i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] table = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        solveSudoku(table);</span><br><span class="line"> </span><br><span class="line">        print(table);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> &#123;</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Pair</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];</span><br><span class="line">        List&lt;Pair&gt; blanks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    blanks.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, blanks, table, va, vb, vc);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> p, List&lt;Pair&gt; blanks, <span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == blanks.size()) &#123;</span><br><span class="line">            print(table);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) &#123;</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> blanks.get(p);</span><br><span class="line">            <span class="keyword">if</span> (va[pair.i][d] || vb[pair.j][d] || vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">            table[pair.i][pair.j] = ch;</span><br><span class="line">            va[pair.i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(p + <span class="number">1</span>, blanks, table, va, vb, vc);</span><br><span class="line">            <span class="keyword">if</span> (dfs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            table[pair.i][pair.j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            va[pair.i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] table = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        solveSudoku(table);</span><br><span class="line"> </span><br><span class="line">        print(table);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-黄金矿工-Leetcode1219"><a href="#10-黄金矿工-Leetcode1219" class="headerlink" title="10) 黄金矿工-Leetcode1219"></a>10) 黄金矿工-Leetcode1219</h4><p><a href="https://leetcode.cn/problems/path-with-maximum-gold/description/">1219. 黄金矿工 - 力扣（LeetCode）</a></p><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 <code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><ul><li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li><li>矿工每次可以从当前位置向上下左右四个方向走。</li><li>每个单元格只能被开采（进入）一次。</li><li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。</li><li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,6,0],[5,8,7],[0,9,0]]</span></span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line"><span class="string">[[0,6,0],</span></span><br><span class="line"><span class="string"> [5,8,7],</span></span><br><span class="line"><span class="string"> [0,9,0]]</span></span><br><span class="line">一种收集最多黄金的路线是：<span class="number">9</span> -&gt; <span class="number">8</span> -&gt; <span class="number">7</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[1,0,7]</span>,<span class="comment">[2,0,6]</span>,<span class="comment">[3,4,5]</span>,<span class="comment">[0,3,0]</span>,<span class="comment">[9,0,20]</span>]</span></span><br><span class="line">输出：28</span><br><span class="line">解释：</span><br><span class="line"><span class="comment">[<span class="comment">[1,0,7]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[2,0,6]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[3,4,5]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[0,3,0]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[9,0,20]</span>]</span></span><br><span class="line">一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 15</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li><li>最多 <strong>25</strong> 个单元格中有黄金。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] g;</span><br><span class="line">    <span class="type">boolean</span>[][] vis;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumGold</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        m = g.length;n = g[<span class="number">0</span>].length;</span><br><span class="line">        vis= <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans = Math.max(ans,dfs(i,j));</span><br><span class="line">                    vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> g[x][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d:dirs)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x+d[<span class="number">0</span>],ny = y+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||nx&gt;=m||ny&lt;<span class="number">0</span>||ny&gt;=n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">            ans = Math.max(ans,g[x][y] + dfs(nx,ny));</span><br><span class="line">            vis[nx][ny] =<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-543"><a href="#LeetCode-543" class="headerlink" title="LeetCode 543"></a>LeetCode 543</h4><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1,2,3,4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> ，取路径 [<span class="number">4,2,1,3</span>] 或 [<span class="number">5,2,1,3</span>] 的长度。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：root </span>=<span class="string"> [1,2]</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 104]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode u)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> dfs(u.left),r=dfs(u.right);</span><br><span class="line">        ans = Math.max(ans,l+r);</span><br><span class="line"><span class="comment">//返回最大深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode433"><a href="#LeetCode433" class="headerlink" title="LeetCode433"></a>LeetCode433</h4><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 <code>&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 之一。</p><p>假设我们需要调查从基因序列 <code>start</code> 变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p><ul><li>例如，<code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> 就是一次基因变化。</li></ul><p>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p><p>给你两个基因序列 <code>start</code> 和 <code>end</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使 <code>start</code> 变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p><p>注意：起始基因序列 <code>start</code> 默认是有效的，但是它并不一定会出现在基因库中。</p><p><strong>示例 1：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>start.length == 8</code></li><li><code>end.length == 8</code></li><li><code>0 &lt;= bank.length &lt;= 10</code></li><li><code>bank[i].length == 8</code></li><li><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code> 组成</li></ul><blockquote><p>这道题目是一个典型的<strong>最短路径问题</strong>，但是它在基因序列的背景下进行。题目要求我们找到从基因序列 <code>start</code> 变化到 <code>end</code> 的最少变化次数。这里的“变化”指的是基因序列中的一个字符发生了变化。题目中还提供了一个基因库 <code>bank</code>，只有基因库中的基因序列才是有效的，即变化后的基因序列必须出现在基因库中。</p><h3 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h3><ol><li><strong>基因序列</strong>：由8个字符组成，每个字符可以是 ‘A’、’C’、’G’ 或 ‘T’。</li><li><strong>基因变化</strong>：指的是基因序列中的一个字符发生了变化，例如 “AACCGGTT” 变为 “AACCGGTA”。</li><li><strong>基因库 <code>bank</code></strong>：记录了所有有效的基因变化，只有出现在 <code>bank</code> 中的基因序列才是有效的。</li><li><strong>目标</strong>：找到从 <code>start</code> 变化到 <code>end</code> 所需的最少变化次数。如果无法完成变化，返回 -1。</li><li><strong>输入</strong>：<ul><li><code>start</code>：起始基因序列。</li><li><code>end</code>：目标基因序列。</li><li><code>bank</code>：有效的基因序列列表。</li></ul></li><li><strong>输出</strong>：最少变化次数，如果无法完成变化，则返回 -1。</li></ol><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><ul><li><strong>示例 1</strong>：从 “AACCGGTT” 到 “AACCGGTA” 只需要一次变化，因为 “AACCGGTA” 在基因库中。</li><li><strong>示例 2</strong>：从 “AACCGGTT” 到 “AAACGGTA” 需要两次变化，可能的路径是 “AACCGGTT” → “AACCGCTA” → “AAACGGTA”，这两个中间基因序列都在基因库中。</li><li><strong>示例 3</strong>：从 “AAAAACCC” 到 “AACCCCCC” 需要三次变化，可能的路径是 “AAAAACCC” → “AAAACCCC” → “AAACCCCC” → “AACCCCCC”，这三个中间基因序列都在基因库中。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目中提供的代码使用了<strong>回溯法</strong>来解决这个问题。以下是代码的逻辑解释：</p><ol><li><strong>初始化</strong>：<code>ans</code> 用于存储最少变化次数，初始值为 <code>Integer.MAX_VALUE</code>。</li><li><strong>递归函数 <code>backtrack</code></strong>：<ul><li>参数 <code>start</code>：当前基因序列。</li><li>参数 <code>end</code>：目标基因序列。</li><li>参数 <code>bank</code>：基因库。</li><li>参数 <code>used</code>：一个布尔数组，用于标记基因库中的哪些基因序列已经被使用过。</li><li>参数 <code>t</code>：当前的变化次数。</li></ul></li><li><strong>递归终止条件</strong>：<ul><li>如果当前变化次数 <code>t</code> 已经大于等于 <code>ans</code>，则直接返回，因为不可能找到更短的路径。</li><li>如果当前基因序列 <code>start</code> 等于目标基因序列 <code>end</code>，则更新 <code>ans</code> 为当前的最小变化次数。</li></ul></li><li><strong>递归搜索</strong>：<ul><li>遍历基因库 <code>bank</code>，对于每个基因序列，检查它是否与当前基因序列 <code>start</code> 只有一个字符不同（即变化次数为1）。</li><li>如果找到这样的基因序列，标记为已使用，递归调用 <code>backtrack</code> 函数，尝试找到从这个基因序列变化到 <code>end</code> 的最少变化次数。</li><li>递归完成后，取消标记（回溯），以便其他路径可以使用这个基因序列。</li></ul></li><li><strong>返回结果</strong>：<ul><li>如果 <code>ans</code> 仍然是 <code>Integer.MAX_VALUE</code>，说明无法从 <code>start</code> 变化到 <code>end</code>，返回 -1。</li><li>否则，返回 <code>ans</code>。</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个全局变量ans来存储从start到end的最少变化次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 主函数，接收起始基因序列start，目标基因序列end和基因库bank作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String start, String end, String[] bank)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用回溯函数，从start开始寻找到end的最少变化次数</span></span><br><span class="line">        backtrack(start, end, bank, <span class="keyword">new</span> <span class="title class_">boolean</span>[bank.length], <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果ans仍然是初始值，说明没有找到从start到end的路径，返回-1</span></span><br><span class="line">        <span class="comment">// 否则返回找到的最少变化次数</span></span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 回溯函数，用于递归地寻找从start到end的最少变化次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String start, String end, String[] bank, <span class="type">boolean</span>[] used, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前的步数t已经大于等于已知的最少步数ans，则直接返回，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果当前的基因序列start已经等于目标基因序列end，更新ans为当前步数t</span></span><br><span class="line">        <span class="keyword">if</span> (start.equals(end)) &#123;</span><br><span class="line">            ans = Math.min(ans, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历基因库bank中的每一个基因序列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, diff = <span class="number">0</span>; i &lt; bank.length; i++, diff = <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前基因序列已经被使用过，则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 计算当前基因序列与start的差异，如果差异为1，则表示可以通过一次变化从start变为当前基因序列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; start.length(); j++) </span><br><span class="line">                    diff += start.charAt(j) != bank[i].charAt(j) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 如果差异为1，表示可以通过一次变化从start变为当前基因序列</span></span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 标记当前基因序列为已使用</span></span><br><span class="line">                    used[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 递归调用回溯函数，尝试从当前基因序列变化到end</span></span><br><span class="line">                    backtrack(bank[i], end, bank, used, t + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 回溯，取消当前基因序列的已使用标记，以便其他路径可以使用</span></span><br><span class="line">                    used[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong><code>diff</code> 的作用</strong>：<ul><li><code>diff</code> 用于计算当前基因序列 <code>start</code> 和基因库中的某个基因序列 <code>bank[i]</code> 之间的差异。</li><li>具体来说，<code>diff</code> 计算的是两个序列中对应位置上不同字符的个数。</li><li>如果 <code>diff</code> 等于 1，表示两个序列之间只有一个字符不同，即可以通过一次变化从 <code>start</code> 变为 <code>bank[i]</code>。</li></ul></li><li><strong><code>bank</code> 的使用</strong>：<ul><li><code>bank</code> 是一个数组，包含了所有有效的基因序列。</li><li>在回溯过程中，我们遍历 <code>bank</code> 中的每个基因序列，检查它是否可以作为从 <code>start</code> 到 <code>end</code> 的一个中间步骤。</li><li>只有当 <code>bank[i]</code> 与 <code>start</code> 的差异为 1 时，<code>bank[i]</code> 才会被考虑作为下一步。</li></ul></li></ol><p>举例说明</p><p>假设我们有以下输入：</p><ul><li><code>start = &quot;AACCGGTT&quot;</code></li><li><code>end = &quot;AAACGGTA&quot;</code></li><li><code>bank = [&quot;AACCGGTA&quot;, &quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;]</code></li></ul><h4 id="步骤-1：初始化"><a href="#步骤-1：初始化" class="headerlink" title="步骤 1：初始化"></a>步骤 1：初始化</h4><ul><li><code>ans = Integer.MAX_VALUE</code>（初始的最少变化次数设为最大整数值）</li></ul><h4 id="步骤-2：第一次调用-backtrack"><a href="#步骤-2：第一次调用-backtrack" class="headerlink" title="步骤 2：第一次调用 backtrack"></a>步骤 2：第一次调用 <code>backtrack</code></h4><ul><li><code>backtrack(&quot;AACCGGTT&quot;, &quot;AAACGGTA&quot;, bank, new boolean[bank.length], 0)</code></li></ul><h4 id="步骤-3：遍历-bank"><a href="#步骤-3：遍历-bank" class="headerlink" title="步骤 3：遍历 bank"></a>步骤 3：遍历 <code>bank</code></h4><ul><li>计算 <code>start</code> 和每个 <code>bank[i]</code> 的差异 <code>diff</code>：<ul><li><code>diff(&quot;AACCGGTT&quot;, &quot;AACCGGTA&quot;) = 2</code>（两个字符不同）</li><li><code>diff(&quot;AACCGGTT&quot;, &quot;AACCGCTA&quot;) = 1</code>（一个字符不同）</li><li><code>diff(&quot;AACCGGTT&quot;, &quot;AAACGGTA&quot;) = 2</code>（两个字符不同）</li></ul></li><li>只有 <code>&quot;AACCGCTA&quot;</code> 的 <code>diff</code> 为 1，因此我们选择它作为下一步。</li></ul><h4 id="步骤-4：递归调用-backtrack"><a href="#步骤-4：递归调用-backtrack" class="headerlink" title="步骤 4：递归调用 backtrack"></a>步骤 4：递归调用 <code>backtrack</code></h4><ul><li><code>used[1] = true</code>（标记 “AACCGCTA” 为已使用）</li><li><code>backtrack(&quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;, bank, used, 1)</code></li></ul><h4 id="步骤-5：再次遍历-bank"><a href="#步骤-5：再次遍历-bank" class="headerlink" title="步骤 5：再次遍历 bank"></a>步骤 5：再次遍历 <code>bank</code></h4><ul><li>计算 <code>&quot;AACCGCTA&quot;</code> 和每个 <code>bank[i]</code> 的差异 <code>diff</code>：<ul><li><code>diff(&quot;AACCGCTA&quot;, &quot;AACCGGTA&quot;) = 2</code></li><li><code>diff(&quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;) = 1</code></li></ul></li><li>只有 <code>&quot;AAACGGTA&quot;</code> 的 <code>diff</code> 为 1，因此我们选择它作为下一步。</li></ul><h4 id="步骤-6：再次递归调用-backtrack"><a href="#步骤-6：再次递归调用-backtrack" class="headerlink" title="步骤 6：再次递归调用 backtrack"></a>步骤 6：再次递归调用 <code>backtrack</code></h4><ul><li><code>used[2] = true</code>（标记 “AAACGGTA” 为已使用）</li><li><code>backtrack(&quot;AAACGGTA&quot;, &quot;AAACGGTA&quot;, bank, used, 2)</code></li></ul><h4 id="步骤-7：达到目标"><a href="#步骤-7：达到目标" class="headerlink" title="步骤 7：达到目标"></a>步骤 7：达到目标</h4><ul><li><code>start.equals(end)</code> 为 <code>true</code>，更新 <code>ans = 2</code></li></ul><h4 id="步骤-8：回溯"><a href="#步骤-8：回溯" class="headerlink" title="步骤 8：回溯"></a>步骤 8：回溯</h4><ul><li>取消标记 <code>used[2] = false</code>，<code>used[1] = false</code></li><li>返回到上一级递归</li></ul><p>最终，我们找到了从 <code>&quot;AACCGGTT&quot;</code> 到 <code>&quot;AAACGGTA&quot;</code> 的最少变化次数为 2。</p><p>总结</p><p>通过这个例子，我们可以看到 <code>diff</code> 是如何计算两个序列之间的差异，并且 <code>bank</code> 是如何被用来找到有效的中间步骤。代码通过递归和回溯，尝试所有可能的路径，直到找到最短的路径或确定不存在这样的路径。</p>]]></content>
    
    
    <summary type="html">回溯</summary>
    
    
    
    <category term="算法与数据结构" scheme="https://yjyrichard.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法与数据结构" scheme="https://yjyrichard.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
